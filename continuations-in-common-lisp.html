<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title></title>
	<meta name="generator" content="LibreOffice 6.0.7.3 (Linux)"/>
	<meta name="created" content="2021-12-26T22:19:33.783167778"/>
	<meta name="changed" content="2021-12-26T22:27:05.808209224"/>
	<style type="text/css">
		@page { margin: 2cm }
		p { margin-bottom: 0.25cm; line-height: 115% }
		h1 { margin-bottom: 0.21cm }
		h1.western { font-family: "Liberation Serif", serif }
		h1.cjk { font-family: "Noto Sans CJK SC"; font-size: 24pt }
		h1.ctl { font-family: "Lohit Devanagari"; font-size: 24pt }
		h2.cjk { font-family: "Noto Sans CJK SC" }
		h2.ctl { font-family: "Lohit Devanagari" }
		pre.cjk { font-family: "Courier New", monospace }
		a:link { so-language: zxx }
		code.cjk { font-family: "Courier New", monospace }
	</style>
</head>
<body lang="en-US" dir="ltr">
<h1 class="western"><a name="38de"></a>Продолжения в Common Lisp</h1>
<h2 class="western"><a name="4829"></a>Вводное руководство с использованием макросов 
передачи продолжения из книги Пола Грэма о Лиспе.</h2>

<p><a href="https://ashok-khanna.medium.com/?source=post_page-----1911cb413a03-----------------------------------">
  <font color="#000080">
    <img src="continuations-in-common-lisp_html_4b6b6a58fd97f750.jpg" name="Image1" alt="Ashok Khanna" align="bottom" width="28" height="28" border="1"/>
  </font>
</a>
</p>

<p><a href="https://ashok-khanna.medium.com/?source=post_page-----1911cb413a03-----------------------------------">Ashok
Khanna</a></p>

<p><a href="https://ashok-khanna.medium.com/continuations-in-common-lisp-1911cb413a03?source=post_page-----1911cb413a03-----------------------------------">Aug
17Â·7 min read</a></p>

<p><a name="a5cb"></a>Продолжение - сложная концепция, но она имеет определенную 
ценность в определенных приложениях. В этом руководстве я попытаюсь объяснить 
концепции и то, как реализовать продолжения в Common Lisp, надеюсь, это поможет 
в вашем понимании этой темы. Я подозреваю, что вам придется прочитать несколько 
разных объяснений из разных источников, и, надеюсь, одно из них понравится. 
Надеюсь, вы найдете приведенное ниже руководство полезным.</p>

<p style="margin-left: 1cm; margin-right: 1cm"><a name="b61d"></a>В Части 1 (эта страница) 
дается концептуальный обзор продолжений, а в Части 2 (которая выйдет в ближайшее время) 
подробно описывается возможная реализация в Common Lisp (на основе макросов 
передачи продолжения Пола Грэма из On Lisp). </p>

<h1 class="western"><a name="7e58"></a>Что такое продолжения?</h1>

<p><a name="168b"></a><a name="rmm"></a>Продолжением можно считать программу, 
замороженную в действии. Вы можете хранить этот объект столько, сколько захотите, 
и когда вы его вызовете, он перезапустит вычисления, происходившие при его создании.</p>

<p><a name="4cc0"></a>Мне нравится думать о продолжении как о 
книжной закладке(bookmark) в программе. Рассмотрим следующее выражение: </p>

<pre class="western"><a name="4eeb"></a><a name="40bf"></a>&gt; (+ 1 (+ 2 (+ 3 (+ 4 5))))
<a name="4b0c"></a>;; Which may be easier to read as follows:&gt; (+ 1
     (+ 2
        (+ 3
           (+ 4 5))))          </pre>
<p>
<a name="7eda"></a>Мы могли бы переписать эту программу как:</p>

<ol>
	<li/>
<p style="margin-bottom: 0cm"><a name="e750"></a> Складываем 4 и 5, получаем 9
</p>

	<li/>
<p style="margin-bottom: 0cm"><a name="973b"></a>Добавьте 3 к 
	результату шага 1 (9), чтобы получить 12</p>

	<li/>
<p style="margin-bottom: 0cm"><a name="936d"></a>Добавьте 2 к 
	результату шага 2 (12), чтобы получить 14</p>

	<li/>

<p><a name="0c2f"></a> Добавьте 1 к результату 
	шага 3 (14), чтобы получить 15</p>

</ol>

<p><a name="d01c"></a>Скажем, мы взяли продолжение после шага 2 и 
сохранили его в объекте с именем <code class="western">*cont*</code>. 
Это продолжение будет представлять собой оставшуюся часть вышеуказанной программы, 
а именно шаги 3 и 4. </p>

<p><a name="1c07"></a>Давайте немного поработаем с <strong><em>псевдокодом</em></strong>.
Предположим, мы можем вызвать это продолжение и передать значение, скажем 7, 
следующим образом: </p>

<pre class="western" style="margin-bottom: 0.5cm"><a name="71c9"></a>&gt; (*cont* 7)</pre>
<p>
<a name="f9ad"></a>Продолжение <code class="western">*cont*</code> является 
функциональным объектом, и здесь будет перезапущена оставшаяся часть программы 
(шаги 3 и 4 выше), но с использованием предоставленного значения (7), а не исходного 
значения в конце шага 2 (12). Таким образом, приведенное выше выражение вернет 10: </p>

<pre class="western" style="margin-bottom: 0.5cm"><a name="0758"></a><a name="dde2"></a><a name="4fae"></a>&gt; (*cont* 7)10;; Вышеупомянутое эквивалентно (+ 1 (+ 2 <strong>7</strong>)), 
где 7 - это значение, передаваемое в продолжение.</pre>
<h2 class="western">
<a name="d537"></a>Продолжение с другой точки зрения</h2>

<p><a name="f233"></a>Давайте вернемся к вышесказанному, но с другой точки зрения. 
Когда наш интерпретатор Common Lisp оценивает(вычисляет) предыдущее выражение, 
он вычисляет каждый член слева направо. Это имеет эффект опускания стека вызовов 
(теоретически - я не уверен, действительно ли стеки вызовов создаются для простого 
примера ниже, но вы можете представить себе тот же процесс для функций, вызывающих 
другие функции, и так далее). </p>

<p style="margin-bottom: 0cm"><br/>

</p>

<p><img src="continuations-in-common-lisp_html_2e749d048ab637c7.png" name="Image3" align="bottom" width="700" height="368" border="0"/>
</p>

<p><a name="a8a4"></a>Как только вычислитель достигает дна стека, он 
начинает возвращать значения  наверх. Вышеупомянутые четыре шага отражают 
этот процесс возврата. Таким образом, Lisp будет вычислять формы слева направо 
и вниз, а затем, когда все формы вычслены, он вернет значения навверх.
</p>

<p style="margin-left: 1cm; margin-right: 1cm"><a name="adba"></a>Чтобы помочь 
понять продолжения, эта вызуализация помогает, увидеть как Lisp вычисляет формы 
вниз и возвраты результатов форм наверх.</p>

<p><a name="f448"></a>Дайте нам знать, визуализируйте наше продолжение 
сверху с помощью нижеследующего. Если вы внимательно пройдетесь по нашему примеру, 
вы, надеюсь, увидите, что продолжение относится на самом деле к верхней части выражения, 
а не к нижней части. Таким образом, хотя продолжение относится к оставшейся части программы, 
как только мы понимаем, что возвращаемые значения возвращаются вверх, мы понимаем, что 
оставшаяся часть программы - это все формы выше точки, в которой мы берем продолжение, 
а не ниже ее. Для меня это был очень важный момент, так что, надеюсь, вы тоже его оцените. </p>

<p style="margin-bottom: 0cm"><br/>

</p>

<p><img src="continuations-in-common-lisp_html_1de0df2c0d1316f6.png" name="Image5" align="bottom" width="700" height="392" border="0"/>
</p>

<p style="margin-left: 1cm; margin-right: 1cm"><a name="11d9"></a>Итак, снова, 
для повторения, вычисляете вниз, но возвращайтесь вверх. Последними частями программы 
являются те, что находятся наверху, т. е. Последнее пришло - первое вышло, или, 
альтернативно, первое пришло последним :)</p>

<p><a name="89d8"></a>Тогда возникает естественный вопрос: что является нижней 
частью приведенной выше программы, а именно: </p>

<pre class="western" style="margin-bottom: 0.5cm"><a name="4c29"></a>&gt; (+ 3 (+ 4 5))</pre>
<p>
<a name="91b9"></a>Это просто нормальный вызов функции. Нам не нужны какие-либо 
специальные механизмы для его «сохранения» или повторного запуска - это просто 
простая форма, которую нам нужно запустить. Можно очень легко сохранить эти 
вызовы функций в переменной и вызывать их позже, примерно так: </p>

<pre class="western"><a name="4277"></a><a name="9b05"></a>&gt; (defvar *saved-form*)&gt; (let ((next-steps (lambda (a)
                      (+ 3 (+ 4 a)))))
    (setf *saved-form* next-steps)
<a name="28df"></a><a name="5f04"></a><a name="01b8"></a><a name="6ace"></a><a name="3495"></a>    (funcall next-steps 5))12&gt; *saved-form*#&lt;FUNCTION (LAMBDA (A)) {52C670EB}&gt;&gt; (funcall *saved-form* 5)12</pre><h2 class="western">
<a name="ec6a"></a>Так к чему ты клонишь?</h2>

<p><a name="8743"></a>Короче говоря, очень легко узнать, <strong><em>что происходит 
дальше</em></strong>, то есть формы, которые мы собираемся вычислить (например, в 
<code class="western">let</code> выше). 
Намного сложнее узнать, <strong><em>что произошло раньше</em></strong>, потому что для 
этого потребуется вернуться вверх по стеку вызовов до самого верхнего уровня, что-то, 
что можно сделать, но что-то, что не всегда очевидно из блока кода, который вы сейчас 
просматриваете.</p>

<p><a name="f555"></a>Например, как бы мы могли изобразить вышеупомянутое продолжение? 
Возможно, мы могли бы сделать </p>

<pre class="western"><a name="46bf"></a>&gt; (defun *cont* (a)
    (+ 1 (+ 2 a)))</pre>
<p>
<a name="6ab7"></a>Это не так уж плохо. Но представьте, если бы у нас было 
много уровней в нашем стеке вызовов, в том числе с рекурсиями. Насколько я понимаю, 
это непростая задача.</p>

<p><a name="c726"></a>Концептуально в функциональном программировании 
мы пишем сверху вниз (согласно схемам выше). Так что относительно легко следить за тем, 
что будет дальше, но мы склонны терять из виду то, что происходило раньше. </p>

<h2 class="western"><a name="dba6"></a>Императивное и декларативное программирование</h2>

<p><a name="56ad"></a>Я предполагаю, что центральная концепция во всем этом - 
разница между императивным и декларативным программированием.
<a href="https://stackoverflow.com/questions/17826380/what-is-difference-between-functional-and-imperative-programming-languages" target="_blank">Любезно предоставлено Stack Overflow</a>:</p>

<ul>
	<li/>
<p style="margin-bottom: 0cm"><a name="ba0b"></a>Императивный язык использует 
	последовательность утверждений(<strong>sequence of statements</strong>), чтобы определить, 
	как достичь определенной цели. Считается, что эти операторы изменяют состояние программы, 
	поскольку каждый из них выполняется по очереди.</p>

	<li/>

<p><a name="bdf2"></a> С другой стороны, функциональное программирование - 
	это форма декларативного программирования. Декларативное программирование - 
	это не императивный стиль программирования, при котором <strong>программы 
	описывают желаемые результаты без явного перечисления команд или шагов, 
	которые должны быть выполнены</strong>.</p>

</ul>

<p><a name="5a2c"></a>В нашем примере императивное программирование - 
это четыре шага, которые мы обозначили в начале, пошаговые команды о том, 
как выполнить программу от начала до конца. В таких стилях программирования 
относительно легко отслеживать следующие шаги, в конце концов, это 
пошаговый процесс.</p>

<p><a name="fc53"></a>С другой стороны, функциональный пример, который 
мы вам дали, был декларативным. На первом этапе мы сказали, дайте нам 
сумму 1 и (+ 2…). Последний объект еще не был рассчитан, мы просто сказали, 
что хотим. Только на последующих этапах мы работали в направлении вниз и 
вычисляли каждую часть этой формы и вычисляли значение, которое нужно 
добавить к 1.</p>

<p><a name="7059"></a>Можно подумать, что возврат значений наверх является 
императивным вычислением, выполняемым интерпретатором для вычисления 
окончательного результата после вычисления каждой части, то есть: </p>

<ul>
	<li/>
<p style="margin-bottom: 0cm"><a name="7f22"></a>Форма - это выражение того, 
	что мы хотим</p>

	<li/>
<p style="margin-bottom: 0cm"><a name="039a"></a>Вычисление(оценка) элементов формы → 
	Определение того, чего мы хотим</p>

	<li/>

<p><a name="e872"></a>Возврат значений → 
	Дает нам то, что мы хотим</p>

</ul>

<p><a name="e516"></a>В функциональном программировании легко спросить, 
чего мы хотим (т. е. Форма - это выражение того, что мы хотим), но сложнее 
выразить шаги, чтобы получить это. По этой причине продолжения, которые 
представляют собой остаток шагов программы в определенной точке программы, 
сложнее выразить вручную в функциональном программировании, поскольку стиль 
функциональной парадигмы затемняет эту часть («как») в пользу  «что». </p>

<p><a name="e381"></a>Возвращаясь к нашему предыдущему обсуждению, 
относительно легко попросить нижнюю часть <code class="western">(+ 3
(+ 4 5))</code>, поскольку это просто запрос того, что мы хотим; 
немного сложнее запросить верхнюю часть, потому что это остаток шагов 
в вычислении, а наш языковой стиль явно скрывает шаги вычисления («как») 
от шагов вычисления(оценки) (спрашивая «что» мы хотим ).</p>

<p><a name="d2a4"></a>Таким образом, продолжения являются важным механизмом 
для преодоления этого пробела, чтобы упростить выполнение оставшихся шагов программы. 
Я не эксперт, но, основываясь на вышеизложенном, я бы предположил, что продолжения 
имеют гораздо меньшее значение в императивных языках, потому что оставшиеся шаги 
программы очень очевидны на этих языках.</p>

<p><a name="2bf5"></a>И в качестве заключительной мысли к Части 1 этого 
руководства, я надеюсь, что приведенное выше уточнение подчеркивает 
важность понимания и использования продолжений в функциональном программировании, 
поскольку они представляют собой ключевой аспект ограничений самого 
языка (ограничения может быть не лучшим словом, но этот недостаток - 
просто результат функционального программирования, сосредоточенного на том, 
что мы хотим, а не на том, как этого достичь). </p>

<h1 class="western"><a name="a3a0"></a>Продолжения в Common Lisp (Часть 2) — Пик скрытности</h1>

<p><a name="6cae"></a>Давайте теперь продолжим и узнаем, как реализовать 
продолжения в Common Lisp. Ниже приведены необходимые нам макросы. Ой! 
Мы рассмотрим их во второй части руководства, которая вскоре выйдет. </p>

<pre class="western"><a name="2a10"></a><a name="d20d"></a><a name="7a61"></a>(defvar *actual-cont* #'identity)(define-symbol-macro *cont* *actual-cont*)(defmacro =defun (name parameters &amp;body body)
  (let ((f (intern (concatenate 'string
                                &quot;=&quot;
                                (symbol-name name)))))
    `(progn
       (defmacro ,name ,parameters
         `(,',f *cont* ,,@parameters))
       (defun ,f (*cont* ,@parameters)
<a name="92c3"></a>         ,@body))))(defmacro =bind (parameters expression &amp;body body)
  `(let ((*cont* #'(lambda ,parameters ,@body)))
<a name="432c"></a>     ,expression))(defmacro =values (&amp;rest return-values)
<a name="c5d0"></a>  `(funcall *cont* ,@return-values))(defmacro =funcall (fn &amp;rest arguments)
<a name="8ed6"></a>  `(funcall ,fn *cont* ,@arguments))(defmacro =apply (fn &amp;rest arguments)
<a name="ab35"></a>  `(apply ,fn *cont* ,@arguments))(defmacro =lambda (parameters &amp;body body)
  `#'(lambda (*cont* ,@parameters)
       ,@body))</pre>
</body>
</html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title></title>
	<meta name="generator" content="LibreOffice 6.0.7.3 (Linux)"/>
	<meta name="created" content="2021-12-26T22:06:50.020708769"/>
	<meta name="changed" content="2021-12-26T22:10:51.510572142"/>
	<style type="text/css">
		@page { margin: 2cm }
		p { margin-bottom: 0.25cm; line-height: 115% }
		h1 { margin-bottom: 0.21cm }
		h1.western { font-family: "Liberation Serif", serif }
		h1.cjk { font-family: "Noto Sans CJK SC"; font-size: 24pt }
		h1.ctl { font-family: "Lohit Devanagari"; font-size: 24pt }
		h2.cjk { font-family: "Noto Sans CJK SC" }
		h2.ctl { font-family: "Lohit Devanagari" }
		pre.cjk { font-family: "Courier New", monospace }
		a:link { so-language: zxx }
		code.cjk { font-family: "Courier New", monospace }
	</style>
</head>
<body lang="en-US" dir="ltr">
<h1 class="western"><a name="9c40"></a>Управление пакетами в Common Lisp - 
путь CLIM</h1>
<h2 class="western"><a name="fde4"></a>Изучите прошлое, чтобы стать лучше 
в будущем </h2>

<p><a href="https://ashok-khanna.medium.com/?source=post_page-----d3a334bc73ef-----------------------------------">
  <font color="#000080">
    <img src="https://miro.medium.com/fit/c/56/56/1*xfU-AcbKxxVOO8bTBILTpA.jpeg" name="Image1" alt="Ashok Khanna" align="bottom" width="28" height="28" border="1"/>
  </font>
</a>
</p>

<p><a href="https://ashok-khanna.medium.com/?source=post_page-----d3a334bc73ef-----------------------------------">Ashok
Khanna</a></p>

<p><a name="5d3b"></a>В начале 1990-х некоторые из самых ярких умов сообщества 
Common Lisp в то время объединили свои усилия для разработки переносимого GUI-фреймворка,
известного как <a href="https://en.wikipedia.org/wiki/Common_Lisp_Interface_Manager" target="_blank">Common Lisp Interface Manager (CLIM)</a>. Хотя CLIM в то время не прижился 
в массовых кругах программирования, <a href="http://bauhh.dyndns.org:8000/clim-spec/index.html" target="_blank">спецификации фреймворка</a> представляют собой мастер-класс по разработке 
больших и сложных объектно-ориентированных систем на Common Lisp.</p>

<p><a name="eca9"></a>Проект существует сегодня и <a href="https://github.com/McCLIM/McCLIM" target="_blank">активно развивается в форме McCLIM</a>, и проницательный читатель может принять
участие в этом проекте с открытым исходным кодом по двум причинам:</p>

<ul>
	<li/>
<p style="margin-bottom: 0cm"><a name="7555"></a>В Лиспе не так много качественных 
	и больших кодовых баз, которые можно было бы изучить для 
	самосовершенствования.</p>

	<li/>

<p><a name="69b7"></a> CLIM - отличный пример CLOS в действии. Хотя поначалу 
	трудно было разобраться в этом из-за множества классов и функций, потратив 
	немного времени на CLIM, вы, вероятно, получите откровение о том, как лучше 
	всего организовать большие и сложные программы.</p>

</ul>

<p><a name="e3c3"></a><a name="rmm"></a>В рамках сегодняшней дискуссии 
я хочу коснуться подхода CLIM к управлению пакетами, как это было подчеркнуто 
профессором <a href="http://metamodular.com/" target="_blank">Робертом Страндом</a> из IRC, 
старшим специалистом по информатике и основным разработчиком <a href="https://github.com/robert-strandh/SICL" target="_blank">SICL</a>, новой реализации Common Lisp, которая подчеркивает
модульность и переносимость.</p>

<p><a name="01fc"></a>Без лишних слов, приступим!</p>

<h1 class="western"><a name="0a7c"></a>Подход CLIM к управлению пакетами
</h1>

<p><a name="eaf6"></a>Прежде чем мы начнем, я хочу отметить, что мы предполагаем, 
что читатель имеет разумное представление о пакетах в Common Lisp. Не стесняйтесь 
ознакомиться с <a href="https://ashok-khanna.medium.com/an-introduction-to-lisp-packages-7a9ee352006e">моим вводным руководством</a> по пакетам, однако сегодняшняя 
тема находится на промежуточном уровне, поэтому вам может потребоваться некоторое время, 
чтобы идеи усвоились.
</p>

<p><a name="6694"></a>Двигаясь дальше, рассмотрим сценарий, в котором мы работаем 
с большой кодовой базой. Когда дело доходит до управления пакетами, возникают две 
конкурирующие проблемы:</p>

<ul>
	<li/>
<p style="margin-bottom: 0cm"><a name="1d1f"></a>Было бы идеально, если бы все символы 
	в кодовой базе были в одном пакете, чтобы избежать использования квалификаторов 
	пакетов или иным образом слишком сильно беспокоиться о том, какой символ в каком 
	пакете </p>

	<li/>
<p style="margin-bottom: 0cm"><a name="3220"></a>Однако наличие всех символов в 
	одном пакете в нескольких файлах затрудняет выделение ключевых символов в 
	конкретном файле. Именно по этой причине подход «один пакет/один файл» стал 
	довольно популярным, поскольку он позволяет легко отмечать экспортируемые 
	(т.е. наиболее важные) символы в конкретном файле.
</p>

	<li/>

<p><a name="15bb"></a>Хотя это также может быть достигнуто путем размещения 
	<code class="western">(export ...)</code>(экспорта) форм в каждом файле, 
	обычно предпочтительно перечислять все экспортируемые символы в одном месте, 
	а именно в определении пакета.</p>

</ul>

<p><a name="6d04"></a>Подход CLIM решает эти проблемы, и мы проиллюстрируем 
это на примере. Допустим, у нас есть следующие пакеты:</p>

<ul>
	<li/>
<p style="margin-bottom: 0cm"><a name="ebb3"></a>Пакет APP-MAIN, представляющий 
	завершенный пакет, предоставляемый пользователям. Допустим, он экспортирует 
	символы A, B, C, D и E.</p>

	<li/>

<p><a name="0b9d"></a>Три дополнительных пакета, скажем SUB-PACKAGE-1, SUB-PACKAGE-2 
	и SUB-PACKAGE-3. Скажем, все три подпакета используют символы друг друга, 
	но с точки зрения экспортируемых символов, SUB-PACKAGE-1 экспортирует A и B, 
	SUB-PACKAGE-2 экспортирует C, а SUB-PACKAGE-3 экспортирует D и E</p>

</ul>

<p><a name="0a54"></a>Подход CLIM заключается в следующем:</p>

<ul>
	<li/>

<p><a name="82ac"></a>Для всеобъемлющего основного пакета (APP-MAIN) 
	экспортируйте все символы следующим образом. </p>

</ul>
<pre class="western"><a name="b846"></a>(defpackage :app-main
  (:use)
  (:export #:A #:B #:C #:D #:E))</pre>
<ul>
	<li/>

<p><a name="e360"></a>Для каждого из подпакетов: 
	<code class="western">:use :app-main</code> и экспортируйте 
	соответствующие символы. Например: </p>

</ul>
<pre class="western"><a name="d759"></a>(defpackage :sub-package-1
  (:use :app-main)
  (:export #:A #:B))</pre>
<p>
<a name="44ad"></a>Конечным результатом является то, что</p>

<ul>
	<li/>
<p style="margin-bottom: 0cm"><a name="7be3"></a>Все ваши подпакеты 
	имеют полный доступ ко всем экспортируемым символам APP-MAIN.</p>

	<li/>
<p style="margin-bottom: 0cm"><a name="da6e"></a>Существует четкое 
	различие между внешними и внутренними символами APP-MAIN. Подпакет 
	может получить доступ только к внешним символам APP-MAIN без 
	квалификатора пакета и должен квалифицировать любые внутренние символы, 
	не интернированные в его пакете.</p>

	<li/>

<p><a name="67f7"></a>Очень легко отличить внешние и внутренние символы 
	любого субпакета. </p>

</ul>

<p><a name="c7d9"></a>Ключевой трюк, который выполняет CLIM, - это, 
	используя приведенный выше пример, перевернутое 
	использование пакета APP-MAIN:</p>

<ul>
	<li/>
<p style="margin-bottom: 0cm"><a name="dded"></a> Обычно экспортируемые 
	символы из подпакетов импортируются в основной пакет, но здесь 
	все наоборот.</p>

	<li/>
<p style="margin-bottom: 0cm"><a name="e5f6"></a>Подпакеты экспортируют символы 
	(при необходимости), которые они наследуют от основного пакета.
</p>

	<li/>

<p><a name="7a87"></a>Однако в то же время нет циклической зависимости между 
	субпакетами и основным пакетом, поскольку мы не импортируем символы 
	из субпакетов обратно в основной пакет.</p>

</ul>

<p><a name="42aa"></a>Все это может немного сбивать с толку, но прочтите все 
вышесказанное и, надеюсь, вы найдете это полезным трюком для использования в
своих программах!
</p>

<p><a name="623c"></a>Спасибо за чтение!</p>

<p><br/>
<br/>

</p>

</body>
</html>
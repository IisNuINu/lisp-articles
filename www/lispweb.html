<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title></title>
	<meta name="generator" content="LibreOffice 6.0.7.3 (Linux)"/>
	<meta name="created" content="2021-09-05T08:45:12.106549889"/>
	<meta name="changed" content="2021-09-05T08:47:05.039469734"/>
	<style type="text/css">
		@page { margin: 2cm }
		p { margin-bottom: 0.25cm; line-height: 115% }
		h1 { margin-bottom: 0.21cm }
		h1.western { font-family: "Liberation Serif", serif }
		h1.cjk { font-family: "Noto Sans CJK SC"; font-size: 24pt }
		h1.ctl { font-family: "Lohit Devanagari"; font-size: 24pt }
		h3.cjk { font-family: "Noto Sans CJK SC" }
		h3.ctl { font-family: "Lohit Devanagari" }
		h2.cjk { font-family: "Noto Sans CJK SC" }
		h2.ctl { font-family: "Lohit Devanagari" }
		pre.cjk { font-family: "Courier New", monospace }
		a:link { so-language: zxx }
	</style>
</head>
<body lang="en-US" dir="ltr">
<h1 class="western">Lisp для Web становится книгой
</h1>

<p><img src="lispweb_html_54c1d3d0a19dee23.jpg" name="Image1" alt="Lisp for the web - the book" align="left" hspace="5" width="234" height="324" border="0"/>
Следующая статья и код были обновлены как книга <a href="https://leanpub.com/lispweb">Lisp
для Web</a>. Вы можете получить его по любой цене на  <a href="https://leanpub.com/lispweb">Leanpub</a>.
</p>

<h1 class="western">Lisp для Web 
</h1>
<h3 class="western">by Adam Tornhill, April 2008 
</h3>

<pВ своем эссе <a href="http://www.paulgraham.com/avg.html" target="_top">Превосходя Посредственность </a> Пол Грэм рассказал историю о том, как его веб-стартап Viaweb 
превзошел своих конкурентов, используя Lisp. Лисп? Я правильно это разобрал? 
Этот древний язык со всеми этими пугающими скобками? Да, в самом деле! 
И чтобы определить его сильные стороны и то, что они могут для нас сделать, 
я заставлю Lisp работать над разработкой веб-приложения. В процессе мы узнаем, 
как язык 50-летней давности может быть настолько хорошо приспособлен для 
современной веб-разработки, и да, это связано со всеми этими скобками.  
</p>

<h2 class="western">Что ожидать 
</h2>

<p>С нуля разработаем трехуровневое веб-приложение. Я покажу, как: 
</p>

<ul>
	<li/>
<p style="margin-bottom: 0cm">использовать мощные библиотеки с открытым 
	исходным кодом для выражения динамического HTML и JavaScript в Lisp, 
	</p>

	<li/>
<p style="margin-bottom: 0cm">разработать небольшой встроенный предметно-ориентированный 
	язык(domain specific language - DSL), адаптированный для моего приложения, 
	</p>

	<li/>
<p style="margin-bottom: 0cm">расширить типичный цикл разработки, изменяя код в 
	работающей системе и выполняя код во время компиляции,
	</p>

	<li/>

<p>и, наконец, перейти от структур данных в памяти к постоянным объектам 
	с помощью сторонней базы данных. 
	</p>

</ul>

<p>Я сделаю это в живой системе, прозрачной для пользователей приложения. 
Поскольку Lisp очень высокоуровневый, я смогу достичь всего примерно за 
70 строк кода.  
</p>

<p>Эта статья не научит вас Common Lisp (для этой цели я рекомендую 
<a href="https://www.adamtornhill.com/reviews/pcl.htm" target="_top">Практический 
Common Lisp </a>). Вместо этого я дам краткий обзор языка и попытаюсь 
объяснить концепции по мере их введения, достаточно, чтобы следовать коду. 
Идея состоит в том, чтобы передать ощущение того, как нужно развиваться в Lisp, а
 не сосредотачиваться на деталях.
</p>

<h2 class="western">История Лиспа  
</h2>

<p>Лисп - это фактически семейство языков, открытых Джоном Маккарти 50 лет назад. 
Характерной чертой Лиспа является то, что код Лиспа состоит из структур данных 
Лиспа с практическим подтекстом, о том что не только естественно, но и очень эффективно 
писать программы, которые пишут программы. Эта функция позволила Lisp адаптироваться 
на протяжении многих лет. Например, когда стало популярным объектно-ориентированное
программирование, на Лиспе можно было реализовать мощные объектные системы 
в виде библиотек без каких-либо изменений в базовом языке. Позже то же самое 
подтвердилось и для аспектно-ориентированного программирования.
</p>

<p>Эта идея применима не только ко всем парадигмам программирования. 
Его истинная сила - в решении повседневных проблем. С Lisp легко создать 
предметно-ориентированный язык(DSL), позволяющий нам программировать 
настолько близко к предметной области, насколько позволяет наше воображение. 
Я скоро проиллюстрирую эту концепцию, но прежде чем мы начнем, давайте 
подробнее рассмотрим синтаксис Lisp. 
</p>

<h2 class="western">Ускоренный курс по Lisp
</h2>

<p>То, что Грэм использовал для Viaweb, был Common Lisp, стандартизированным 
языком ANSI, который мы будем использовать и в этой статье (другой главный 
претендент - Scheme, который считается более чистым и элегантным, 
но с гораздо меньшей библиотекой).
</p>

<p>Common Lisp - это интерактивный язык высокого уровня, который можно 
интерпретировать или компилировать. Вы взаимодействуете с Лиспом через 
его <i>верхний уровень</i>. Верхний уровень - это, по сути, подсказка. 
В моей системе это выглядит так:  
</p>

<pre class="western">        CL-USER&gt;
      </pre>
<p>
Через верхний уровень мы можем вводить выражения и видеть результаты 
(значения, возвращаемые верхним уровнем, <b>выделяются</b>): 
</p>

<pre class="western">        CL-USER&gt;(+ 1 2 3)
        <b>6</b>
      </pre>
<p>
Как мы видим в примере, Lisp использует префиксную нотацию. Выражение в скобках 
называется <i>формой</i>. При загрузке такой формы, как (+ 1 2 3), Lisp обычно 
обрабатывает первый элемент (+) как функцию, а остальные как аргументы. 
Аргументы вычисляются слева направо и сами могут быть вызовами функций:  
</p>

<pre class="western">        CL-USER&gt;(+ 1 2 (/ 6 2))
        <b>6</b>
      </pre>
<p>
Мы можем <b>определить</b> наши собственные <b>функции</b> с помощью defun:  
</p>

<pre class="western">        CL-USER&gt;(defun say-hello (to)
                    (format t &quot;Hello, ~a&quot; to))
      </pre>
<p>
Здесь мы определяем функцию say-hello, принимая один аргумент: to. 
Функция format используется для печати приветствия и напоминает 
printf на стероидах. Её первый аргумент - это выходной поток, и здесь 
мы используем t как сокращение для стандартного вывода. Второй аргумент - 
это строка, которая в нашем случае содержит встроенную директиву ~ 
формат инструкции для использования одного аргумента и вывода его в 
удобочитаемой форме. Мы можем вызвать нашу функцию так:  
</p>

<pre class="western">        CL-USER&gt;(say-hello &quot;ACCU&quot;)
        <b>Hello, ACCU</b>
        <b>NIL</b>
      </pre>
<p>
Первая строка - это побочный эффект, печати &quot;Hello, ACCU&quot, а 
NIL - это возвращаемое значение из нашей функции. По умолчанию Common Lisp 
возвращает значение последнего выражения. Отсюда мы можем переопределить 
say-hello, чтобы вместо этого возвращалось его приветствие: 
</p>

<pre class="western">        CL-USER&gt;(defun say-hello (to)
                     (format nil &quot;Hello, ~a&quot; to))
      </pre>
<p>
Если в качестве места назначения используется nil, format просто 
возвращает результирующую строку:  
</p>

<pre class="western">        CL-USER&gt;(say-hello &quot;ACCU&quot;)
        <b>&quot;Hello, ACCU&quot;</b>
      </pre>
<p>
Теперь мы избавились от побочного эффекта. Программирование без побочных 
эффектов находится в русле функционального программирования, одной из парадигм, 
поддерживаемых Lisp. Lisp также имеет динамическую типизацию. Таким образом, 
мы можем вместо этого скормить нашей функции число:  
</p>

<pre class="western">        CL-USER&gt;(say-hello 42)
        <b>&quot;Hello, 42&quot;</b>
      </pre>
<p>
В Лиспе функции - это  граждане первого класса. Это означает, что мы можем 
создавать их, как любой другой объект, и передавать их в качестве аргументов 
другим функциям. Такие функции, принимающие функции в качестве аргументов, 
называются <i>функциями высшего порядка</i>. Один из примеров - mapcar. 
mapcar принимает функцию в качестве первого аргумента и впоследствии 
применяет ее к элементам одного или нескольких заданных списков:  
</p>

<pre class="western">        CL-USER&gt;(mapcar #'say-hello (list &quot;ACCU&quot; 42 &quot;Adam&quot;))
        <b>(&quot;Hello, ACCU&quot; &quot;Hello, 42&quot; &quot;Hello, Adam&quot;)</b>
      </pre>
<p>
Забавный #'- это просто ярлык для доступа к объекту функции. Как вы видите выше, 
mapcar собирает результат каждого вызова функции в список, который является ее 
возвращаемым значением. Это возвращаемое значение, конечно, может служить аргументом 
еще одной функции: 
</p>

<pre class="western">        CL-USER&gt;(sort (mapcar #'say-hello (list &quot;ACCU&quot; 42 &quot;Adam&quot;)) #'string-lessp)
        <b>(&quot;Hello, 42&quot; &quot;Hello, ACCU&quot; &quot;Hello, Adam&quot;)</b>
      </pre>
<p>
Сам по себе Lisp несложен, хотя может потребоваться некоторое время, 
чтобы понять функциональный стиль программирования. Как видите, выражения 
Lisp лучше всего читать изнутри-наружу. Но настоящий секрет понимания синтаксиса 
Лиспа состоит в том, чтобы понять, что <b>его</b> нет в языке; то, что мы ввели выше, 
- это в основном деревья синтаксического анализа, генерируемые компиляторами 
на других языках. И, как мы скоро увидим, именно эта функция делает его пригодным 
для метапрограммирования. 
</p>

<h2 class="western">Братья - это история 
</h2>

<p>Помните горячие игровые дискуссии 20 лет назад? &quot;Giana
Sisters&quot;(Сестры Джиана) действительно были намного лучше, 
чем &quot;Super Mario Bros&quot;, не так ли? Мы передадим вопрос 
мудрым людям, разработав веб-приложение. Наше веб-приложение позволит 
пользователям добавлять и голосовать за свои любимые ретро-игры. 
Снимок экрана с конечным результатом представлен на рисунке 1 ниже. 
</p>

<p><img src="lispweb_html_310c1b6fb5144efb.png" name="Image2" alt="Retro Games front page" align="bottom" width="800" height="625" border="0"/>

</p>

<p>С этого момента я начинаю сохранять свой код на Лиспе в текстовых файлах 
вместо того, чтобы просто вводить выражения на верхнем уровне. Далее я определяю 
пакет для своего кода. Пакеты похожи на пространства имен в пакетах C ++ или Java 
и помогают предотвратить конфликты имен (главное отличие состоит в том, что пакеты 
в Common Lisp являются объектами первого класса). 
</p>

<pre class="western">        (defpackage :retro-games
             (:use :cl :cl-who :hunchentoot :parenscript))
      </pre>
<p>
Новый пакет называется :retro-games, и я также указываю другие пакеты, 
которые мы будем использовать изначально:
</p>

<ul>
	<li/>
<p style="margin-bottom: 0cm"> CL - стандартный пакет Common Lisp, 
	содержащий весь язык.
	</p>

	<li/>
<p style="margin-bottom: 0cm"><a href="http://weitz.de/cl-who/" target="_top">CL-WHO
	</a>это библиотека для преобразования выражений Lisp в XHTML. 
	</p>

	<li/>
<p style="margin-bottom: 0cm"><a href="http://weitz.de/hunchentoot/" target="_top">Hunchentoot
	</a> это веб-сервер, написанный на самом Common Lisp и предоставляющий 
	инструментарий для создания динамических веб-сайтов.
 	</p>

	<li/>

<p><a href="http://common-lisp.net/project/parenscript/" target="_top">ParenScript
	</a>позволяет нам компилировать выражения Lisp в JavaScript. Мы будем 
	использовать его для проверки на стороне клиента. 
	</p>

</ul>

<p>Имея определение моего пакета, я помещу в него остальной код, 
переключившись на пакет :retro-games :  
</p>

<pre class="western">        (in-package :retro-games)
      </pre>
<p>
Большинство верхних уровней указывают текущий пакет в своем приглашении. 
В моей системе приглашение теперь выглядит так:  
</p>

<pre class="western">        RETRO-GAMES&gt;
      </pre><h2 class="western">
Представление игр 
</h2>

<p>Когда пакет на месте, мы можем вернуться к проблеме. Кажется, она требует 
некоторого представления игры, и я предпочитаю абстрагировать её как класс: 
</p>

<pre class="western">        (defclass game ()
            ((name  :initarg  :name)
             (votes :initform 0)))
      </pre>
<p>
Выражение выше определяет класс game без каких-либо определяемых 
пользователем суперклассов, поэтому пустой список () является 
вторым аргументом. В игре есть два <i>slots</i>(слота) (слоты аналогичны 
атрибутам или членам на других языках): name(имя) и количество набранных голосов. 
Чтобы создать игровой объект, я вызываю make-instance и передаю ему имя класса 
для создания экземпляра: 
</p>

<pre class="western">        RETRO-GAMES&gt;(setf many-lost-hours (make-instance 'game :name &quot;Tetris&quot;))
        <b>#&lt;GAME @ #x7213da32&gt;</b>
      </pre>
<p>
Поскольку я указал <b>начальный аргумент</b> в моем определении слота 
name(имени), я могу передать этот аргумент напрямую и инициализировать 
этот слот как &quot;Tetris&quot;. Слот votes(голоса) не имеет начального аргумента. 
Вместо этого я указываю код, который хочу запустить во время создания экземпляра,
чтобы вычислить его начальное значение с помощью :initform. В этом случае код тривиален, 
так как я хочу только инициализировать количество голосов нулем. Кроме того, я использую
setf для присвоения объекта, созданного make-instance, переменной many-lost-hours. 
</p>

<p>Теперь, когда у нас есть экземпляр игры, мы хотели бы что-то с ним сделать. 
Конечно, мы могли бы сами написать код для доступа к слотам. Однако есть более 
лисповый способ; defclass предоставляет возможность автоматически генерировать 
функции доступа для наших слотов(accessor):  
</p>

<pre class="western">        (defclass game ()
          ((name  <b>:reader   name</b> 
                  :initarg  :name)
           (votes <b>:accessor votes</b> 
                  :initform 0)))
      </pre>
<p>
Опция :reader в слоте имени автоматически создаст функцию чтения, а 
опция :accessor, используемая для слота votes(голосов), создаст функции 
как чтения, так и записи. Lisp приятно единообразен по синтаксису, и эти 
сгенерированные функции вызываются так же, как и любые другие функции: 
</p>

<pre class="western">        RETRO-GAMES&gt;(name many-lost-hours)
        <b>&quot;Tetris&quot;</b>
        RETRO-GAMES&gt;(votes many-lost-hours)
        <b>0</b>
        RETRO-GAMES&gt;(incf (votes many-lost-hours))
        <b>1</b>
        RETRO-GAMES&gt;(votes many-lost-hours)
        <b>1</b>
      </pre>
<p>
Единственная новая функция здесь - incf, которая при задании одного аргумента 
увеличивает свое значение на единицу. Мы можем инкапсулировать этот механизм 
в метод, используемый для голосования за данную игру: 
</p>

<pre class="western">        (defmethod vote-for (user-selected-game)
           (incf (votes user-selected-game)))
      </pre>
<p>
Верхний уровень позволяет сразу опробовать и проголосовать за Tetris:  
</p>

<pre class="western">        
       RETRO-GAMES&gt;(votes many-lost-hours)
       <b>1</b>
       RETRO-GAMES&gt;(vote-for many-lost-hours)
       <b>2</b>
       RETRO-GAMES&gt;(votes many-lost-hours)
       <b>2</b>
      </pre><h2 class="western">
Прототип серверной части(back end) 
</h2>

<p>Прежде чем мы сможем окунуться в радость создания веб-страниц, 
нам понадобится серверная часть для нашего приложения. Поскольку Lisp 
позволяет легко изменять существующие приложения, обычно начинают очень 
просто и позволяют развивать разработку по мере того, как мы узнаем 
больше о проблеме, которую пытаемся решить. Таким образом, я начну с 
использования списка в памяти как простого непостоянного(non-persistent) 
хранилища.  
</p>

<pre class="western">        (defvar *games* '())
      </pre>
<p>
Выражение выше определяет и инициализирует глобальную переменную 
(фактически термин Lisp - это <i>специальная переменная</i>) *games* 
пустым списком. Звездочки не являются частью синтаксиса; это просто 
соглашение об именах для глобальных объектов. Списки могут быть не 
самой эффективной структурой данных для всех проблем, но Common Lisp 
отлично поддерживает списки, и с ними легко работать. Позже мы перейдем 
к настоящей базе данных, и, имея это в виду, я инкапсулирую доступ к 
*games* в несколько небольших функций: 
</p>

<pre class="western">        (defun game-from-name (name)
          (find name *games* :test #'string-equal 
                             :key  #'name))
      </pre>
<p>
Наша первая функция game-from-name реализована в терминах find. 
find принимает элемент и последовательность. Поскольку мы сравниваем строки, 
я говорю find использовать для сравнения функцию string-equal (помните, 
#'- это сокращение для ссылки на функцию). Также указываю ключ для сравнения. 
В данном случае нас интересует сравнение значения, возвращаемого функцией 
name для каждого  объекта game.
</p>

<p>Если совпадений нет, find возвращает NIL, что в логическом контексте 
принимает значение false. Это означает, что мы можем повторно использовать 
game-from-name, когда хотим знать, хранится ли игра в списке *games*. 
Однако мы хотим прояснить наши намерения: 
</p>

<pre class="western">        (defun game-stored? (game-name)
         (game-from-name game-name))
      </pre>
<p>
Как показано на рисунке 1, мы хотим представить игры, отсортированные по популярности. 
Это довольно просто сделать с помощью функции сортировки Common Lisp; нам нужно только
позаботиться, потому что по соображениям эффективности сортировка деструктивна. 
То есть sort может изменять свой аргумент. Мы можем сохранить наш список *games*, 
передав копию для сортировки. Я говорю sort возвращать список, отсортированный 
в порядке убывания на основе значения, возвращаемого функцией votes, вызываемой 
для каждой game(игры):  
</p>

<pre class="western">        (defun games ()
         (sort (copy-list *games*) #'&gt; :key #'votes))
      </pre>
<p>
Пока что запросы. Определим еще одну утилиту для фактического добавления 
игр в наше хранилище:  
</p>

<pre class="western">        (defun add-game (name)
         (unless (game-stored? name)
           (push (make-instance 'game :name name) *games*)))
      </pre>
<p>
push - это модифицирующая операция, которая добавляет game(игру), 
созданную make-instance, в список *games*. Давайте попробуем все 
это на высшем уровне. 
</p>

<pre class="western">        
      RETRO-GAMES&gt;(games)
      <b>NIL</b>
      RETRO-GAMES&gt;(add-game &quot;Tetris&quot;)
      <b>(#&lt;GAME @ #x71b943c2&gt;)</b>
      RETRO-GAMES&gt;(game-from-name &quot;Tetris&quot;)
      <b>#&lt;GAME @ #x71b943c2&gt;</b>
      RETRO-GAMES&gt;(add-game &quot;Tetris&quot;)
      <b>NIL</b>
      RETRO-GAMES&gt;(games)
      <b>(#&lt;GAME @ #x71b943c2&gt;)</b>
      RETRO-GAMES&gt;(mapcar #'name (games))
      <b>(&quot;Tetris&quot;)</b>
      </pre>
<p>
Значения, возвращаемые на верхний уровень, могут выглядеть не 
слишком информативными. По сути, это печатное представление объекта game. 
Common Lisp позволяет нам настраивать способ печати объекта, но мы не будем 
вдаваться в подробности. Вместо этого, с этим прототипом серверной части, 
мы готовы войти в Интернет.  
</p>

<h2 class="western">Генерация HTML динамически 
</h2>

<p>Первым шагом в разработке встроенного предметно-ориентированного языка 
является поиск лисп-представления целевого языка. Для HTML это действительно 
просто, поскольку и HTML, и Lisp представлены в виде древовидной структуры, 
хотя Lisp менее подробен. Вот пример использования библиотеки CL-WHO:  
</p>

<pre class="western">        
       (with-html-output (*standard-output* nil :indent t)
           (:html
              (:head
                 (:title &quot;Test page&quot;))
              (:body
                 (:p &quot;CL-WHO is really easy to use&quot;))))
      </pre>
<p>
Этот код будет расширен до следующего HTML, который выводится в
*standard-output* : 
</p>

<pre class="western">        
       &lt;html&gt;
          &lt;head&gt;
             &lt;title&gt;Test page &lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
             &lt;p&gt; CL-WHO is really easy to use &lt;/p&gt;
          &lt;/body&gt;
       &lt;/html&gt;
      </pre>
<p>
CL-WHO aтакже позволяет нам встраивать выражения Лиспа, настраивая 
сцену для динамических веб-страниц.  
</p>

<h2 class="western">Макросы: борьба со злом дублирования кода
</h2>

<p>Хотя CL-WHO обеспечивает более точное представление, чем сырой HTML, 
мы все еще сталкиваемся с потенциальным риском дублирования кода; 
теги html, head и body образуют шаблон, который будет повторяться 
на всех страницах. И станет только хуже, когда мы начнем писать строгий и 
проверяющий XHTML 1.0, где нам придется включать больше тегов и атрибутов и, 
конечно же, начинать каждую страницу с этой забавной строки DOCTYPE.  
</p>

<p>Кроме того, если вы посмотрите на рисунок 1, вы заметите, что на 
странице ретро-игр есть заголовок с изображением этого прекрасного 
Commodore (фото Билла Бертрама - спасибо!) И ремешок. Я хочу иметь 
возможность определить этот заголовок один раз, и все мои страницы 
будут использовать его автоматически. Проблема требует подходящей абстракции, 
и в этом Лисп отличается от других языков. В Лиспе мы фактически можем 
взять на себя роль разработчика языка и расширить язык нашим собственным синтаксисом. 
Функциональность которая позволяет это сделать, - это макросы. Синтаксически 
макросы выглядят как функции, но представляют собой совершенно разные зверюги. 
Конечно, точно так же, как макросы функций принимают аргументы. Разница в том, 
что аргументы макросов - это исходный код, потому что макросы используются 
компилятором для генерации кода.  
</p>

<p>Макросы могут быть концептуальной проблемой, поскольку они стирают 
грань между временем компиляции и временем выполнения. Макросы расширяются 
в код, который фактически компилируется. При своем расширении макросы имеют 
доступ ко всему языку, включая другие макросы, и могут вызывать функции, 
создавать объекты и т. Д.
</p>

<p>Итак, давайте задействуем этот удивительный механизм макросов, 
определив новую синтаксическую конструкцию, standard-page(стандартную страницу). 
standard-page абстрагирует весь шаблонный код XHTML и автоматически 
генерирует заголовок на каждой странице. Макрос примет два аргумента. 
Первый - это заголовок страницы, а второй - код, определяющий тело фактической 
веб-страницы. Вот простой пример использования: 
</p>

<pre class="western">        
       (standard-page (:title &quot;Retro Games&quot;)
                      (:h1 &quot;Top Retro Games&quot;)
                      (:p &quot;We'll write the code later...&quot;))
      </pre>
<p>
Большая часть макроса будет простыми конструкциями CL-WHO. Используя 
синтаксис обратной кавычки (символьный знак `), мы можем указать шаблон 
для кода, который мы хотим сгенерировать: 
</p>

<pre class="western">        
       (defmacro standard-page ((&amp;key title) &amp;body body)
         `(with-html-output-to-string (*standard-output* nil :prologue t :indent t)
           (:html :xmlns &quot;http://www.w3.org/1999/xhtml&quot;
                  :xml\:lang &quot;en&quot; 
                  :lang &quot;en&quot;
                  (:head 
                   (:meta :http-equiv &quot;Content-Type&quot; 
                          :content    &quot;text/html;charset=utf-8&quot;)
                   (:title <b>,title</b>)
                   (:link :type &quot;text/css&quot; 
                          :rel &quot;stylesheet&quot;
                          :href &quot;/retro.css&quot;))
                  (:body 
                   (:div :id &quot;header&quot; ; Retro games header
                         (:img :src &quot;/logo.jpg&quot; 
                               :alt &quot;Commodore 64&quot; 
                               :class &quot;logo&quot;)
                         (:span :class &quot;strapline&quot; 
                                &quot;Vote on your favourite Retro Game&quot;))
                   ,@<b>body</b>))))
      </pre>
<p>
Внутри выражения, заключенного в обратные кавычки, мы можем 
использовать , (запятую) для вычисления аргумента и ,@ (запятая-at), 
чтобы вычислить и объединить аргумент список. Помните, что 
аргументы макроса - это код. В этом примере первый аргумент title
привязан к &quot;Retro Games&quot;, а второй аргумент body
содержит выражения :h1 и :p, заключенные в списке. В определении 
макроса код, связанный с этими аргументами, просто вставляется 
в нужные места в нашем коде шаблона, заключенном в обратные кавычки. 
</p>

<p>Мощь, которую мы получаем от макросов, становится очевидной, 
когда мы смотрим на сгенерированный код. Три строки в приведенном 
выше примере использования расширяются в это (обратите внимание, 
что символы Lisp нечувствительны к регистру и поэтому обычно 
представлены в верхнем регистре):  
</p>

<pre class="western">        
       (WITH-HTML-OUTPUT-TO-STRING (*STANDARD-OUTPUT* NIL :PROLOGUE T :INDENT T)  
        (:HTML :XMLNS &quot;http://www.w3.org/1999/xhtml&quot;
               :|XML:LANG| &quot;en&quot; 
               :LANG &quot;en&quot;
               (:HEAD
                (:META :HTTP-EQUIV &quot;Content-Type&quot; 
                       :CONTENT &quot;text/html;charset=utf-8&quot;)
                <b>(:TITLE &quot;Retro Games&quot;)</b>
                (:LINK :TYPE &quot;text/css&quot; 
                       :REL &quot;stylesheet&quot; 
                       :HREF &quot;/retro.css&quot;))
               (:BODY
                (:DIV :ID &quot;header&quot;
                      (:IMG :SRC &quot;/logo.jpg&quot; 
                            :ALT &quot;Commodore 64&quot; 
                            :CLASS &quot;logo&quot;)
                      (:SPAN :CLASS &quot;strapline&quot; 
                             &quot;Vote on your favourite Retro Game&quot;))
                <b>(:H1 &quot;Top Retro Games&quot;)</b>
                <b>(:P &quot;We'll write the code later...&quot;)</b>)))
      </pre>
<p>
Это большая победа; все это код, который нам не нужно писать. 
Теперь, когда у нас есть краткий способ выразить веб-страницы 
с помощью единообразного вида, пришло время представить Hunchentoot. 
</p>

<h2 class="western">Больше, чем опера 
</h2>

<p>Hunchentoot Эди Вейца, названный в честь научно-фантастической 
оперы Заппы, представляет собой полнофункциональный веб-сервер,
написанный на Common Lisp. Чтобы запустить Hunchentoot, мы просто 
вызываем его функцию start-server: 
</p>

<pre class="western">        RETRO-GAMES&gt;(start-server :port 8080)
      </pre>
<p>
start-server поддерживает несколько аргументов, но нас интересует 
только указать порт, отличный от порта по умолчанию 80. 
И все - сервер запущен и работает. Мы можем проверить это, указав 
в веб-браузере адрес http://localhost:8080/, который должен отображать 
страницу Hunchentoot по умолчанию. Чтобы что-то опубликовать, 
мы должны предоставить Hunchentoot <i>handler</i>(обработчик). 
В Hunchentoot все запросы динамически отправляются соответствующему 
обработчику, а фреймворк содержит несколько функций для определения 
диспетчеров(распределителей сообщений). Приведенный ниже код создает 
диспетчер и добавляет его в таблицу диспетчеризации Hunchentoot:  
</p>

<pre class="western">        (push (create-prefix-dispatcher &quot;/retro-games.htm&quot; 'retro-games) *dispatch-table*)
      </pre>
<p>
Диспетчер будет вызывать функцию retro-games всякий раз, когда 
запрос URI начинается с /retro-games.htm. Теперь нам просто 
нужно определить функцию retro-games, которая генерирует HTML:  
</p>

<pre class="western">        
       (defun retro-games ()
         (standard-page (:title &quot;Retro Games&quot;)
                        (:h1 &quot;Top Retro Games&quot;)
                        (:p &quot;We'll write the code later...&quot;)))
      </pre>
<p>
Вот и вся - онлайн-страница ретро-игр. Но я бы не спешил праздновать; 
Хотя мы постарались абстрагироваться от повторяющихся шаблонов на 
стандартной странице, мы только что столкнулись с другой, более 
тонкой формой дублирования. Проблема в том, что каждый раз, 
когда мы хотим создать новую страницу, мы должны явно создавать 
диспетчер для нашего обработчика. Было бы неплохо, если бы 
Lisp мог делать это за нас автоматически? В основном я 
хочу определить такую функцию: 
</p>

<pre class="western">        
       (define-url-fn (retro-games)
         (standard-page (:title &quot;Retro Games&quot;)
                        (:h1 &quot;Top Retro Games&quot;)
                        (:p &quot;We'll write the code later...&quot;)))
      </pre>
<p>
и попросил Lisp создать обработчик, связать его с диспетчером и поместить 
в таблицу диспетчеризации по мере компиляции кода. Угадайте, какой синтаксис
использует наш макрос. Все, что нам нужно сделать, это переформулировать 
наши пожелания в defmacro:  
</p>

<pre class="western">        
       (defmacro define-url-fn ((name) &amp;body body)
         `(progn
            (defun ,<b>name</b> ()
              ,@<b>body</b>)
            (push (create-prefix-dispatcher ,(format nil &quot;/~(~a~).htm&quot; <b>name</b>) ',<b>name</b>) *dispatch-table*)))
      </pre>
<p>
Теперь наш &quot;wish code&quot;(код пожелания) указанного выше фактически компилируется 
и генерирует следующий код Лиспа (аргументы макроса <b>выделены</b>): 
</p>

<pre class="western">        
       (PROGN 
        (DEFUN <b>RETRO-GAMES ()</b>
          <b>(STANDARD-PAGE (:TITLE &quot;Retro Games&quot;)</b>
                         <b>(:H1 &quot;Top Retro Games&quot;)</b>
                         <b>(:P &quot;We'll write the code later...&quot;)))</b>
        (PUSH (CREATE-PREFIX-DISPATCHER &quot;/<b>retro-games</b>.htm&quot; '<b>RETRO-GAMES</b>) *DISPATCH-TABLE*))
      </pre>
<p>
В этом макросе есть несколько интересных моментов: 
</p>

<ol>
	<li/>
<p style="margin-bottom: 0cm"> Он показывает, что макросы могут принимать 
	другие макросы в качестве аргументов. Компилятор Lisp продолжит 
	расширять макросы, и standard-page тоже будет расширена, написав 
	для нас еще больше кода. 
	</p>

	<li/>
<p style="margin-bottom: 0cm">Макросы могут выполнять код по мере их расширения. 
	Строка префикса &quot;/retro-games.htm&quot; собирается с format(форматом)
	во время раскрытия макроса. Используя запятую, я вычисляю форму, и в 
	сгенерированном коде ее нет и следа - только результирующая строка. 
	</p>

	<li/>

<p>Макрос должен разворачиваться в единую форму, но на самом деле 
	нам нужны две формы; определение функции и код для создания 
	диспетчера. progn решает эту проблему, объединяя формы в 
	единую форму и затем вычисляя их по порядку. 
	</p>

</ol>
<h2 class="western">Собираем все вместе 
</h2>

<p>Уф, это было много Лиспа за короткое время. Но используя созданные 
нами абстракции, мы можем быстро собрать приложение. Давайте закодируем 
главную страницу, как показано на рисунке 1 выше: 
</p>

<pre class="western">        
       (define-url-fn (retro-games)
         (standard-page (:title &quot;Top Retro Games&quot;)
                        (:h1 &quot;Vote on your all time favourite retro games!&quot;)
                        (:p &quot;Missing a game? Make it available for votes &quot; (:a :href &quot;new-game.htm&quot; &quot;here&quot;))
                        (:h2 &quot;Current stand&quot;)
                        (:div :id &quot;chart&quot; ; <b>For CSS styling of links</b>
                              (:ol
                               (dolist (game (games))
                                 (htm  
                                  (:li 
                                   (:a :href (format nil &quot;vote.htm?name=~a&quot; (name game)) &quot;Vote!&quot;)
                                   (fmt &quot;~A with ~d votes&quot; (name game) (votes game)))))))))
      </pre>
<p>
Здесь мы используем наш недавно разработанный встроенный предметно-ориентированный 
язык для определения функций URL (define-url-fn) и создания стандартных страниц
(standard-pages). Следующие строки представляют собой простую генерацию XHTML, 
включая ссылку на  <i>new-game.htm</i>; страницу, которую мы еще не указали. 
Мы будем использовать некоторый CSS, чтобы стилизовать голосование! ссылки 
выглядят и работают как кнопки, поэтому я заключил список в тег div.
</p>

<p>Первый встроенный код Lisp - это dolist. Мы используем его для создания 
каждого элемента game в упорядоченном HTML-списке. dolist работает, 
перебирая список, в данном случае возвращаемое значение из -функции games, 
впоследствии привязывая каждый элемент к игровой переменной. Используя 
формат и методы доступа к объекту game, я собираю презентацию и место
 назначения для голосования !. Вот пример вывода HTML из одного сеанса:  
</p>

<pre class="western">        
      &lt;div id='chart'&gt;
         &lt;ol&gt;
            &lt;li&gt;
               &lt;a href='vote.htm?name=Super Mario Bros'&gt;Vote!&lt;/a&gt; Super Mario Bros with 12 votes
            &lt;/li&gt;
            &lt;li&gt;
               &lt;a href='vote.htm?name=Last Ninja'&gt;Vote!&lt;/a&gt; Last Ninja with 11 votes
            &lt;/li&gt;
         &lt;/ol&gt;
      &lt;/div&gt;
      </pre>
<p>
Когда пользователь нажимает "Голосовать!" мы получим запрос на vote.htm 
с именем игры, прикрепленным в качестве параметра запроса. Hunchentoot 
предоставляет функцию параметра, которая, как и следовало ожидать, 
возвращает значение параметра, указанного в следующей строке. 
Мы передаем это значение в нашу внутреннюю абстракцию game-from-name 
и привязываем результат к локальной переменной с помощью let:   
</p>

<pre class="western">        
       (define-url-fn (vote)
         (let ((game (game-from-name (parameter &quot;name&quot;))))
           (if game
               (vote-for game))
           (redirect &quot;/retro-games.htm&quot;)))
      </pre>
<p>
После голосования за запрошенную игру функция перенаправления Hunchentoot 
переводит клиента на обновленный график. 
</p>

<p><img src="lispweb_html_d2e1dee1bf76943d.png" name="Image3" alt="Retro Games add game page" align="bottom" width="800" height="627" border="0"/>

</p>

<p>Теперь, когда мы можем голосовать, нам нужно проголосовать за несколько игр. 
В коде для страницы ретро-игр выше я включил ссылку на <i>new-game.htm</i>. 
Эта страница показана на рисунке 2. В основном она содержит HTML-форму с 
вводом текста для названия игры: 
</p>

<pre class="western">        
       (define-url-fn (new-game)
         (standard-page (:title &quot;Add a new game&quot;)
                        (:h1 &quot;Add a new game to the chart&quot;)
                        (:form :action &quot;/game-added.htm&quot; :method &quot;post&quot; 
                               (:p &quot;What is the name of the game?&quot; (:br)
                                   (:input :type &quot;text&quot;  
                                           :name &quot;name&quot; 
                                           :class &quot;txt&quot;))
                               (:p (:input :type &quot;submit&quot; 
                                           :value &quot;Add&quot; 
                                           :class &quot;btn&quot;)))))
      </pre>
<p>
Когда пользователь отправляет форму, его данные отправляются на  <i>game-added.htm</i>:
</p>

<pre class="western">        
       (define-url-fn (game-added)
         (let ((name (parameter &quot;name&quot;)))
           (unless (or (null name) (zerop (length name)))
             (add-game name))
           (redirect &quot;/retro-games.htm&quot;)))
      </pre>
<p>
Первая строка в нашей функции URL должна выглядеть знакомо; так же, 
как в нашей функции голосования, мы получаем значение параметра name 
и привязываем его к локальной переменной (name). Здесь мы должны остерегаться 
пустого name(имени). В конце концов, ничто не заставляет пользователя писать 
что-либо в поле перед отправкой формы (через минуту мы увидим, как добавить 
проверку на стороне клиента). Если мы получаем допустимое имя, мы добавляем 
его в нашу базу данных с помощью функции add-game.  
</p>

<h2 class="western">Выражение JavaScript в Лиспе 
</h2>

<p>Допустим, мы хотим убедиться, что пользователь хотя бы что-то 
набрал перед отправкой формы. Можем ли мы сделать это в Лиспе? Да, вообще-то. 
Мы можем написать код Lisp, который компилируется в JavaScript, и мы 
используем библиотеку ParenScript для этой задачи.
</p>

<p>Ненавязчивый JavaScript - важный принцип разработки, и ParenScript 
поддерживает его. Но в Лиспе это становится меньшей проблемой; 
На самом деле я не пишу JavaScript, все на Лиспе. Таким образом, я встраиваю 
свой обработчик событий в форму:  
</p>

<pre class="western">        
      (:form :action &quot;/game-added.htm&quot; :method &quot;post&quot; 
             :onsubmit 
             (ps-inline
              (when (= name.value &quot;&quot;)
                (alert &quot;Please enter a name.&quot;)
                (return false)))
      </pre>
<p>
Этот код будет компилироваться в следующую смесь HTML и JavaScript:  
</p>

<pre class="western">        
      &lt;form action='/game-added.htm' method='post' 
         onsubmit='javascript:if (name.value == &quot;&quot;) {
            alert(&quot;Please enter a name.&quot;);
            return false;
         }'&gt;
      </pre><h2 class="western">
Постоянные(сохраняемые) объекты 
</h2>

<p>Первоначально мы как бы упорно избегали проблемы. Чтобы все заработало 
как можно быстрее, мы использовали простой список в памяти как &quot;database&quot;(базу данных).
Это нормально для прототипирования, но мы по-прежнему хотим сохранить 
все добавленные игры на случай, если мы выключим сервер. Кроме того, 
в текущей разработке есть некоторые потенциальные проблемы с многопоточностью. 
Hunchentoot является многопоточным, и запросы могут поступать в разных потоках. 
Мы можем решить все это, перейдя на поточно-ориентированную базу данных. 
А с Lisp подобные проектировочные решения - это всего лишь макрос; познакомьтесь, 
пожалуйста, с Elephant! 
</p>

<p><a href="http://common-lisp.net/project/elephant/" target="_top">Elephant
</a> - это чрезвычайно умный протокол и база данных для постоянных объектов. 
Для фактического хранения вещей на диске Elephant поддерживает несколько бэкэндов, 
таких как PostGres и SqlLite. В этом примере я буду использовать Berkeley DB,
просто потому, что у него лучшая производительность с Elephant. 
</p>

<p>Первый шаг - открыть контроллер хранилища, который служит мостом между Lisp 
и серверной частью:  
</p>

<pre class="western">        (open-store '(:BDB &quot;/home/adam/temp/gamedb/&quot;))
      </pre>
<p>
Здесь я просто указываю, что мы используем Berkeley DB (:BDB), и указываю каталог 
для файлов базы данных. Теперь давайте создадим несколько постоянных объектов. 
Взгляните еще раз на наш текущий  класс game:  
</p>

<pre class="western">        
         (defclass game ()
           ((name :reader   name 
                  :initarg :name)
            (votes :accessor votes 
                   :initform 0)))
      </pre>
<p>
Elephant предоставляет удобный макрос defpclass, который создает 
постоянные классы. Использование defpclass очень похоже на defclass 
Common Lisp, но добавляет некоторые новые возможности; мы будем использовать
:index, чтобы указать, что мы хотим, чтобы наши слоты можно было извлекать
 по их значениям. Я также добавляю <b>init</b>ial <b>arg</b>ument(начальный аргумент)
 к голосам, который я использую позже при преобразовании наших старых игр в 
этот постоянный класс: 
</p>

<pre class="western">        
         (defpclass persistent-game ()
           ((name :reader name 
                  :initarg :name 
                  :index t)
            (votes :accessor votes 
                   :initarg :votes 
                   :initform 0 
                   :index t)))
      </pre>
<p>
Абстракция Elephant действительно чистая; постоянные объекты создаются так же, 
как и любой другой объект:  
</p>

<pre class="western">        
         RETRO-GAMES&gt;(make-instance 'persistent-game :name &quot;Winter Games&quot;)
         <b>#&lt;PERSISTENT-GAME oid:100&gt;</b>
      </pre>
<p>
Elephant поставляется с набором функций для легкого восстановления/возвращения(retrieval). 
Если нам нужны все экземпляры нашего класса persistent-game, это просто: 
</p>

<pre class="western">        
         RETRO-GAMES&gt;(get-instances-by-class 'persistent-game)
         <b>(#&lt;PERSISTENT-GAME oid:100&gt;)</b>
      </pre>
<p>
Мы, конечно, можем сохранить ссылку на возвращенный список или, 
поскольку мы знаем, что только что создали экземпляр persistent-game, 
напрямую вызвать для него метод:  
</p>

<pre class="western">        
         RETRO-GAMES&gt;(name (first (get-instances-by-class 'persistent-game)))
         <b>&quot;Winter Games&quot;</b>
      </pre>
<p>
Раньше мы позаботились о том, чтобы инкапсулировать доступ к серверной части, 
и теперь это окупается. Нам просто нужно изменить эти функции, чтобы 
использовать Elephant API вместо работы со списком *games*. Функции запроса 
очень просты; поскольку мы проиндексировали наш слот name(имени), мы можем 
использовать метод get-instance-by-value для получения соответствующего 
постоянного объекта:  
</p>

<pre class="western">        
          (defun game-from-name (name)
            (get-instance-by-value 'persistent-game 'name name))
      </pre>
<p>
Как и в нашей первоначальной реализации с использованием find, 
метод get-instance-by-value возвращает NIL, если объект с данным name(именем)
 не сохранен. Это значит, что мы можем game-stored(сохранить игры)? 
в точности как есть, без изменений. Но как насчет добавления новой game(игры)? 
Что ж, нам больше не нужно поддерживать какие-либо ссылки на созданные объекты. 
База данных делает это за нас. Но мы должны изменить add-game, чтобы 
создать экземпляр persistent-game вместо нашего старого класса game. 
И хотя Elephant является потокобезопасным, мы должны гарантировать 
атомарность транзакций. Elephant предоставляет хороший макрос 
with-transaction для решения этой проблемы:  
</p>

<pre class="western">        
           (defun add-game (name)
             (with-transaction ()
                        (unless (game-stored? name)
                            (make-instance 'persistent-game :name name))))
      </pre>
<p>
Всего одно последнее изменение, прежде чем мы сможем скомпилировать и 
развернуть нашу новую серверную часть: функция games, отвечающая за 
возврат списка всех игр, отсортированных по популярности: 
</p>

<pre class="western">        
            (defun games ()
              (nreverse (get-instances-by-range 'persistent-game 'votes nil nil)))
      </pre>
<p>
votes(голоса) - это проиндексированный слот, поэтому мы можем использовать 
get-instance-by-range для получения отсортированного списка. Два последних 
аргумента равны нулю, что приведет к извлечению всех сохраненных игр. 
Возвращенный список будет отсортирован от наименьшего к наибольшему, 
поэтому я применяю nreverse, чтобы перевернуть список (n в nreverse указывает, 
что это деструктивная функция).
</p>

<h2 class="western">Вспоминая игры
</h2>

<p>Очевидно, мы хотим сохранить все ранее добавленные игры. 
В конце концов, пользователи не должны страдать из-за того, 
что мы решили изменить реализацию. Итак, как нам преобразовать 
существующие игры в постоянные объекты? Самый простой способ - 
отобразить(map) список *games* и создать persistent-game с теми 
же значениями слотов, что и в старых объектах game(играх):  
</p>

<pre class="western">        
            RETRO-GAMES&gt;(mapcar <b>#'(lambda (old-game)</b>
                                     <b>(make-instance 'persistent-game </b>
                                                    <b>:name (name old-game)</b>
                                                    <b>:votes (votes old-game)))</b> 
                                *games*)
      </pre>
<p>
Мы могли бы определить функцию для этой задачи с помощью defun
но, поскольку это одноразовая операция, я использую анонимную функцию, 
известную как <i>lambda function</i>(лямбда-функция) (см. <b>Выделенный</b> 
код выше). И всё - все игры перенесены в постоянную базу данных. 
Теперь мы можем установить для *games* значение NIL (фактически делая 
все старые объекты game доступными для сборки мусора) и даже сделать 
историей символ *games*, удалив ее из пакета:  
</p>

<pre class="western">        
            RETRO-GAMES&gt; (setf *games* nil)
            <b>NIL</b>
            RETRO-GAMES&gt; (unintern '*games*)
            <b>T</b>
      </pre><h2 class="western">
Концовка 
</h2>

<p>Эта статья на самом деле лишь поверхностно коснулась того, 
на что способен Лисп. Тем не менее, я надеюсь, что если вы зашли так далеко, 
то увидели, что за всеми этими скобками скрывается большая сила. 
Благодаря своей макросистеме Lisp может быть тем, чем вы хотите. 
</p>

<p>Благодаря динамичному и интерактивному характеру Lisp он идеально 
подходит для создания прототипов. А поскольку программы на Лиспе очень 
легко развивать, этот прототип может однажды превратиться в полноценный 
продукт.  
</p>

<h2 class="western">Ссылки
</h2>

<p>Полный исходный код приложения Retro Games доступен
<a href="https://www.adamtornhill.com/code/retro-games.lisp" target="_top">здесь
</a>. 
</p>

<p>Matthew Snyder написал сиквел. Он доступен здесь: <a href="http://msnyder.info/posts/2011/07/lisp-for-the-web-part-ii/">Lisp
for the Web. Part II </a>
</p>

<p style="margin-bottom: 0cm; line-height: 100%"><br/>

</p>

</body>
</html>
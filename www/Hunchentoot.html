<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Strict//EN">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Hunchentoot - веб-сервер Common Lisp, ранее известный как TBNL </title><meta name="description" content="
    A full-featured web server written in Common Lisp offering things
    like HTTP/1.1 chunking, persistent connections, and SSL.  Includes
    a framework for building dynamic websites interactively.
  "><style type="text/css">
  body { background-color: #ffffff }
  pre { padding:5px; background-color:#e0e0e0 }
  pre.none { padding:5px; background-color:#ffffff }
  h3, h4, h5 { text-decoration: underline; }
  .entry-type { padding-left: 1em; font-size: 60%; font-style: italic }
  a { text-decoration: none; padding: 1px 2px 1px 2px; }
  a:visited { text-decoration: none; padding: 1px 2px 1px 2px; }
  a:hover { text-decoration: none; padding: 1px 1px 1px 1px; border: 1px solid #000000; } 
  a:focus { text-decoration: none; padding: 1px 2px 1px 2px; border: none; }
  a.none { text-decoration: none; padding: 0; }
  a.none:visited { text-decoration: none; padding: 0; } 
  a.none:hover { text-decoration: none; border: none; padding: 0; } 
  a.none:focus { text-decoration: none; border: none; padding: 0; } 
  a.noborder { text-decoration: none; padding: 0; } 
  a.noborder:visited { text-decoration: none; padding: 0; } 
  a.noborder:hover { text-decoration: none; border: none; padding: 0; } 
  a.noborder:focus { text-decoration: none; border: none; padding: 0; }  
        </style></head><body>

  <h2>
    <a href="http://www.htg1.de/hunchentoot/hunchentoot.html" title="Click here for the Hunchentoot logo" class="noborder">
      <img src="Hunchentoot_files/hunchentoot.gif" width="93" height="45" border="0" align="top">
    </a>
    Hunchentoot - веб-сервер Common Lisp, ранее известный как TBNL 
  </h2>

  <blockquote>
    <h3 xmlns=""><a class="none" name="abstract">Отвлечение</a></h3>

<p>
        Hunchentoot - это веб-сервер, написанный на Common Lisp, и в то же время 
	набор инструментов для создания динамических веб-сайтов. В качестве автономного 
	веб-сервера Hunchentoot поддерживает  HTTP/1.1 фрагменты(chunking) 
	(в обоих направлениях), постоянные соединения (keep-alive) и SSL.
      </p>

<p>
        Hunchentoot предоставляет такие возможности, как автоматическая 
	обработка session(сессии/сеанса) (с файлами cookie и без них), 
	ведение журнала, настраиваемая обработка ошибок и легкий доступ 
	к параметрам GET и POST, отправленным клиентом. Он <em>не включает</em> 
	функциональные возможности для программного создания вывода HTML. 
	Для этой задачи вы можете использовать любую понравившуюся библиотеку, 
	например (shameless self-plug) 
        <a href="http://weitz.de/cl-who/">CL-WHO</a> или
        <a href="http://weitz.de/html-template/">HTML-TEMPLATE</a>.
      </p>

<p>
        Hunchentoot общается со своим внешним интерфейсом или с клиентом через 
	сокеты TCP/IP и, не обязательно(но возможно), использует многопроцессорную 
	обработку для одновременной обработки нескольких запросов. Следовательно, 
	он не может быть полностью реализован в <a href="http://www.lispworks.com/documentation/HyperSpec/Front/index.htm">переносимом Common Lisp</a>. В настоящее 
	время он работает с <a href="http://www.lispworks.com/">LispWorks</a> и всеми 
	Lisp, которые поддерживаются уровнями совместимости <a href="http://common-lisp.net/project/usocket/">usocket</a> и <a href="http://common-lisp.net/project/bordeaux-threads/">Bordeaux Threads</a>.
      </p>

<p>
        Hunchentoot поставляется  <a href="http://www.opensource.org/licenses/bsd-license.php">с лицензией в стиле BSD</a>, поэтому вы можете делать с ним все, что захотите.
      </p>

<p>
        Hunchentoot используется (или использовался), например, 
        <a href="http://quickhoney.com/">QuickHoney</a>,
        <a href="http://www.city-farming.de/">City Farming</a>,
        <a href="http://heikestephan.de/">Heike Stephan</a>.
      </p>

<p>
        <font color="red">Download shortcut:</font>
        <a href="http://weitz.de/files/hunchentoot.tar.gz">http://weitz.de/files/hunchentoot.tar.gz</a>.
      </p>

  </blockquote>

  <h3 xmlns=""><a class="none" name="contents">СОДЕРЖАНИЕ</a></h3>
  <ol xmlns="">
<li><a href="#abstract">Отвлечение</a></li>
<li><a href="#contents">Содержание</a></li>
<li>
<a href="#install">Скачивание и установка</a><ol>
<li><a href="#port80"> Запуск Hunchentoot на 80-м порту</a></li>
<li><a href="#proxy"> Hunchentoot за прокси</a></li>
</ol>
</li>
<li><a href="#support">Поддержка</a></li>
<li><a href="#teen-age">Ваш собственный веб-сервер (легкая версия для подростков в Нью-Йорке)</a></li>
<li><a href="#extras">Сторонняя документация и дополнения</a></li>
<li>
<a href="#reference"> Справочник по функциям и переменным</a><ol>
<li><a href="#acceptors">Acceptors(Акцепторы/принимающие)</a></li>
<li><a href="#acceptor-behaviour">Настройка поведения акцептора</a></li>
<li><a href="#subclassing-acceptors">Пример создания подкласса ACCEPTOR</a></li>
<li><a href="#taskmasters">Taskmasters(Надсмотрщики)</a></li>
<li><a href="#request-dispatch"> Отправка и обработка запроса</a></li>
<li><a href="#easy-handlers">Использование фреймворка easy-handler</a></li>
<li><a href="#requests">Request objects(Объекты запроса)</a></li>
<li><a href="#replies">Reply objects( Объекты ответа)</a></li>
<li><a href="#sessions">Sessions(Сессии/Сеансы)</a></li>
<li><a href="#session-behaviour">Настройка поведения сеанса</a></li>
<li><a href="#cookies">Cookies(Печенюшки)</a></li>
<li><a href="#logging">Logging(Протоколирование)</a></li>
<li><a href="#conditions"> Условия и обработка ошибок</a></li>
<li><a href="#misc">Разное</a></li>
</ol>
</li>
<li><a href="#testing">Тестирование</a></li>
<li><a href="#debugging">Отладка</a></li>
<li><a href="#history">История</a></li>
<li><a href="#index">Индекс Символов</a></li>
<li><a href="#ack">Благодарности</a></li>
</ol>

  <h3 xmlns=""><a class="none" name="install">Скачивание и установка</a></h3>
    	Hunchentoot зависит от пары других библиотек Lisp, которые вам необходимо 
	сначала установить: 
    <ul>
      <li>Pierre R. Mai's <a href="http://www.cliki.net/md5">MD5</a>,</li>
      <li>Kevin Rosenberg's <a href="http://www.cliki.net/cl-base64">CL-BASE64</a>,</li>
      <li>Janis Dzerins' <a href="http://common-lisp.net/project/rfc2388/">RFC2388</a>,</li>
      <li>Peter Seibel's <a href="http://weitz.de/cl-fad/">CL-FAD</a>,</li>
      <li>Gary King's <a href="http://common-lisp.net/project/trivial-backtrace/">trivial-backtrace</a>,</li>
      <li>Erik Huelsmann's <a href="http://common-lisp.net/project/usocket">usocket</a> (если вы не используете LispWorks),</li>
      <li>Greg Pfeil's <a href="http://common-lisp.net/project/bordeaux-threads/">Bordeaux Threads</a> (если вы не используете LispWorks),
      </li>
      <li>
        David Lichteblau's <a href="http://common-lisp.net/project/cl-plus-ssl/">CL+SSL</a>
        (если вы не используете LispWorks),
      </li>
      <li>
        и мой собственный <a href="http://weitz.de/flexi-streams/">FLEXI-STREAMS</a> (0.12.0 или 	выше),
        <a href="http://weitz.de/chunga/">Chunga</a> (1.0.0 или
	выше), и <a href="http://weitz.de/cl-ppcre/">
        CL-PPCRE</a> (плюс
        <a href="http://weitz.de/cl-who/">CL-WHO</a> для <a href="#teen-age">примеров кода</a>
        и <a href="http://weitz.de/drakma/">Drakma</a> для <a href="#testing">тестов</a>).
      </li>
    </ul>

    	Обязательно используйте <em>новейшие</em> версии всех этих библиотек 
	(которые сами могут зависеть от других библиотек) - попробуйте версии 
	репозитория, если вы сомневаетесь. Примечание: вы можете скомпилировать 
	Hunchentoot без поддержки SSL - и, следовательно, без необходимости иметь 
	CL + SSL - если вы добавите: <code>:HUNCHENTOOT-NO-SSL</code> в 
	<a href="http://www.lispworks.com/documentation/HyperSpec/Body/v_featur.htm">
      <code>*FEATURES*</code></a> <em>перед</em> его компиляцией.

<p>
      Hunchentoot будет работать только с Lisp-ами, где 
	<a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#character_code">коды символьных знаков</a> всех знаков 
	<a href="http://en.wikipedia.org/wiki/ISO/IEC_8859-1">Latin-1</a> совпадают 
	с их <a href="http://en.wikipedia.org/wiki/Code_point">кодовыми точками</a> 
	Unicode (что имеет место для всех текущих реализаций, которые я знаю).
    </p>

<p>
      Сам Hunchentoot вместе с этой документацией можно загрузить с
      <a href="https://github.com/edicl/hunchentoot/archive/v1.2.38.tar.gz">https://github.com/edicl/hunchentoot/archive/v1.2.38.tar.gz</a>.
      The current version is 1.2.38.
    </p>

<p>
      Предпочтительный метод компиляции и загрузки Hunchentoot - через <a href="http://www.cliki.net/asdf">ASDF</a>. Если вы хотите избежать загрузки и установки всех 
	зависимостей вручную, попробуйте превосходную систему <a href="http://www.quicklisp.org/">Quicklisp</a> Зака Бина
    </p>

<p>
      Hunchentoot и его зависимости также можно установить с помощью <a href="http://common-lisp.net/project/clbuild/">clbuild</a>. Также есть порт для <a href="http://www.gentoo.org/proj/en/lisp/common-lisp/index.xml">Gentoo Linux</a> благодаря Мэтью Кеннеди.
    </p>

<p>
      Текущая разрабатываемая версия Hunchentoot находится по адресу 
	<a href="https://github.com/edicl/hunchentoot">https://github.com/edicl/hunchentoot</a>. 	Если вы хотите отправлять патчи, пожалуйста, создайте форк репозитория 
	github и отправьте pull запросы. 
    </p>

    <h4 xmlns=""><a name="port80"> Запуск Hunchentoot на 80-м порту</a></h4>

      Hunchentoot не поставляется с кодом, который помог бы запустить его на 
	привилегированном порту (например, порту 80 или 443) в Unix-подобных 
	операционных системах. Современные Unix-подобные системы имеют определенные 
	непереносимые способы, позволяющие пользователям без полномочий root 
	прослушивать привилегированные порты, поэтому включение такой функциональности 
	в Hunchentoot считалось ненужным. Пожалуйста, обратитесь за помощью к 
	онлайн-ресурсам. На момент написания этой статьи в документации YAWS 
	есть <a href="http://yaws.hyber.org/privbind.yaws">исчерпывающая запись</a>
	 по этой теме. 

    <h4 xmlns=""><a name="proxy"> Hunchentoot за прокси</a></h4>

      Если вы не уверены в том, что подвергаете Hunchentoot разгулу дикого Интернета, 
	или если ваше веб-приложение на Лиспе является частью более крупного веб-сайта, 
	вы можете спрятать его за <a href="http://en.wikipedia.org/wiki/Proxy_server">прокси-сервером</a>. Один из подходов, который я использовал несколько раз, - это использовать 
	модуль Apache <a href="http://httpd.apache.org/docs/current/mod/mod_proxy.html">mod_proxy</a> с конфигурацией, которая выглядит следующим образом: 

<pre><a href="http://httpd.apache.org/docs/current/mod/mod_proxy.html#proxypass" class="noborder">ProxyPass</a> /hunchentoot http://127.0.0.1:3000/hunchentoot
<a href="http://httpd.apache.org/docs/current/mod/mod_proxy.html#proxypassreverse" class="noborder">ProxyPassReverse</a> /hunchentoot http://127.0.0.1:3000/hunchentoot</pre>

      Это будет туннелировать все запросы, где путь URI начинается с 
	<code>"/hunchentoot"</code>, на (Hunchentoot) сервер, который 
	прослушивает порт 3000 на той же машине.


<p>
        Конечно, есть <a href="http://www.red-bean.com/pipermail/lispweb/2006-October/001342.html">несколько других</a> (более легких) веб-прокси, которые вы можете использовать 
	вместо Apache. 
      </p>

  <h3 xmlns=""><a class="none" name="support">Поддержк</a></h3>

<p>
      Разработанную версию Hunchentoot можно найти <a href="https://github.com/edicl/hunchentoot" target="_new">на github</a>. Пожалуйста, используйте систему отслеживания проблем github, 
	чтобы отправлять отчеты об ошибках. Патчи приветствуются, пожалуйста, используйте 
	a href="https://github.com/edicl/hunchentoot/pulls">GitHub pull
      requests</a>. Если вы хотите внести изменения, сначала <a href="http://weitz.de/patches.html" target="_new">прочтите это</a>. 
    </p>

  <h3 xmlns=""><a class="none" name="teen-age">Ваш собственный веб-сервер (легкая версия для подростков в Нью-Йорке)</a></h3>
    Запустить собственный веб-сервер довольно просто. Сделайте что-нибудь вроде этого:
<pre>(hunchentoot:<a class="noborder" href="#teen-age">start</a> (make-instance 'hunchentoot:<a class="noborder" href="#acceptor">easy-acceptor</a> :port 4242))</pre>
    Вот и все. Теперь вы должны иметь возможность ввести адрес 
    "<a href="http://127.0.0.1:4242/"><code>http://127.0.0.1:4242/</code></a>" в 
    своем браузере и увидеть что-то, хотя на данный момент ничего интересного.

<p>
      По умолчанию Hunchentoot обслуживает файлы из каталога 
	<code><i>www/</i></code> в своем дереве исходного кода. 
	В дистрибутиве этот каталог содержит HTML-версию документации, 
	а также шаблоны ошибок. Расположение корневого каталога документа 
	можно указать при создании нового экземпляра <code xmlns=""><a href="#acceptor">ACCEPTOR</a></code> с помощью <code xmlns=""><a href="#acceptor-document-root">ACCEPTOR-DOCUMENT-ROOT</a></code>. Точно так же расположение каталога шаблонов ошибок может быть указано в <code xmlns=""><a href="#acceptor-error-template-directory">ACCEPTOR-ERROR-TEMPLATE-DIRECTORY</a></code>. 
	И <code xmlns=""><a href="#acceptor-document-root">ACCEPTOR-DOCUMENT-ROOT</a></code>, и
      <code xmlns=""><a href="#acceptor-error-template-directory">ACCEPTOR-ERROR-TEMPLATE-DIRECTORY</a></code> могут быть указаны с использованием логического пути, который будет
	транслироваться один раз при создании экземпляра 
	<code xmlns=""><a href="#acceptor">ACCEPTOR</a></code>. 
</p>

<p>
      Класс <code xmlns=""><a href="#easy-acceptor">EASY-ACCEPTOR</a></code> реализует 
	фреймворк для разработки веб-приложений. Обработчики определяются с помощью 
	макроса <code xmlns=""><a href="#define-easy-handler">DEFINE-EASY-HANDLER</a></code>.
	Диспетчеризация запросов осуществляется согласно списку функций диспетчеризации в 
	<code xmlns=""><a href="#*dispatch-table*">*DISPATCH-TABLE*</a></code>. Каждая из 
	функций в этом списке вызывается, чтобы определить, хочет ли она обработать запрос,
	предоставленный как единственный аргумент. Если функция диспетчера хочет обработать
	запрос, она возвращает другую функцию для фактического создания желаемой страницы.

    </p>

<p>
      <code xmlns=""><a href="#define-easy-handler">DEFINE-EASY-HANDLER</a></code> 
	сопровождается набором функций создания диспетчеров, которые можно использовать 
	для создания диспетчеров для стандартных задач. Они описаны в <a class="noborder" href="#easy-handlers">подразделе о простых обработчиках</a>.
</a>
    </p>

<p>
      А теперь будьте немного смелее, попробуйте это
</p>

<pre>(hunchentoot:<a class="noborder" href="#define-easy-handler">define-easy-handler</a> (say-yo :uri "/yo") (name)
  (setf (hunchentoot:<a class="noborder" href="#content-type*">content-type*</a>) "text/plain")
  (format nil "Hey~@[ ~A~]!" name))</pre>
      и посмотрим, что происходит в  "<a href="http://127.0.0.1:4242/yo"><code>http://127.0.0.1:4242/yo</code></a>" или
      "<a href="http://127.0.0.1:4242/yo?name=Dude"><code>http://127.0.0.1:4242/yo?name=Dude</code></a>" .

<p></p>

<p>
    Hunchentoot поставляется с небольшим примером веб-сайта, который вы 
	можете использовать, чтобы проверить, работает ли он, и который 
	также должен продемонстрировать несколько вещей, которые вы можете 
	делать с Hunchentoot. Чтобы запустить пример веб-сайта, введите в 
	ваш (listener)прослушиватель следующий код: 

</p>

<pre>(<a class="noborder" href="http://common-lisp.net/~mmommer/asdf-howto.shtml#sec11">asdf:oos</a> 'asdf:load-op :hunchentoot-test)</pre>

    Теперь перейдите по адресу  "<a href="http://127.0.0.1:4242/hunchentoot/test"><code>http://127.0.0.1:4242/hunchentoot/test</code></a>" и поиграйте немного. 

<p></p>

  <h3 xmlns=""><a class="none" name="extras">>Сторонняя документация и дополнения</a></h3>

<p>
      Adam Petersen has written a book called <a href="http://www.adampetersen.se/articles/lispweb.htm">"Lisp for
      the Web"</a> which explains how Hunchentoot and some other
      libraries can be used to build web sites.
    </p>

<p>
      Вот программное обеспечение, расширяющее Hunchentoot или основанное на нем:
    </p>

    <ul>
      <li>
        <a href="https://github.com/fukamachi/clack">Clack</a> - это уровень 
	абстракции веб-сервера, по умолчанию - Hunchentoot. 
      </li>
      <li>
        <a href="https://github.com/slyrus/hunchentoot-cgi">hunchentoot-cgi</a>
        (by Cyrus Harmon)предоставляет обработчики <a href="http://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a> для Hunchentoot. 
      </li>
      <li>
        <a href="http://weitz.de/cl-webdav/">CL-WEBDAV</a> - это сервер 
	<a href="http://webdav.org/">WebDAV</a>, основанный на Hunchentoot.
      </li>
      <li>
        <a href="http://restas.lisper.ru/">RESTAS</a> это веб-фреймворк, основанный 
	на Hunchentoot. <a href="https://github.com/fukamachi/caveman">Caveman</a>, <a href="https://github.com/Shirakumo/radiance">Radiance</a>, <a href="https://github.com/joaotavora/snooze">Snooze</a> или снова <a href="https://github.com/joaotavora/snooze">Snooze</a>
        or again <a href="http://40ants.com/weblocks/">Weblocks</a> - это совместимые с ним
	фреймворки. 

      </li>

    </ul>

  <h3 xmlns=""><a class="none" name="reference"> Справочник по функциям и переменным</a></h3>

    <h4 xmlns=""><a name="acceptors">>Acceptors(Акцепторы/принимающие)</a></h4>

      Если вы хотите, чтобы Hunchentoot действительно что-то делал, вам нужно создать и 
	<a href="#teen-age">start</a>(запустить) <a href="#acceptor">acceptor</a>(акцептор). 
	Вы также можете запустить несколько акцепторов в одном образе, каждый из которых 
	будет прослушивать разные порты. 

      <p xmlns=""><a class="none" name="acceptor"></a>
      [Standard class]
      <br><b>acceptor</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Чтобы создать веб-сервер Hunchentoot, вы создаете экземпляр этого класса 
	или одного из его подклассов и используете обобщенную функцию 
	<code><a href="#start">START</a></code>, чтобы запустить его (и 
	<code><a href="#stop">STOP</a></code>, чтобы остановить его). Используйте: 
	аргумент(initarg) <code xmlns="http://www.w3.org/1999/xhtml">:port</code>, 
	если вы не хотите прослушивать http-порт 80 по умолчанию. Если для порта указан 0,
	система выбирает случайный порт для прослушивания. Выбранный номер порта можно 
	получить с помощью средства доступа(ацессора) 
	<code><a href="#acceptor-port">ACCEPTOR-PORT</a></code>. Выбранный номер порта
	сохраняется при остановке и запуске акцептора.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Существуют и другие аргументы инициализации, большинство из которых, 
		вероятно, вам не понадобится очень часто. Они подробно описаны в 
		документации к определениям слотов.
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            Если вы не работаете в Лиспе без возможностей MP, у вас может быть 
	    несколько активных экземпляров <code xmlns=""><a href="#acceptor">ACCEPTOR</a></code>
	     (прослушивающих разные порты) одновременно. 
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="ssl-acceptor"></a>
      [Standard class]
      <br><b>ssl-acceptor</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Создаёт и 
	<code><a href="#start">START</a></code>(запускает) экземпляр этого класса 
	(вместо <code><a href="#acceptor">ACCEPTOR</a></code>), если вам нужен https-сервер. 
	Есть два обязательных аргумента инициализации: <code xmlns="http://www.w3.org/1999/xhtml">:SSL-CERTIFICATE-FILE</code> и <code xmlns="http://www.w3.org/1999/xhtml">:SSL-PRIVATEKEY-FILE</code> для указателей пути, обозначающих файл сертификата и файл ключа в формате PEM. 
	В LispWorks вы можете иметь и то, и другое в одном файле, и в этом случае второй 
	аргумент(initarg) является необязательным. Вы также можете использовать иницализирующий
	аргумент <code xmlns="http://www.w3.org/1999/xhtml">:SSL-PRIVATEKEY-PASSWORD</code>,
	чтобы указать пароль (в виде строки) для файла ключей (или 
	 <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>, по умолчанию, если пароль
	отсутствует).
        <p xmlns="http://www.w3.org/1999/xhtml">
          Порт по умолчанию для экземпляров <code xmlns=""><a href="#ssl-acceptor">SSL-ACCEPTOR</a></code> - 443 вместо 80. 
        </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="start"></a>
          [Generic function]
          <br><b>start</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">acceptor
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Запускает <code><i>acceptor</i></code>, чтобы он начал принимать соединения. Возвращает акцептор. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="stop"></a>
          [Generic function]
          <br><b>stop</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor &amp;key soft</clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">acceptor
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Останавливает <code><i>acceptor</i></code>(акцептор/приемник), чтобы он больше не принимал запросы. 
	Если <code><i>soft</i></code> - это истина, и есть какие-либо запросы 
	в процессе, ждет, пока все запросы будут полностью обработаны, 
	но пока не принимает новые запросы. Обратите внимание, что <code><i>soft</i></code>
	не должен быть установлен при вызове <code><a href="#stop">stop</a></code>
	из обработчика запросов, так как это приведет к взаимоблокировке. 
        </clix:description></blockquote>
<p></p>

        <p xmlns=""><a class="none" name="started-p"></a>
          [Generic function]
          <br><b>started-p</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">generalized-boolean
            </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Сообщает, запущен ли <code><i>acceptor</i></code>(акцептор). Реализация по умолчанию просто запрашивает у 
	<code><i>acceptor</i></code>(акцептора) статус прослушивания, поэтому, 
	если T возвращается вызывающему потоку, то какой-то поток вызвал 
	<code><a href="#start">start</a></code>(запуск) или <code><a href="#stop">stop</a></code>(остановка) какого-то потока не завершилась. Если возвращается NIL, либо какой-то 
	поток вызвал <code><a href="#stop">stop</a></code>(остановку), либо вызов 
	некоторого потока для <code><a href="#start">start</a></code>(запуска) не завершился,
	либо <code><a href="#start">start</a></code>(запуск) никогда не был вызван 
	для акцептора. 
                <code><i>acceptor</i></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*acceptor*"></a>
      [Special variable]
      <br><b>*acceptor*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Текущий объект ACCEPTOR в контексте запроса. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="acceptor-listen-backlog"></a>
          [Generic function]
          <br><b>acceptor-listen-backlog</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">listen-backlog
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">number-of-pending-connections
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Количество ожидающих соединений, разрешенных в прослушивающем сокете, 
	прежде чем ядро отклонит дальнейшие входящие соединения. Только не для LispWorks.
        </clix:description></blockquote>
<p></p>

      <p xmlns="">
      [Generic readers]<br><a class="none" name="acceptor-address"></a><b>acceptor-address</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">address
          </clix:returns></i><br><a class="none" name="acceptor-port"></a><b>acceptor-port</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">port
          </clix:returns></i><br><a class="none" name="acceptor-read-timeout"></a><b>acceptor-read-timeout</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">read-timeout
          </clix:returns></i><br><a class="none" name="acceptor-ssl-certificate-file"></a><b>acceptor-ssl-certificate-file</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">ssl-acceptor
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">ssl-certificate-file
          </clix:returns></i><br><a class="none" name="acceptor-ssl-privatekey-file"></a><b>acceptor-ssl-privatekey-file</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">ssl-acceptor
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">ssl-privatekey-file
          </clix:returns></i><br><a class="none" name="acceptor-ssl-privatekey-password"></a><b>acceptor-ssl-privatekey-password</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">ssl-acceptor
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">ssl-privatekey-password
          </clix:returns></i><br><a class="none" name="acceptor-write-timeout"></a><b>acceptor-write-timeout</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">write-timeout
          </clix:returns></i><br></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Это считыватели для различных слотов объектов 
	<code><a href="#acceptor">ACCEPTOR</a></code> (и некоторые из них, очевидно, 
	имеют смысл только для объектов <code><a href="#ssl-acceptor">SSL-ACCEPTOR</a></code>). 
	См. Дополнительную информацию в документации этих слотов и обратите внимание на то, 
	что для всех них есть соответствующие аргументы инициализации. 
        </clix:description></blockquote>
<p></p>

      <p xmlns="">
      [Generic accessors]<br><a class="none" name="acceptor-access-log-destination"></a><b>acceptor-access-log-destination</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">(or pathname null)
          </clix:returns></i><br><tt>(setf (</tt><b>acceptor-access-log-destination</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i><tt>) <i>new-value</i>)</tt><br><a class="none" name="acceptor-document-root"></a><b>acceptor-document-root</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">(or pathname null)
          </clix:returns></i><br><tt>(setf (</tt><b>acceptor-document-root</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i><tt>) <i>new-value</i>)</tt><br><a class="none" name="acceptor-error-template-directory"></a><b>acceptor-error-template-directory</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">(or pathname null)
          </clix:returns></i><br><tt>(setf (</tt><b>acceptor-error-template-directory</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i><tt>) <i>new-value</i>)</tt><br><a class="none" name="acceptor-input-chunking-p"></a><b>acceptor-input-chunking-p</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">input-chunking-p
          </clix:returns></i><br><tt>(setf (</tt><b>acceptor-input-chunking-p</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i><tt>) <i>new-value</i>)</tt><br><a class="none" name="acceptor-message-log-destination"></a><b>acceptor-message-log-destination</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">(or pathname null)
          </clix:returns></i><br><tt>(setf (</tt><b>acceptor-message-log-destination</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i><tt>) <i>new-value</i>)</tt><br><a class="none" name="acceptor-name"></a><b>acceptor-name</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">name
          </clix:returns></i><br><tt>(setf (</tt><b>acceptor-name</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i><tt>) <i>new-value</i>)</tt><br><a class="none" name="acceptor-output-chunking-p"></a><b>acceptor-output-chunking-p</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">output-chunking-p
          </clix:returns></i><br><tt>(setf (</tt><b>acceptor-output-chunking-p</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i><tt>) <i>new-value</i>)</tt><br><a class="none" name="acceptor-persistent-connections-p"></a><b>acceptor-persistent-connections-p</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">persistent-connections-p
          </clix:returns></i><br><tt>(setf (</tt><b>acceptor-persistent-connections-p</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i><tt>) <i>new-value</i>)</tt><br><a class="none" name="acceptor-reply-class"></a><b>acceptor-reply-class</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">reply-class
          </clix:returns></i><br><tt>(setf (</tt><b>acceptor-reply-class</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i><tt>) <i>new-value</i>)</tt><br><a class="none" name="acceptor-request-class"></a><b>acceptor-request-class</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">request-class
          </clix:returns></i><br><tt>(setf (</tt><b>acceptor-request-class</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:lambda-list></i><tt>) <i>new-value</i>)</tt><br></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Это аксессоры для различных слотов объектов <code><a href="#acceptor">ACCEPTOR</a></code>. См. Дополнительную информацию в документации этих слотов и обратите внимание на то, 
	что для всех них есть соответствующие аргументы инициализации. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="acceptor-ssl-p"></a>
          [Generic function]
          <br><b>acceptor-ssl-p</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">generalized-boolean
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Возвращает истинное значение,
	 если <code><i>acceptor</i></code> использует SSL-соединения. По умолчанию 
	безоговорочно возвращается <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>, и
	подклассы <code><a href="#acceptor">ACCEPTOR</a></code> должны специализировать 
	этот метод, чтобы сигнализировать, что они используют безопасные соединения - см. 
	Класс <code><a href="#ssl-acceptor">SSL-ACCEPTOR</a></code>. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*default-connection-timeout*"></a>
      [Special variable]
      <br><b>*default-connection-timeout*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Тайм-аут соединения по
	 умолчанию, используемый, когда акцептор читает и записывает в поток сокета. 
	Обратите внимание, что некоторые Лиспы позволяют вам устанавливать разные 
	таймауты для чтения и записи, и вы можете указать оба значения через initargs 
	при создании акцептора(<a xmlns="http://www.w3.org/1999/xhtml" href="#acceptors">acceptor</a>).
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="acceptor-remove-session"></a>
          [Generic function]
          <br><b>acceptor-remove-session</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor session
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">|
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Эта функция вызывается всякий раз, когда сеанс/сессия в 
	<code><a href="#acceptor">ACCEPTOR</a></code> разрушается из-за тайм-аута сеанса 
	или явного вызова <code><a href="#remove-session">REMOVE-SESSION</a></code>. 
        </clix:description></blockquote>
<p></p>

    <h4 xmlns=""><a name="acceptor-behaviour">Настройка поведения акцептора</a></h4>

      Если вы хотите изменить то, что делают акцепторы, вам следует создать подкласс 
	<code xmlns=""><a href="#acceptor">ACCEPTOR</a></code> (или 
	<code xmlns=""><a href="#ssl-acceptor">SSL-ACCEPTOR</a></code>) и специализировать 
	обобщенные функции, которые определяют их поведение (см. Пример ниже). 
	Жизненный цикл акцептора выглядит так: он запускается функцией 
	<code xmlns=""><a href="#start">START</a></code>, которая немедленно вызывает 
	<code xmlns=""><a href="#start-listening">START-LISTENING</a></code>, а затем 
	применяет функцию <code xmlns=""><a href="#execute-acceptor">EXECUTE-ACCEPTOR</a></code>
	к своему <a href="#taskmasters">taskmaster</a>(Надсмотрщики за задачей). 
	Эта функция в конечном итоге вызовет <code xmlns=""><a href="#accept-connections">ACCEPT-CONNECTIONS</a></code>, который отвечает за настройку ожидания подключения клиентов. 
	Для каждого входящего подключения,  применяется  <code xmlns=""><a href="#handle-incoming-connection">HANDLE-INCOMING-CONNECTION</a></code> к taskmaster(мастеру задачи/надсмотрщику),
	который либо вызывает <code xmlns=""><a href="#process-connection">PROCESS-CONNECTION</a></code> напрямую, либо создает поток для его вызова. 
	<code xmlns=""><a href="#process-connection">PROCESS-CONNECTION</a></code> вызывает
	<code xmlns=""><a href="#initialize-connection-stream">INITIALIZE-CONNECTION-STREAM</a></code> до того, как сделает что-либо еще, затем он выбирает и вызывает функцию, 
	которая обрабатывает <a href="#requests">request</a>(запрос), и, наконец, она 
	отправляет <a href="#replies">reply</a>(ответ) клиенту, прежде чем он вызывает 
	<code xmlns=""><a href="#reset-connection-stream">RESET-CONNECTION-STREAM</a></code>.
	Если соединение является постоянным(persistent), эта процедура повторяется 
	(за исключением этапа инициализации) в цикле, пока соединение не будет закрыто. 
	Акцептор/Приемник останавливается с помощью <code xmlns=""><a href="#stop">STOP</a></code>.
      <code xmlns=""><a href="#stop">STOP</a></code>.

<p>
        Если вы просто хотите использовать стандартные акцепторы, поставляемые с 
	Hunchentoot, вам не нужно ничего знать о функциях, перечисленных в этом разделе. 
      </p>

      <p xmlns=""><a class="none" name="start-listening"></a>
          [Generic function]
          <br><b>start-listening</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">|
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Устанавливает прослушивающий
	сокет для данного акцептора и позволяет ему прослушивать входящие соединения. 
	Эта функция вызывается из потока, который изначально запускает акцептор, и может 
	возвращать ошибки, возникающие в результате операции прослушивания (например, 
	'address in use'(адрес используется) или нечто подобное). 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="accept-connections"></a>
          [Generic function]
          <br><b>accept-connections</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">nil
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">В цикле принимает соединение 
	и передает его taskmaster(надсмотрщику) принимающей стороны для обработки с 
	использованием <code><a href="#handle-incoming-connection">HANDLE-INCOMING-CONNECTION</a></code>. В LispWorks эта функция возвращается немедленно, в других Lisp она возвращается 
	только после остановки акцептора. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="process-connection"></a>
          [Generic function]
          <br><b>process-connection</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor socket
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">nil
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Эта функция вызывается мастером задачи/надсмотрщиком при установке нового 
	клиентского соединения. Его аргументами являются объект 
	<code><a href="#acceptor">ACCEPTOR</a></code> и дескриптор сокета LispWorks 
	или объект потока сокета usocket в <code><i>socket</i></code>. Он считывает 
	заголовки запроса, настраивает объекты <a xmlns="http://www.w3.org/1999/xhtml" href="#requests">request</a>(запроса) и <a xmlns="http://www.w3.org/1999/xhtml" href="#replies">reply</a>(ответа) 
	и передает <code><a href="#process-request">PROCESS-REQUEST</a></code>, который вызывает
	<code><a href="#handle-request">HANDLE-REQUEST</a></code> для выбора и вызова 
	обработчика запроса и отправляет свой ответ клиенту. Это выполняется в цикле до 
	тех пор, пока поток не будет закрыт или пока не истечет время ожидания соединения.
	Вероятно, не рекомендуется повторно реализовывать этот метод, пока вы действительно,
	действительно не поймете, что делаете.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Обработчики могут вызывать обобщенную функцию 
		<code xmlns=""><a href="#detach-socket">DETACH-SOCKET</a></code>, чтобы указать,
		что Hunchentoot не должен обрабатывать дальнейшие запросы в соединении, и что
		ответственность за сокет берет на себя стороннее программное обеспечение. 
		Это может использоваться специализированными обработчиками, которые хотят
		передать опрос или обработку соединения функциям за пределами Hunchentoot, 
		о есть для мультиплексирования соединений или реализации специализированных
		клиентских протоколов. Hunchentoot завершит обработку запроса, и функция 
		<code xmlns=""><a href="#process-connection">PROCESS-CONNECTION</a></code>
		 вернется, не закрывая соединение. В этот момент акцептор может взаимодействовать
		с сокетом любым необходимым способом. 
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="detach-socket"></a>
          [Generic function]
          <br><b>detach-socket</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">nil
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Сообщает Hunchentoot, что он должен прекратить обслуживание запросов в сокете 
	текущего запроса. Hunchentoot завершит обработку текущего запроса, а затем вернется 
	из <code><a href="#process-connection">PROCESS-CONNECTION</a></code>, не закрывая
	соединение с клиентом. <code><a href="#detach-socket">DETACH-SOCKET</a></code> 
	можно вызвать только из функции обработчика запросов. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="initialize-connection-stream"></a>
          [Generic function]
          <br><b>initialize-connection-stream</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor stream
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">stream
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Может использоваться для изменения потока, который используется для связи между 
	клиентом и сервером перед чтением запроса. Метод 
	<code><a href="#acceptor">ACCEPTOR</a></code> по умолчанию ничего не делает, 
	но посмотрите, например, метод, определенный для 
	<code><a href="#ssl-acceptor">SSL-ACCEPTOR</a></code>. Все методы этой обобщенной
	функции <em xmlns="http://www.w3.org/1999/xhtml">должны</em> возвращать поток для
	использования. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="reset-connection-stream"></a>
          [Generic function]
          <br><b>reset-connection-stream</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor stream
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">stream
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Сбрасывает поток, который используется для связи между клиентом и сервером после
	обслуживания одного запроса, чтобы его можно было использовать для обработки 
	следующего запроса. Эта обобщенная функция вызывается после обработки запроса и 
	<em xmlns="http://www.w3.org/1999/xhtml">должна</em> возвращать поток. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="acceptor-log-access"></a>
          [Generic function]
          <br><b>acceptor-log-access</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor &amp;key return-code</clix:lambda-list></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Функция для вызова журнала доступа к акцептору. Аргумент ключевого слова 
	<code><i>return-code</i></code> содержит дополнительную информацию о запросе 
	на регистрацию. Кроме того, он может использовать стандартные функции доступа 
	запроса и ответа, доступные для функций-обработчиков, чтобы получить 
	дополнительную информацию о запросе. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="acceptor-log-message"></a>
          [Generic function]
          <br><b>acceptor-log-message</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor log-level format-string &amp;rest format-arguments</clix:lambda-list></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Функция для вызова акцептором(<code><i>acceptor</i></code>) сообщений журнала. 
	Он должен принимать уровень серьезности сообщения, который может быть одним из
	:ERROR, :INFO или :WARNING, строка формата и произвольное количество аргументов
	форматирования. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="acceptor-status-message"></a>
          [Generic function]
          <br><b>acceptor-status-message</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor http-return-code &amp;key &amp;allow-other-keys</clix:lambda-list></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Эта функция вызывается, когда обработчик запроса был вызван, но не смог 
	предоставить контент для отправки обратно клиенту. Он преобразует 
	<code><i>HTTP-STATUS-CODE</i></code> в некоторое содержимое запроса, 
	обычно в удобочитаемое описание кода состояния, отображаемого пользователю. 

          Если в текущем ацессоре установлен ERROR-TEMPLATE-DIRECTORY, а каталог 
	содержит файл, соответствующий HTTP-STATUS-CODE, с именем 
	&lt;code&gt;.html, этот файл отправляется клиенту после замены переменной. 
	На переменные ссылается  ${&lt;variable-name&gt;}.

          Могут быть предоставлены дополнительные аргументы ключевого слова, 
	которые становятся доступными для логики шаблонов как переменные подстановки. 
	Эти переменные могут быть вставлены в шаблоны сообщений об ошибках, которые 
	содержат текущий URL-адрес относительно сервера и без параметров GET. 

          В дополнение к переменным, соответствующим аргументам ключевого слова, 
	доступны переменные script-name, lisp-implementation-type, 
	lisp-implementation-version и hunchentoot-version. 
        </clix:description></blockquote>
<p></p>

  <h4 xmlns=""><a name="subclassing-acceptors">Пример создания подкласса ACCEPTOR</a></h4>

    В этом примере показано, как создать подкласс 
	<code xmlns=""><a href="#acceptor">ACCEPTOR</a></code>, чтобы предоставить Hunchentoot
	базовую поддержку виртуального хоста. Предполагается, что Hunchentoot находится за
	выходящим в Интернет обратным прокси-сервером, который сопоставляет часть хоста 
	(или домена) входящих HTTP-запросов с уникальными портами localhost. 

    <pre>(asdf:load-system "hunchentoot")
(asdf:load-system "drakma")

;;; Subclass ACCEPTOR
(defclass vhost (hunchentoot:acceptor)
  ;; slots
  ((dispatch-table
    :initform '()
    :accessor dispatch-table
    :documentation "List of dispatch functions"))
  ;; options
  (:default-initargs                    ; default-initargs must be used
   :address "127.0.0.1"))               ; because ACCEPTOR uses it

;;; Specialise ACCEPTOR-DISPATCH-REQUEST for VHOSTs
(defmethod hunchentoot:acceptor-dispatch-request ((vhost vhost) request)
  ;; try REQUEST on each dispatcher in turn
  (mapc (lambda (dispatcher)
	  (let ((handler (funcall dispatcher request)))
	    (when handler               ; Handler found. FUNCALL it and return result
	      (return-from hunchentoot:acceptor-dispatch-request (funcall handler)))))
	(dispatch-table vhost))
  (call-next-method))

;;; ======================================================================
;;; Now all we need to do is test it

;;; Instantiate VHOSTs
(defvar vhost1 (make-instance 'vhost :port 50001))
(defvar vhost2 (make-instance 'vhost :port 50002))

;;; Populate each dispatch table
(push
 (hunchentoot:create-prefix-dispatcher "/foo" 'foo1)
 (dispatch-table vhost1))
(push
 (hunchentoot:create-prefix-dispatcher "/foo" 'foo2)
 (dispatch-table vhost2))

;;; Define handlers
(defun foo1 () "Hello")
(defun foo2 () "Goodbye")

;;; Start VHOSTs
(hunchentoot:start vhost1)
(hunchentoot:start vhost2)

;;; Make some requests
(drakma:http-request "http://127.0.0.1:50001/foo")
;;; =|
;;; 127.0.0.1 - [2012-06-08 14:30:39] "GET /foo HTTP/1.1" 200 5 "-" "Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)"
;;; =&gt;
;;; "Hello"
;;; 200
;;; ((:CONTENT-LENGTH . "5") (:DATE . "Fri, 08 Jun 2012 14:30:39 GMT")
;;;  (:SERVER . "Hunchentoot 1.2.3") (:CONNECTION . "Close")
;;;  (:CONTENT-TYPE . "text/html; charset=utf-8"))
;;; #&lt;PURI:URI http://127.0.0.1:50001/foo&gt;
;;; #&lt;FLEXI-STREAMS:FLEXI-IO-STREAM {CA90059}&gt;
;;; T
;;; "OK"
(drakma:http-request "http://127.0.0.1:50002/foo")
;;; =|
;;; 127.0.0.1 - [2012-06-08 14:30:47] "GET /foo HTTP/1.1" 200 7 "-" "Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)"
;;; =&gt;
;;; "Goodbye"
;;; 200
;;; ((:CONTENT-LENGTH . "7") (:DATE . "Fri, 08 Jun 2012 14:30:47 GMT")
;;;  (:SERVER . "Hunchentoot 1.2.3") (:CONNECTION . "Close")
;;;  (:CONTENT-TYPE . "text/html; charset=utf-8"))
;;; #&lt;PURI:URI http://127.0.0.1:50002/foo&gt;
;;; #&lt;FLEXI-STREAMS:FLEXI-IO-STREAM {CAE8059}&gt;
;;; T
;;; "OK"</pre>

    Как заставить каждый VHOST записывать в отдельные потоки (или файлы) журнала доступа, 
	оставлено читателю в качестве упражнения. 

    <h4 xmlns=""><a name="taskmasters">Taskmasters(Надсмотрщики)</a></h4>
      Как "нормальный" пользователь Hunchentoot, вы можете полностью игнорировать 
	taskmasters(мастеров задач/надсмотрщиков) и пропустить этот раздел. Но если вы все 
	еще читаете, вот грязные подробности: с каждым <a href="#acceptors">acceptor</a>
	(акцептором) связывается надсмотрщик во время создания. Задача мастера задачи 
	- распределить работу по приему и обработке входящих соединений. Акцептор вызывает
	мастера, если это необходимо, и тот обращается обратно к акцептору. Это делается с
	помощью обобщенных функций, описанных в этом и 
	<a href="#acceptor-behaviour">предыдущем</a> разделе. Hunchentoot поставляется с 
	двумя стандартными реализациями мастера задач - одна (которая по умолчанию используется 
	в многопоточных Lisps), которая запускает новый поток для каждого входящего соединения, 
	и вторая, которая обрабатывает все запросы последовательно. Например, должно быть
	относительно просто создать диспетчер задач, который выделяет потоки из фиксированного
	пула вместо того, чтобы создавать новый для каждого соединения. 

<p>
	Вы можете контролировать ресурсы, потребляемые многопоточным мастером задач, 
	с помощью двух аргументов инициализации. <code>:max-thread-count</code> позволяет 
	вам установить максимальное количество потоков запросов, которые могут обрабатываться
	одновременно. Если это <code>nil</code>, ограничение по потокам не налагается

        <code>:max-accept-count</code>  позволяет вам установить максимальное количество 
	запросов, которые могут быть недовыполненными (то есть обрабатываются или помещаются 
	в очередь для обработки).

        Если указано <code>:max-thread-count</code> и <code>:max-accept-count</code> 
	равно <code>NIL</code>, то будет сгенерирована ошибка 
	<code xmlns=""><a href="#+http-service-unavailable+">+HTTP-SERVICE-UNAVAILABLE+</a></code>, если количество потоков, обрабатывающих запросы, превышает max-thread-count
	(максимальное количество потоков). Если указаны оба параметра:  
	<code>:max-thread-count</code> и <code>:max-accept-count</code> тогда 
	max-thread-count должно быть меньше max-accept-count; если обрабатывается больше, 
	чем max-thread-count запросов, то запросы до max-accept-count будут ставиться в 
	очередь до тех пор, пока поток не станет доступным. Если невыполненных запросов 
	больше, чем max-accept-count, будет сгенерирована ошибка 
	<code xmlns=""><a href="#+http-service-unavailable+">+HTTP-SERVICE-UNAVAILABLE+</a></code>.

        В среде с балансировкой нагрузки с несколькими серверами Hunchentoot разумно 
	указать <code>:max-thread-count</code>, но оставить <code>:max-accept-count</code> null.
	Это немедленно приведет к <code xmlns=""><a href="#+http-service-unavailable+">+HTTP-SERVICE-UNAVAILABLE+</a></code>, когда на одном сервере не хватает ресурсов, поэтому 
	балансировщик нагрузки может попытаться найти другой сервер.

        В среде с одним сервером Hunchentoot разумно предоставить как 
	<code>:max-thread-count</code>, так и несколько большее значение для
	<code>:max-accept-count</code>. Это заставит сервер, у которого почти не хватает 
	ресурсов, немного подождать; если сервер полностью исчерпал ресурсы, то ответ 
	будет <code xmlns=""><a href="#+http-service-unavailable+">+HTTP-SERVICE-UNAVAILABLE+</a></code>. По умолчанию для этих значений 100 и 120 соответственно.
      </p>

<p>
        Если вы хотите реализовать своих собственных мастеров задач, вам следует создать 
	подкласс <code xmlns=""><a href="#taskmaster">TASKMASTER</a></code> или одного из его
	подклассов, <code xmlns=""><a href="#single-threaded-taskmaster">SINGLE-THREADED-TASKMASTER</a></code> или
        <code xmlns=""><a href="#one-thread-per-connection-taskmaster">ONE-THREAD-PER-CONNECTION-TASKMASTER</a></code>, и специализировать обобщенные функции из этого раздела. 
      </p>

      <p xmlns=""><a class="none" name="taskmaster"></a>
      [Standard class]
      <br><b>taskmaster</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Экземпляр этого класса отвечает за распределение работы по обработке запросов 
	для его получателя. Это «абстрактный» класс в том смысле, что обычно будут 
	использоваться только экземпляры подклассов 
	<code><a href="#taskmaster">TASKMASTER</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="one-thread-per-connection-taskmaster"></a>
      [Standard class]
      <br><b>one-thread-per-connection-taskmaster</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Мастер задач, который запускает один поток для прослушивания входящих запросов 
	и один поток для каждого входящего соединения.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Это реализация мастера задач по умолчанию для многопоточных реализаций Лиспа.
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="single-threaded-taskmaster"></a>
      [Standard class]
      <br><b>single-threaded-taskmaster</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Мастер задач, который работает синхронно в потоке, в котором была вызвана 
	функция <code><a href="#start">START</a></code> (или, в случае LispWorks, в потоке,
	запущенном <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.lispworks.com/documentation/lw51/LWRM/html/lwref-61.htm#marker-910861"><code>COMM:START-UP-SERVER</code></a>).
	Это простейшая из возможных реализаций мастера задач в том смысле, что его методы 
	не делают ничего, кроме вызова своих приемных «сестринских» методов - 
	<code><a href="#execute-acceptor">EXECUTE-ACCEPTOR</a></code> вызывает 
	<code><a href="#accept-connections">ACCEPT-CONNECTIONS</a></code>, 
	<code><a href="#handle-incoming-connection">HANDLE-INCOMING-CONNECTION</a></code>
	вызывает <code><a href="#process-connection">PROCESS-CONNECTION</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="multi-threaded-taskmaster"></a>
      [Standard class]
      <br><b>multi-threaded-taskmaster</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Это абстрактный класс для мастеров задач, использующих несколько потоков; 
	это не конкретный класс, и вы не должны создавать его с помощью 
	<code xmlns="http://www.w3.org/1999/xhtml">MAKE-INSTANCE</code>. Вместо этого вы 
	должны создать его подкласс <code><a href="#one-thread-per-connection-taskmaster">ONE-THREAD-PER-CONNECTION-TASKMASTER</a></code>, описанный выше. 
	<code><a href="#multi-threaded-taskmaster">MULTI-THREADED-TASKMASTER</a></code>
	предназначен для наследования расширениями Hunchentoot, такими как <a xmlns="http://www.w3.org/1999/xhtml" href="http://common-lisp.net/project/qitab/">quux-hunchentoot</a>'s
	<code xmlns="http://www.w3.org/1999/xhtml">THREAD-POOLING-TASKMASTER</code>, 
	хотя на данный момент он наследует только один слот и один метод на 
	<code><a href="#execute-acceptor">EXECUTE-ACCEPTOR</a></code>, чтобы иметь его. 
	начать новый поток для акцептора, а затем сохранить его в указанном слоте. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="execute-acceptor"></a>
          [Generic function]
          <br><b>execute-acceptor</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">taskmaster
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Это обратный вызов, 
вызываемый акцептором после того, как он выполнил всю начальную обработку, чтобы начать
прослушивание входящих соединений (см. <code><a href="#start-listening">START-LISTENING</a></code>). Обычно он вызывает метод <code><a href="#accept-connections">ACCEPT-CONNECTIONS</a></code>
	акцептора, но в зависимости от экземпляра taskmaster метод может быть вызван из 
	нового потока.   
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="handle-incoming-connection"></a>
          [Generic function]
          <br><b>handle-incoming-connection</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">taskmaster socket
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Эта функция вызывается акцептором, чтобы начать обработку запросов на 
	новом входящем соединении. <code><i>socket</i></code> - это экземпляр usocket, 
	который представляет новое соединение (или дескриптор сокета в LispWorks). 
	Мастер задачи/надсмотрщик начинает обработку запросов на входящем соединении, 
	вызывая метод <code><a href="#process-connection">PROCESS-CONNECTION</a></code>
	экземпляра акцептора. Аргумент <code><i>socket</i></code> передается 
	<code><a href="#process-connection">PROCESS-CONNECTION</a></code> в качестве аргумента.

           Если мастер задачи является многопоточным мастером задачи, 
	<code><a href="#handle-incoming-thread">HANDLE-INCOMING-THREAD</a></code> вызовет 
	<code><a href="#create-request-handler-thread">CREATE-REQUEST-HANDLER-THREAD</a></code>,
	который вызовет <code><a href="#process-connection">PROCESS-CONNECTION</a></code> в 
	новом потоке. <code><a href="#handle-incoming-thread">HANDLE-INCOMING-THREAD</a></code>
	может выдать ошибку  <code><a href="#+http-service-unavailable+">+HTTP-SERVICE-UNAVAILABLE+</a></code>, если существует слишком много потоков запросов или может 
	заблокировать ожидание завершения потока запроса. 
              </clix:description></blockquote>
<p></p>

            <p xmlns=""><a class="none" name="start-thread"></a>
          [Generic function]
          <br><b>start-thread</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">taskmaster thunk &amp;key
            </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">thread
            </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Эта функция является 
	обратным вызовом, который запускает новый поток, который будет вызывать данный
	<code><i>thunk</i></code>(преобразователь) в контексте соответствующего 
	<code><i>taskmaster</i></code>(мастера задач) с соответствующими контекстно-зависимыми
	аргументами ключевого слова. 
	<code><a href="#one-thread-per-connection-taskmaster">ONE-THREAD-PER-CONNECTION-TASKMASTER</a></code> использует его в  <code><a href="#execute-acceptor">EXECUTE-ACCEPTOR</a></code> и <code><a href="#create-request-handler-thread">CREATE-REQUEST-HANDLER-THREAD</a></code>,
	но специализированные мастера задач могут определять больше функций, которые его
	используют. По умолчанию он просто создает поток, вызывающий thunk(преобразователь)
	с указанным аргументом ключевого слова <code><i>name</i></code>. 
	Специализированные мастера задач могут обернуть специальные привязки и обработчики
	условий вокруг вызова thunk(преобразователя), зарегистрировать поток в таблице 
	управления и т. Д. 
              </clix:description></blockquote>
<p></p>

            <p xmlns=""><a class="none" name="create-request-handler-thread"></a>
          [Generic function]
          <br><b>create-request-handler-thread</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">taskmaster socket
            </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">thread
            </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Эта функция вызывается 
	<code><a href="#handle-incoming-thread">HANDLE-INCOMING-THREAD</a></code> 
	для создания нового потока, который вызывает 
	<code><a href="#process-connection">PROCESS-CONNECTION</a></code>. Если вы 
	специализируете эту функцию, вы должны быть осторожны, чтобы поток вызывал 
	<code><a href="#decrement-taskmaster-request-count">DECREMENT-TASKMASTER-REQUEST-COUNT</a></code> перед завершением. Типичный метод будет выглядеть так: 

                <pre xmlns="http://www.w3.org/1999/xhtml">(defmethod create-request-handler-thread ((taskmaster monitor-taskmaster) socket)
  (bt:make-thread
   (lambda ()
     (with-monitor-error-handlers
         (unwind-protect
              (with-monitor-variable-bindings
                  (process-connection (taskmaster-acceptor taskmaster) socket))
           (decrement-taskmaster-request-count taskmaster))))))</pre>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="shutdown"></a>
          [Generic function]
          <br><b>shutdown</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">taskmaster
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">taskmaster
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Выключает надсмотрщика
	(мастера задачи), то есть освобождает все ресурсы, которые были им настроены. 
	Например, многопоточный мастер задачи может завершить все потоки, которые в 
	настоящее время с ним связаны. Эта функция вызывается методом акцептора
	<code><a href="#stop">STOP</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="taskmaster-acceptor"></a>
      [Generic accessor]
      <br><b>taskmaster-acceptor</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">taskmaster
        </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">acceptor
        </clix:returns></i><br><tt>(setf (</tt><b>taskmaster-acceptor</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">taskmaster
        </clix:lambda-list></i><tt>) <i>new-value</i>)</tt></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Это аксессор для слота объекта <code><a href="#taskmaster">TASKMASTER</a></code>,
	который ссылается обратно на <a xmlns="http://www.w3.org/1999/xhtml" href="#acceptors">acceptor</a>(акцептор), с которым он связан.
        </clix:description></blockquote>
<p></p>

    <h4 xmlns=""><a name="request-dispatch"> Отправка и обработка запроса</a></h4>

      Основная задача <code xmlns=""><a href="#handle-request">HANDLE-REQUEST</a></code> - 
	выбрать и вызвать функцию, которая обрабатывает запрос, то есть просматривает 
	данные, отправленные клиентом, и готовит соответствующий ответ для отправки 
	обратно. По умолчанию это реализовано следующим образом:

<p>
        Класс ACCEPTOR определяет обобщенную функцию <code xmlns=""><a href="#acceptor-dispatch-request">ACCEPTOR-DISPATCH-REQUEST</a></code>, которая используется для фактической отправки
	 запроса. Эта функция вызывается методом по умолчанию 
	<code xmlns=""><a href="#handle-request">HANDLE-REQUEST</a></code>. Каждый метод 
	<code xmlns=""><a href="#acceptor-dispatch-request">ACCEPTOR-DISPATCH-REQUEST</a></code>
	смотрит на объект запроса и в зависимости от его содержимого решает либо обработать
	запрос, либо вызвать следующий метод. 
      </p>

<p>
        Для отправки запроса Hunchentoot вызывает обобщенные функции 
	<code xmlns=""><a href="#acceptor-dispatch-request">ACCEPTOR-DISPATCH-REQUEST</a></code>.
	Метод для <code xmlns=""><a href="#acceptor">ACCEPTOR</a></code> пытается обслуживать
	статический файл относительно его <code xmlns=""><a href="#acceptor-document-root">ACCEPTOR-DOCUMENT-ROOT</a></code>. Подклассы акцепторов для конкретных приложений обычно выполняют
	синтаксический анализ и отправку URL-адресов в соответствии с требуемой политикой.
      </p>

<p>
        Метод по умолчанию <code xmlns=""><a href="#handle-request">HANDLE-REQUEST</a></code>
	устанавливает <a href="#logging">стандартное ведение журнала и обработку ошибок</a>
	перед вызовом диспетчера запросов приемника/акцептора.
      </p>

<p>
        Обработчики запросов выполняют свою работу, изменяя <a href="#replies">объект ответа</a>,
	если это необходимо, и в конечном итоге возвращая тело ответа в виде строки или 
	двоичной последовательности. В качестве альтернативы они также могут вызывать 
	<code xmlns=""><a href="#send-headers">SEND-HEADERS</a></code> и писать прямо в поток. 
      </p>

    <h4 xmlns=""><a name="easy-handlers">Использование фреймворка easy-handler</a></h4>

<p>
        Класс <code xmlns=""><a href="#easy-acceptor">EASY-ACCEPTOR</a></code> определяет 
	метод для <code xmlns=""><a href="#acceptor-dispatch-request">ACCEPTOR-DISPATCH-REQUEST</a></code>, который просматривает список <code xmlns=""><a href="#*dispatch-table*">*DISPATCH-TABLE*</a></code>, который состоит из <em>функций диспетчеризации</em>. Каждая из этих функций
	 принимает объект запроса в качестве своего единственного аргумента и либо возвращает
	 обработчик запроса для обработки запроса, либо <code>NIL</code>, что означает, 
	что будет испробован следующий диспетчер в списке. Обработчик запросов
	(<em>request handler</em>) - это функция с нулём аргументов, которая использует
	специальную переменную <code xmlns=""><a href="#*request*">*REQUEST*</a></code> 
	для доступа к обслуживаемому экземпляру запроса. Если все диспетчерские функции
	возвращают <code>NIL</code>, будет вызван следующий 
	<code xmlns=""><a href="#acceptor-dispatch-request">ACCEPTOR-DISPATCH-REQUEST</a></code>.
      </p>

<p>
        <strong>N.B.</strong> Все функции и переменные в этом разделе связаны с механизмом 
	простой отправки запросов и не имеют смысла, если вы используете свой собственный 
	диспетчер запросов
      </p>

      <p xmlns=""><a class="none" name="easy-acceptor"></a>
      [Standard class]
      <br><b>easy-acceptor</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Этот класс не определяет дополнительных слотов относительно 
	<code><a href="#acceptor">ACCEPTOR</a></code>. Он служит только как дополнительный 
	тип для отправки/диспетчеризации вызовов 
	<code><a href="#acceptor-dispatch-request">ACCEPTOR-DISPATCH-REQUEST</a></code>. 
	Чтобы использовать фреймворк простого обработчика, должны использоваться акцепторы 
	этого класса или одного из его подклассов. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="easy-ssl-acceptor"></a>
      [Standard class]
      <br><b>easy-ssl-acceptor</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Этот класс смешивает классы <code><a href="#ssl-acceptor">SSL-ACCEPTOR</a></code> и
          <code><a href="#easy-acceptor">EASY-ACCEPTOR</a></code>. Он используется, 
	когда требуются как ssl, так и фреймворк easy handler. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*dispatch-table*"></a>
      [Special variable]
      <br><b>*dispatch-table*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Глобальный список диспетчерских функций. Начальное значение - это список, 
	состоящий из символа 
          <code><a href="#dispatch-easy-handlers">DISPATCH-EASY-HANDLERS</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="create-prefix-dispatcher"></a>
          [Function]
          <br><b>create-prefix-dispatcher</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">prefix handler</clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">dispatch-fn</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Удобная функция, которая возвращает диспетчер, который возвращает 
	<code><i>handler</i></code>(обработчик) всякий раз, когда часть пути в URI 
	запроса начинается со строки <code><i>prefix</i></code>. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="create-regex-dispatcher"></a>
          [Function]
          <br><b>create-regex-dispatcher</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">regex handler</clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">dispatch-fn</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Удобная функция, которая возвращает диспетчер, который возвращает 
	обработчик(<code><i>handler</i></code>) всякий раз, когда часть пути в URI 
	запроса совпадает с <a xmlns="http://www.w3.org/1999/xhtml" href="http://weitz.de/cl-ppcre/">CL-PPCRE</a> регулярным выражением <code><i>regex</i></code> (которое может быть строкой, 
	s-выражением или сканером). 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="create-folder-dispatcher-and-handler"></a>
          [Function]
          <br><b>create-folder-dispatcher-and-handler</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">uri-prefix base-path <tt>&amp;optional</tt> content-type</clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">dispatch-fn</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Создает и возвращает функцию диспетчеризации, которая будет отправлять в 
	функцию-обработчик, которая передает файл относительно 
	<code><i>base-path</i></code>, который обозначается URI запроса относительно 
	<code><i>uri-prefix</i></code>. <code><i>uri-prefix</i></code> должен быть строкой,
	оканчивающейся косой чертой, <code><i>base-path</i></code> должен быть указателем 
	пути для существующего каталога. Внутренне использует 
	<code><a href="#handle-static-file">HANDLE-STATIC-FILE</a></code>.

          <p xmlns="http://www.w3.org/1999/xhtml">
            Если <code xmlns=""><i>content-type</i></code> не равен <code>NIL</code>, он будет
	использоваться как content-type(тип содержимого) для всех файлов в папке. 
	В противном случае (по умолчанию) content-type(тип содержимого) каждого файла будет
	определяться <a href="#handle-static-file">как обычно</a>. 
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="create-static-file-dispatcher-and-handler"></a>
          [Function]
          <br><b>create-static-file-dispatcher-and-handler</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">uri path
        <tt>&amp;optional
        </tt> content-type
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Создает и возвращает функцию отправки запроса, которая будет отправлена 
	в функцию-обработчик, которая выдает файл, обозначенный указателем пути PATH 
	с типом содержимого CONTENT-TYPE, если SCRIPT-NAME запроса совпадает со строкой URI. 
	Если CONTENT-TYPE равен NIL, пытается определить тип содержимого через суффикс файла.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="define-easy-handler"></a>
          [Macro]
          <br><b>define-easy-handler</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">description lambda-list [[declaration* | documentation]] form*</clix:lambda-list></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Определяет обработчик, как если бы это выполнялось с помощью <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defun.htm">
	<code>DEFUN</code></a>, и при необходимости регистрирует его с URI, чтобы его 
	можно было найти с помощью  <code><a href="#dispatch-easy-handlers">DISPATCH-EASY-HANDLERS</a></code>.
          <p xmlns="http://www.w3.org/1999/xhtml">
            <code xmlns=""><i>description/описание</i></code>  - это либо имя символа, 
	либо список, соответствующий <a href="http://www.lispworks.com/documentation/HyperSpec/Body/03_de.htm">деструктурирующему лямбда-списку </a>
          </p>

          <pre xmlns="http://www.w3.org/1999/xhtml">(name &amp;key uri acceptor-names default-parameter-type default-request-type).</pre>
          <code><i>lambda-list</i></code>  - это список, элементы которого являются либо 
	символом <code><i>var</i></code>, либо списком, соответствующим деструктурирующему 
	лямбда-списку 
          <pre xmlns="http://www.w3.org/1999/xhtml">(var &amp;key real-name parameter-type init-form request-type).</pre>
          В результате обработчик будет функцией Lisp с именем <code><i>name</i></code>
	и параметрами ключевыми словами, названными символами <code><i>var</i></code>. 
	Каждая  <code><i>var</i></code> будет привязана к значению параметра GET или POST 
	с именем <code><i>real-name</i></code> (строка) перед выполнением тела функции. 
	Если <code><i>real-name</i></code> не указано, оно будет вычислено путем 
	<a xmlns="http://www.w3.org/1999/xhtml" href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stg_up.htm#string-downcase">downcasing</a>(уменьшения) имени символа
	<code><i>var</i></code>.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Если указан <code xmlns=""><i>uri</i></code> (который вычисляется), то он должен 
		быть строкой или <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_f.htm#function_designator">(указателем функции) для унарной функции. В этом случае
		обработчик будет возвращен <code xmlns=""><a href="#dispatch-easy-handlers">DISPATCH-EASY-HANDLERS</a></code>, если <code xmlns=""><i>uri</i></code> является
		строкой, а <a href="#script-name">script name</a>(имя сценария) текущего 
		запроса - <code xmlns=""><i>uri</i></code>, или если 
		<code xmlns=""><i>uri</i></code> обозначает/(указывает на) функцию и 
		применение этой функции к <a href="#*request*">текущему объекту <code>REQUEST</code></a> возвращает истинное значение. 
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            <code xmlns=""><i>acceptor-names</i></code> (который вычисляется) может быть 
		списком символов, что означает, что обработчик будет возвращен <code xmlns=""><a href="#dispatch-easy-handlers">DISPATCH-EASY-HANDLERS</a></code> только в акцепторах, которые 
		имеют одно из этих имен (см. <code xmlns=""><a href="#acceptor-name">ACCEPTOR-NAME</a></code>).<code xmlns=""><i>acceptor-names</i></code> также может быть символом 
		<code>T</code>, что означает, что обработчик будет возвращен <code xmlns=""><a href="#dispatch-easy-handlers">DISPATCH-EASY-HANDLERS</a></code> в <em>каждом</em> акцепотре.
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            Будет ли учитываться параметр GET или POST (или оба), зависит от 
		<code xmlns=""><i>request-type</i></code>(типа запроса), 
		который может быть: <code>:GET</code>, <code>:POST</code>, <code>:BOTH</code>,
		или <code>NIL</code>. В последнем случае будет использоваться значение 
		<code xmlns=""><i>default-request-type</i></code> (по умолчанию 
		<code>:BOTH</code>). 
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            Значение <code xmlns=""><i>var</i></code> обычно будет строкой (если только оно 
		не является результатом из <a href="#upload">file upload</a>(загрузки файла),
		и в этом случае оно вообще не будет преобразовано), но если указан 
		<code xmlns=""><i>parameter-type</i></code>(тип параметра) (который вычисляется),
		строка будет преобразована в другой Тип Lisp по следующим правилам:
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            Если соответствующий параметр GET или POST не был предоставлен клиентом, 
		значением <code xmlns=""><i>var</i></code> будет <code>NIL</code>.
		Если <code xmlns=""><i>parameter-type</i></code> - <code>'STRING</code>, 
		значение <code xmlns=""><i>var</i></code> остается неизменным. 
		Если <code xmlns=""><i>parameter-type</i></code> - <code>'INTEGER</code, 
		а строка параметра состоит только из десятичных цифр, значением 
		<code xmlns=""><i>var</i></code> будет соответствующее целое число, 
		в противном случае - <code>NIL</code>. 
		Если <code xmlns=""><i>parameter-type</i></code> - <code>'KEYWORD</code>,
		значением <code xmlns=""><i>var</i></code> будет ключевое слово, полученное путем
		<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_intern.htm">interning</a>(вставки) строки параметра в 
		<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stg_up.htm#string-upcase">upcased</a>(верхнем регистре) в 
		<a href="http://www.lispworks.com/documentation/HyperSpec/Body/11_abc.htm">keyword
              package</a>(пакет ключевых слов). 
		Если <code xmlns=""><i>parameter-type</i></code> - <code>'CHARACTER</code> и
		длина строки параметра равна единице, значением <code xmlns=""><i>var</i></code>
		будет единственный символьный знак этой строки, в противном случае - <code>NIL</code>. 
		Если <code xmlns=""><i>parameter-type</i></code> - <code>'BOOLEAN</code>,
		значение <code xmlns=""><i>var</i></code> всегда будет <code>T</code> (если,
		конечно, это не <code>NIL</code> по первому правилу выше). 
		Если <code xmlns=""><i>parameter-type</i></code> - любой другой атом,
		предполагается, что это <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_f.htm#function_designator">function designator</a>(указатель функции) для унарной
		функции, которая будет вызываться для преобразования строки во что-то еще. 
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            Это были правила для <em>простых</em> типов параметров, но 
		<code xmlns=""><i>parameter-type</i></code> также может быть списком, 
		начинающимся с одного из символов <code>LIST</code>, <code>ARRAY</code>,
		или <code>HASH-TABLE</code>. Второе значение списка всегда должно быть 
		простым типом параметра, как в последнем абзаце - ниже мы назовем его 
		 <em>inner type</em>(внутренним типом).
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            В случае <code>'LIST</code> все параметры GET/POST с именем 
		 <code xmlns=""><i>real-name</i></code> будут собраны, преобразованы во 
		внутренний тип в соответствии с приведенными выше правилами и собраны в список,
		который будет значением <code xmlns=""><i>var</i></code>.
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            В случае <code>'ARRAY</code> все параметры GET/POST, которые имеют имя, 
		подобное результату 
          </p>

          <pre xmlns="http://www.w3.org/1999/xhtml">(format nil "~A[~A]" real-name n)</pre>
		где <code><i>n</i></code> - неотрицательное целое число, будет собран в массив,
		где <code><i>n</i></code>-й элемент будет установлен соответствующим образом
		после преобразования во внутренний тип. Массив, который станет значением
		<code><i>var</i></code>, будет достаточно большим, чтобы содержать все
		совпадающие параметры, но не больше. Элементы массива, не установленные, 
		как описано выше, будут иметь значение <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>. 
		Обратите внимание, что <code xmlns="http://www.w3.org/1999/xhtml">VAR</code>
		всегда будет привязан к массиву, который может быть пустым, поэтому он никогда 
		не будет равен <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>, даже если
		не найдены подходящие параметры GET/POST.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Полная форма типа параметра <code>'HASH-TABLE</code>: 
          </p>

          <pre xmlns="http://www.w3.org/1999/xhtml">(hash-table inner-type key-type test-function)</pre>
         но <code><i>key-type</i></code> и <code><i>test-function</i></code> могут быть опущены,
		 и в этом случае они по умолчанию равны 
		<code xmlns="http://www.w3.org/1999/xhtml">'STRING</code> и
		<code xmlns="http://www.w3.org/1999/xhtml">'EQUAL</code>, соответственно. 
		Для этого типа параметра все параметры GET/POST, которые имеют имя, подобное
		результату 
          <pre xmlns="http://www.w3.org/1999/xhtml">(format nil "~A{~A}" real-name key)</pre>
          (где <code><i>key</i></code>(ключ) - это строка, не содержащая фигурных скобок) 
		станут значениями (после преобразования во 
		<code><i>inner-type</i></code>(внутренний тип)) хеш-таблицы с тестовой функцией
		<code><i>test-function</i></code>, где ключ (после преобразования в 
		<code><i>key-type</i></code>) будет соответствующим ключ. Обратите внимание, что
		<code><i>var</i></code> всегда будет привязан к хеш-таблице, которая может быть
		пустой, поэтому она никогда не будет <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>, даже если не найдены подходящие параметры GET/POST.
          <p xmlns="http://www.w3.org/1999/xhtml">
            	Чтобы еще больше усложнить ситуацию, три типа составных параметров также 
		имеют сокращенную форму - просто один из символов <code>LIST</code>, 
		<code>ARRAY</code> или <code>HASH-TABLE</code>. В этом случае внутренним типом 
		по умолчанию будет  <code>'STRING</code>.
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            Если <code xmlns=""><i>parameter-type</i></code> не указан или <code>NIL</code>, 
		вместо него будет использоваться <code xmlns=""><i>default-parameter-type</i></code>
		(значение по умолчанию - <code>'STRING</code>).

          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            Если результатом вышеперечисленных вычислений будет то, что 
		<code xmlns=""><i>var</i></code> будет привязана к <code>NIL</code>, тогда 
		вместо этого будет вычислятся <code xmlns=""><i>init-form</i></code> 
		(если она предоставляется), а <code xmlns=""><i>var</i></code> будет привязан 
		к результату этого вычисления. 
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            Обработчики, созданные с помощью этого макроса, построены таким образом, 
		что результирующая функция Lisp полезна даже за пределами Hunchentoot. 
		В частности, все вышеперечисленные вычисления параметров будут происходить 
		только в том случае, если <code xmlns=""><a href="#*request*">*REQUEST*</a></code>
		привязан, то есть если мы находимся внутри запроса Hunchentoot. В противном
		случае <code xmlns=""><i>var</i></code> всегда будет привязан к результату 
		вычисления <code xmlns=""><i>init-form</i></code>, если не указан 
		соответствующий аргумент ключевого слова.
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            <a href="#example">Пример кода</a>, поставляемый с Hunchentoot, содержит 
		пример, демонстрирующий некоторые функциональности
		<code xmlns=""><a href="#define-easy-handler">DEFINE-EASY-HANDLER</a></code>.
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="dispatch-easy-handlers"></a>
          [Function]
          <br><b>dispatch-easy-handlers</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Это диспетчер, который
	возвращает соответствующий обработчик, определенный с помощью 
	<code><a href="#define-easy-handler">DEFINE-EASY-HANDLER</a></code>, если он есть. 
        </clix:description></blockquote>
<p></p>

    <h4 xmlns=""><a name="requests">>Request objects(Объекты запроса)</a></h4>

      Для каждого входящего запроса <a href="#acceptors">acceptor</a> (в 
	<code xmlns=""><a href="#process-connection">PROCESS-CONNECTION</a></code>) создает 
	объект <code xmlns=""><a href="#request">REQUEST</a></code> и делает его доступным 
	для <a href="#request-dispatch">handlers</a>(обработчиков) через специальную переменную
	<code xmlns=""><a href="#*request*">*REQUEST*</a></code>. Этот объект содержит всю
	необходимую информацию о запросе, а в этом разделе собраны функции, которые можно
	использовать для запроса такого объекта. Во всех функциях, где 
	<code xmlns=""><i>request</i></code>(запрос) является необязательным или ключевым
	параметром, значение по умолчанию - 
	<code xmlns=""><a href="#*request*">*REQUEST*</a></code>.

<p>
        Если вам нужен более детальный контроль над поведением объектов запроса, 
	вы можете создать подкласс <code xmlns=""><a href="#request">REQUEST</a></code> 
	и соответственно инициализировать слот 
	<a href="#acceptor-request-class"><code>REQUEST-CLASS</code></a> класса 
	<code xmlns=""><a href="#acceptor">ACCEPTOR</a></code>. Акцептор будет 
	генерировать объекты запроса класса, названного этим слотом. 
      </p>

      <p xmlns=""><a class="none" name="request"></a>
      [Standard class]
      <br><b>request</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Объекты этого класса содержат всю информацию о входящем запросе. 
	Они создаются автоматически акцепторами и могут быть доступны соответствующему 
	<a xmlns="http://www.w3.org/1999/xhtml" href="#request-dispatch">обработчику</a>.

          Вы не должны напрямую связываться со слотами этих объектов, но вы можете 
	создать подкласс <code><a href="#request">REQUEST</a></code>, чтобы реализовать 
	свое собственное поведение. См. Слот <a xmlns="http://www.w3.org/1999/xhtml" href="#acceptor-request-class"><code>REQUEST-CLASS</code></a> класса
	<code><a href="#acceptor">ACCEPTOR</a></code>. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*request*"></a>
      [Special variable]
      <br><b>*request*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Текущий объект REQUEST в
контексте запроса. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="real-remote-addr"></a>
          [Function]
          <br><b>real-remote-addr</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">string{, list}
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает входящий HTTP-заголовок '<code xmlns="http://www.w3.org/1999/xhtml">X-Forwarded-For</code>' в качестве второго значения в форме списка IP-адресов и первого 
	элемента этого списка в качестве первого значения, если этот заголовок существует. 
	В противном случае возвращает значение <code><a href="#remote-addr">REMOTE-ADDR</a></code>
	как единственное значение. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="parameter"></a>
          [Function]
          <br><b>parameter</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">name
        <tt>&amp;optional
        </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">string
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает параметр GET или POST с именем <code><i>name</i></code> (строка) - 
	или <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>, если его нет. 
	Если существуют параметры GET и POST с одним и тем же именем, возвращается параметр GET.
	Поиск чувствителен к регистру букв. См. Также  
          <code><a href="#get-parameter">GET-PARAMETER</a></code> и
          <code><a href="#post-parameter">POST-PARAMETER</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="get-parameter"></a>
          [Function]
          <br><b>get-parameter</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">name <tt>&amp;optional</tt> request</clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">string</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает значение параметра GET (как предоставлено через URI запроса), 
	названное  строкой <code><i>name</i></code> в виде строки (или 
	<code xmlns="http://www.w3.org/1999/xhtml">NIL</code>, если нет параметра GET с 
	таким именем). Обратите внимание, что будет возвращено только первое значение, 
	если клиент предоставил более одного параметра GET с именем <code><i>name</i></code>. 
	См. Также   <code><a href="#get-parameters*">GET-PARAMETERS*</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="post-parameter"></a>
          [Function]
          <br><b>post-parameter</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">name <tt>&amp;optional</tt> request</clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">string</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает значение параметра POST (как указано в теле запроса), названного 
	строкой <code><i>name</i></code>. Обратите внимание, что будет возвращено только 
	первое значение, если клиент предоставил более одного параметра POST с именем 
	<code><i>name</i></code>. Это значение обычно будет строкой (или 
	<code xmlns="http://www.w3.org/1999/xhtml">NIL</code>, если нет параметра POST с 
	таким именем). Если, однако, браузер отправил 
	<a xmlns="http://www.w3.org/1999/xhtml" class="none" name="upload">file</a>(файл)
	через форму <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.faqs.org/rfcs/rfc2388.html"> <code>multipart/form-data</code> </a>, значение этой функции будет трехэлементным списком. 
          <pre xmlns="http://www.w3.org/1999/xhtml">(path file-name content-type)</pre>
          где <code><i>path</i></code> - это путь, обозначающий место, где был сохранен
	загруженный файл,<code><i>file-name</i></code> (строка) - это имя файла, отправленное
	браузером, а <code><i>content-type</i></code> (также строка) - это тип контента,
	отправляемый браузером. Файл, обозначенный путем(<code><i>path</i></code>), будет 
	удален после обработки запроса - вам нужно переместить или скопировать его в другое
	место, если вы хотите его сохранить.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Параметры POST будут вычисляться только в том случае, если тип содержимого тела
		 запроса было <code>multipart/form-data</code> или 
		<code>application/x-www-form-urlencoded</code>. Хотя эта функция называется 
		<code>POST-PARAMETER</code>, вы можете указать Hunchentoot вычислить эти
		параметры для других методов запроса, установив 
 <code xmlns=""><a href="#*methods-for-post-parameters*">*METHODS-FOR-POST-PARAMETERS*</a></code>.
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            См. Также  <code xmlns=""><a href="#post-parameters">POST-PARAMETERS</a></code>
            и <code xmlns=""><a href="#*tmp-directory*">*TMP-DIRECTORY*</a></code>.
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="get-parameters*"></a>
          [Function]
          <br><b>get-parameters*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc"><tt>&amp;optional</tt> request</clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">alist</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_a.htm#alist">alist</a> всех параметров GET 
	(предоставленных через URI запроса). <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#car">car</a> каждого элемента 
	этого списка - это имя параметра, а <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#cdr">cdr</a> - его значение 
	(в виде строки). Элементы этого списка расположены в том же порядке, что и в URI 
	запроса. См. Также <code><a href="#get-parameter">GET-PARAMETER</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="post-parameters*"></a>
          [Function]
          <br><b>post-parameters*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc"><tt>&amp;optional</tt> request</clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">alist</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_a.htm#alist">alist</a> всех параметров POST 
	(как указано в теле запроса). <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#car">car</a> каждого элемента 
	этого списка - это имя параметра, а <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#cdr">cdr</a> - его значение. 
	Элементы этого списка расположены в том же порядке, что и в теле запроса.
	См. Также <code xmlns=""><a href="#post-parameter">POST-PARAMETER</a></code>.
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*methods-for-post-parameters*"></a>
      [Special variable]
      <br><b>*methods-for-post-parameters*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
        Список типов методов запроса (в виде ключевых слов), для которых Hunchentoot будет 
	пытаться вычислить  <code><i>post-parameters</i></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="cookie-in"></a>
          [Function]
          <br><b>cookie-in</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">name
        <tt>&amp;optional
        </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">string
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает файл cookie с именем <code><i>name</i></code> (строка), отправленный
	браузером, или <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>, если его нет. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="cookies-in*"></a>
          [Function]
          <br><b>cookies-in*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">alist
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Возвращает список всех файлов
	 cookie, связанных с  объектом <code><i>request</i></code>(запроса)
	<code><a href="#request">REQUEST</a></code>. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="host"></a>
          [Function]
          <br><b>host</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">host
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Возвращает значение входящего HTTP-заголовка 'Host'. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="query-string*"></a>
          [Function]
          <br><b>query-string*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">string
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает строку запроса запроса объекта <code><a href="#request">REQUEST</a></code>.
	Это часть, стоящая за вопросительным знаком (т.е. параметры GET). 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="referer"></a>
          [Function]
          <br><b>referer</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает http-заголовок 'Referer' (sic!). 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="request-method*"></a>
          [Function]
          <br><b>request-method*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">keyword
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает метод запроса как ключевое слово Lisp. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="request-uri*"></a>
          [Function]
          <br><b>request-uri*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">uri
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает URI запроса. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="server-protocol*"></a>
          [Function]
          <br><b>server-protocol*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">keyword
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает протокол запроса как ключевое слово Lisp. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="user-agent"></a>
          [Function]
          <br><b>user-agent</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает 'User-Agent' http-заголовка. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="header-in*"></a>
          [Function]
          <br><b>header-in*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">name
        <tt>&amp;optional
        </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">header
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает входящий заголовок с именем <code><i>name</i></code>. 
	<code><i>name</i></code> может быть ключевым словом (рекомендуется) 
	или строкой. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="headers-in*"></a>
          [Function]
          <br><b>headers-in*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">alist
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает alist входящих заголовков, связанных с объектом <code><i>запроса</i></code>
	<code><a href="#request">REQUEST</a></code> .
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="remote-addr*"></a>
          [Function]
          <br><b>remote-addr*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">address
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает адрес, с которого был отправлен текущий запрос. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="remote-port*"></a>
          [Function]
          <br><b>remote-port*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">port
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает порт, с которого исходил текущий запрос. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="local-addr*"></a>
          [Function]
          <br><b>local-addr*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">address
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          IP-адрес локальной системы, к которой подключился клиент. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="local-port*"></a>
          [Function]
          <br><b>local-port*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">port
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Номер TCP-порта локальной системы, к которой подключился клиент. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="script-name*"></a>
          [Function]
          <br><b>script-name*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">script-name
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает имя файла  объекта  <code><i>запроса</i></code> 
	<code><a href="#request">REQUEST</a></code>. Это запрошенный URI без строки запроса 
	(т.е. параметров GET). 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="aux-request-value"></a>
      [Accessor]
      <br><b>aux-request-value</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">symbol
        <tt>&amp;optional
        </tt> request
        </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">value, present-p
        </clix:returns></i><br><tt>(setf (</tt><b>aux-request-value</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">symbol
        <tt>&amp;optional
        </tt> request
        </clix:lambda-list></i><tt>) <i>new-value</i>)</tt></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Этот метод доступа можно использовать для связывания произвольных данных с символом
	<code><i>symbol</i></code> в объекте <code><i>запроса</i></code> 
	<code><a href="#request">REQUEST</a></code>. <code><i>present-p</i></code> истинно, 
	если такие данные были найдены, в противном случае - 
	<code xmlns="http://www.w3.org/1999/xhtml">NIL</code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="delete-aux-request-value"></a>
          [Function]
          <br><b>delete-aux-request-value</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">symbol
        <tt>&amp;optional
        </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">|
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Удаляет значение, связанное с <code><i>symbol</i></code>, из объекта 
	<code><i>запроса</i></code> <code><a href="#request">REQUEST</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="authorization"></a>
          [Function]
          <br><b>authorization</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает в виде двух значений пользователя и пароль (если есть), 
	закодированных в заголовке 'AUTHORIZATION'. Если такого заголовка нет, возвращает 
	<code xmlns="http://www.w3.org/1999/xhtml">NIL</code>. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*hunchentoot-default-external-format*"></a>
      [Special variable]
      <br><b>*hunchentoot-default-external-format*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Внешний формат, используемый для вычисления объекта 
	<code><a href="#request">REQUEST</a></code>. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*file-upload-hook*"></a>
      [Special variable]
      <br><b>*file-upload-hook*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Если это не <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>, это должна быть
	унарная функция, которая будет вызываться с указанием пути для каждого файла,
	<a xmlns="http://www.w3.org/1999/xhtml" href="#upload">uploaded</a>(загруженного)
	в Hunchentoot. Имя пути обозначает временный файл, в который записывается загруженный
	файл. hook вызывается непосредственно перед созданием файла. На этом этапе 
	<code><a href="#*request*">*REQUEST*</a></code> уже привязан к текущему объекту 
	<code><a href="#request">REQUEST</a></code>, но, очевидно, вы еще не можете получить
	доступ к параметрам публикации(post). 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="raw-post-data"></a>
          [Function]
          <br><b>raw-post-data</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;key</tt>
          request external-format force-text force-binary want-stream
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">raw-body-or-stream</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает содержимое, отправленное клиентом в теле запроса, если оно было 
	(если тип содержимого(content type) не был <code xmlns="http://www.w3.org/1999/xhtml">multipart/form-data</code>, и в этом случае возвращается 	
	<code xmlns="http://www.w3.org/1999/xhtml">NIL</code>). По умолчанию результатом 
	является строка, если <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.faqs.org/rfcs/rfc1590.html">media type</a>(тип носителя) code xmlns="http://www.w3.org/1999/xhtml">Content-Type</code> - <code xmlns="http://www.w3.org/1999/xhtml">"text"</code>, и вектор октетов 
	в противном случае. В случае строки внешний формат, который будет использоваться 
	для декодирования содержимого, будет определяться из параметра <code xmlns="http://www.w3.org/1999/xhtml">charset</code>(кодировки), отправленного клиентом (в противном случае
	будет использоваться <a href="#*hunchentoot-default-external-format*">*HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*</a></code>).
          <p xmlns="http://www.w3.org/1999/xhtml">
            Вы также можете явно указать внешний формат (через 
	<code xmlns=""><i>external-format</i></code>), и в этом случае результатом безусловно
	будет строка. Точно так же вы можете предоставить истинное значение для 
	<code xmlns=""><i>force-text</i></code>, которое заставит Hunchentoot действовать так,
	как если бы типом media type(типом носителя) был <code>"text"</code> (с 
	<code xmlns=""><i>external-format</i></code>(внешним форматом), имеющим приоритет, 
	если он предоставлен). Или вы можете указать истинное значение для 
	<code xmlns=""><i>force-binary</i></code>, что означает, что вам нужен вектор 
	октетов в любом случае. (Если и <code xmlns=""><i>force-text</i></code>, и 
	<code xmlns=""><i>force-binary</i></code> истинны, будет сигнализироваться ошибка.) 
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            Если, однако, вы укажете истинное значение для 
		<code xmlns=""><i>want-stream</i></code>, другие параметры будут проигнорированы,
		и вы получите поток содержимого (flexi) для чтения из него самостоятельно. 
		Тогда вы обязаны прочитать правильный объем данных, потому что в противном 
		случае вы не сможете вернуть ответ клиенту. Для потока <a href="http://weitz.de/flexi-streams/#flexi-streams">octet position</a>(позиция октета) будет установлено значение 0.
		Если клиент предоставил заголовок  <code>Content-Length</code>, поток также 
		будет иметь соответствующую <a href="http://weitz.de/flexi-streams/#flexi-streams">bound/границу</a>, поэтому независимо от того, использовал ли клиент 
		chunked encoding(фрагментированное кодирование) или нет, вы всегда можете 
		читать до EOF.
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            Если тип контента запроса был <code>multipart/form-data</code> или 
		<code>application/x-www-form-urlencoded</code>, контент уже был прочитан
		Hunchentoot, и вы больше не можете читать из потока. 
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            Вы можете вызывать <code xmlns=""><a href="#raw-post-data">RAW-POST-DATA</a></code>
		более одного раза за запрос, но вы не можете смешивать вызовы, которые имеют 
	разные значения для <code xmlns=""><i>want-stream</i></code>.
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            Обратите внимание, что эта функция имеет несколько неправильное название, 
		потому что клиент может отправлять контент, даже если метод запроса не 
		является POST. 
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="recompute-request-parameters"></a>
          [Function]
          <br><b>recompute-request-parameters</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;key
          </tt> request external-format
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">|
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Повторно вычисляет параметры GET и POST для объекта <code><i>запроса</i></code> 
	<code><a href="#request">REQUEST</a></code>. Это имеет смысл только в том случае, 
	если вы переключаете внешние форматы во время запроса. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="process-request"></a>
          [Generic function]
          <br><b>process-request</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">nil
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Эта функция вызывается <code><a href="#process-connection">PROCESS-CONNECTION</a></code> после того, как входящие заголовки были прочитаны. Он вызывает <code><a href="#handle-request">HANDLE-REQUEST</a></code> (и является более или менее тонкой оболочкой вокруг него) 
	для выбора и вызова <a xmlns="http://www.w3.org/1999/xhtml" href="#request-dispatch">handler</a>(обработчика) и отправки вывода этого обработчика клиенту. 
	Обратите внимание, что <code><a href="#process-connection">PROCESS-CONNECTION</a></code>
	вызывается один раз для каждого соединения и зацикливается в случае постоянного
	соединения, в то время как <code><a href="#process-request">PROCESS-REQUEST</a></code>
	вызывается заново для каждого запроса.

          <p xmlns="http://www.w3.org/1999/xhtml">
            Возвращаемое значение этой функции игнорируется.
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            Как и <code xmlns=""><a href="#process-connection">PROCESS-CONNECTION</a></code>, 
	это еще одна функция, поведение которой вам следует изменять только в том случае, 
	если вы действительно, действительно знаете, что делаете. 
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="handle-request"></a>
          [Generic function]
          <br><b>handle-request</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">content
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Эта функция вызывается <code><a href="#process-request">PROCESS-REQUEST</a></code>
	после того, как запрос был прочитан и был создан объект 
	<code><a href="#request">REQUEST</a></code>. Её задача - фактически обработать запрос, 
	то есть вернуть что-то клиенту.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Метод по умолчанию вызывает <a href="#request-dispatch">request dispatcher</a>(диспетчер запросов) акцептора, но вы, конечно, можете реализовать другое поведение. 
	Метод по умолчанию также устанавливает 
	<a href="#logging">стандартную обработку ошибок</a> для 
	обработчика(<a href="#request-dispatch">handler</a>).
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            Возможно, это хорошее место для привязки или повторной привязки специальных 
	переменных, которые затем будут доступны вашим обработчикам(<a href="#request-dispatch">handlers</a>).
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="acceptor-dispatch-request"></a>
          [Generic function]
          <br><b>acceptor-dispatch-request</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">content
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Эта функция вызывается для фактической отправки запроса после настройки 
	стандартного ведения журнала и обработки ошибок. Подклассы 
	<code><a href="#acceptor">ACCEPTOR</a></code> реализуют методы для этой функции, 
	чтобы выполнять свою собственную маршрутизацию запросов. Если метод не хочет 
	обрабатывать запрос, он должен вызвать <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.lispworks.com/documentation/HyperSpec/Body/f_call_n.htm">CALL-NEXT-METHOD</a>,
	чтобы следующий <code><a href="#acceptor">ACCEPTOR</a></code> в цепочке наследования
	получил возможность обработать запрос. 
        </clix:description></blockquote>
<p></p>

      <p xmlns="">
      [Generic readers]<br><a class="none" name="cookies-in"></a><b>cookies-in</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">cookies
          </clix:returns></i><br><a class="none" name="get-parameters"></a><b>get-parameters</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">get-parameters
          </clix:returns></i><br><a class="none" name="header-in"></a><b>header-in</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">name request
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
          </clix:returns></i><br><a class="none" name="headers-in"></a><b>headers-in</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">headers
          </clix:returns></i><br><a class="none" name="post-parameters"></a><b>post-parameters</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">post-parameters
          </clix:returns></i><br><a class="none" name="query-string"></a><b>query-string</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">query-string
          </clix:returns></i><br><a class="none" name="remote-addr"></a><b>remote-addr</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">address
          </clix:returns></i><br><a class="none" name="remote-port"></a><b>remote-port</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">port
          </clix:returns></i><br><a class="none" name="local-addr"></a><b>local-addr</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">address
          </clix:returns></i><br><a class="none" name="local-port"></a><b>local-port</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">port
          </clix:returns></i><br><a class="none" name="request-acceptor"></a><b>request-acceptor</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">acceptor
          </clix:returns></i><br><a class="none" name="request-method"></a><b>request-method</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">method
          </clix:returns></i><br><a class="none" name="request-uri"></a><b>request-uri</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">uri
          </clix:returns></i><br><a class="none" name="server-protocol"></a><b>server-protocol</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">protocol
          </clix:returns></i><br><a class="none" name="script-name"></a><b>script-name</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
          </clix:returns></i><br></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
         Это различные обобщенные считыватели, которые используются для чтения информации 
	об объекте <code><a href="#request">REQUEST</a></code>. Если вы пишете 
	<a xmlns="http://www.w3.org/1999/xhtml" href="#request-dispatch">handler</a>(обработчик), 
	вам <em xmlns="http://www.w3.org/1999/xhtml">не</em> следует использовать эти
	считыватели, а вместо этого использовать соответствующие функции со звездочкой в 
	конце их имени, также перечисленные в этом разделе. Эти обобщенные считыватели
	экспортируются только для пользователей, которые хотят создать свои собственные 
	подклассы <code><a href="#request">REQUEST</a></code>.
        </clix:description></blockquote>
<p></p>

    <h4 xmlns=""><a name="replies">>Reply objects( Объекты ответа)</a></h4>

      Для каждого входящего запроса, <a href="#acceptors">acceptor</a>
      (в <code xmlns=""><a href="#process-connection">PROCESS-CONNECTION</a></code>) создает
      объект <code xmlns=""><a href="#reply">REPLY</a></code> и делает его доступным для
      <a href="#request-dispatch">handlers(обработчиков)</a> через специальную переменную
      <code xmlns=""><a href="#*reply*">*REPLY*</a></code>.  Этот объект содержит всю
      соответствующую информацию (кроме тела содержимого/content body) об ответе, который будет
      отправлен клиенту, и в этом разделе собраны функции, которые можно использовать для запроса
      и изменения такого объекта.  Во всех функциях, где <code xmlns=""><i>reply</i></code>
      (ответ) является необязательным(опциональным) или  ключевым словом, по умолчанию
      используется <code xmlns=""><a href="#*reply*">*REPLY*</a></code>.

<p>
        Если вам нужен более детальный контроль над поведением объектов ответа(reply), вы можете
        создать подкласс <code xmlns=""><a href="#reply">REPLY</a></code> и соответственно
        инициализировать слот <a href="#acceptor-reply-class"><code>REPLY-CLASS</code></a>
        класса <code xmlns=""><a href="#acceptor">ACCEPTOR</a></code>.  Акцептор(приемник)
        будет генерировать объекты ответа классом, именуемым/называемым этим слотом.
      </p>

      <p xmlns=""><a class="none" name="reply"></a>
      [Standard class]
      <br><b>reply</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Объекты этого класса содержат всю информацию об исходящем ответе. Они создаются
          Hunchentoot автоматически и могут быть доступны и изменены соответствующим
          <a xmlns="http://www.w3.org/1999/xhtml" href="#request-dispatch">handler</a>
          (обработчиком).
        <p xmlns="http://www.w3.org/1999/xhtml">
          Вы не должны напрямую связываться со слотами этих объектов, но вы можете создать
          подкласс <code xmlns=""><a href="#reply">REPLY</a></code>, чтобы реализовать свое
          собственное поведение.  См. инициализирующий аргумент(initarg)
          <a href="#acceptor-reply-class"><code>:reply-class</code></a> 
          класса <code xmlns=""><a href="#acceptor">ACCEPTOR</a></code>.
        </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*reply*"></a>
      [Special variable]
      <br><b>*reply*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Текущий объект <code><a href="#reply">REPLY</a></code> в контексте запроса.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="header-out"></a>
      [Accessor]
      <br><b>header-out</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">name
        <tt>&amp;optional
        </tt> reply
        </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">string
        </clix:returns></i><br><tt>(setf (</tt><b>header-out</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">name
        <tt>&amp;optional
        </tt> reply
        </clix:lambda-list></i><tt>) <i>new-value</i>)</tt></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          <code><a href="#header-out">HEADER-OUT</a></code> возвращает исходящий заголовок http
          названный именем ключевого слова <code><i>name</i></code>, если оно есть, в противном
          случае - <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>. 
          <code xmlns="http://www.w3.org/1999/xhtml">SETF</code>
          для <code><a href="#header-out">HEADER-OUT</a></code> изменяет текущее значение
          заголовка с именем <code><i>name</i></code>. Если заголовка с именем
          <code><i>name</i></code> не существует, он создается. Для обратной совместимости
          <code><i>name</i></code> также может быть строкой, и в этом случае связь между
          заголовком и его именем не чувствительна к регистру.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Обратите внимание, что заголовок 'Set-Cookie' не может быть запрошен с помощью
            <code xmlns=""><a href="#header-out">HEADER-OUT</a></code> и не должен устанавливаться
            <code>SETF</code> для  <code xmlns=""><a href="#header-out">HEADER-OUT</a></code>.
            См. также <code xmlns=""><a href="#headers-out*">HEADERS-OUT*</a></code>,
            <code xmlns=""><a href="#content-type*">CONTENT-TYPE*</a></code>,
            <code xmlns=""><a href="#content-length*">CONTENT-LENGTH*</a></code>,
            <code xmlns=""><a href="#cookies-out*">COOKIES-OUT*</a></code> и
            <code xmlns=""><a href="#cookie-out">COOKIE-OUT</a></code>.
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="headers-out*"></a>
          [Function]
          <br><b>headers-out*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> reply
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">alist
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Возвращает alist исходящих
        заголовков связанных с объектом <code><i>reply(ответа)</i></code>
        <code><a href="#reply">REPLY</a></code>.  См. также
        <code><a href="#header-out">HEADER-OUT</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="content-length*"></a>
      [Accessor]
      <br><b>content-length*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> reply
        </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">content-length
        </clix:returns></i><br><tt>(setf (</tt><b>content-length*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> reply
        </clix:lambda-list></i><tt>) <i>new-value</i>)</tt></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Исходящий http заголовок <code><i>ответа</i></code> 'Content-Length'.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="content-type*"></a>
      [Accessor]
      <br><b>content-type*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> reply
        </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">content-type
        </clix:returns></i><br><tt>(setf (</tt><b>content-type*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> reply
        </clix:lambda-list></i><tt>) <i>new-value</i>)</tt></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Исходящий http заголовок <code><i>ответа</i></code> 'Content-Type'.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="cookie-out"></a>
          [Function]
          <br><b>cookie-out</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">name
        <tt>&amp;optional
        </tt> reply
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает текущее значение исходящего 
          <a xmlns="http://www.w3.org/1999/xhtml" href="#cookies">cookie</a> с именем
          <code><i>name</i></code>. Поиск чувствителен к регистру букв.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="cookies-out*"></a>
      [Accessor]
      <br><b>cookies-out*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> reply
        </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">alist
        </clix:returns></i><br><tt>(setf (</tt><b>cookies-out*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> reply
        </clix:lambda-list></i><tt>) <i>new-value</i>)</tt></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает или создает список исходящих 
          <a xmlns="http://www.w3.org/1999/xhtml" href="#cookies">cookies</a>, связанных с объекто
          <code><i>ответа</i></code>  <code><a href="#reply">REPLY</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="return-code*"></a>
      [Accessor]
      <br><b>return-code*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> reply
        </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">return-code
        </clix:returns></i><br><tt>(setf (</tt><b>return-code*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> reply
        </clix:lambda-list></i><tt>) <i>new-value</i>)</tt></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Получает или устанавливает http-код возврата  <code><i>ответа(reply)</i></code>.
          Код возврата каждого объекта <code><a href="#reply">REPLY</a></code> изначально
          установлен в <code><a href="#+http-ok+">+HTTP-OK+</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="send-headers"></a>
          [Function]
          <br><b>send-headers</b> <i></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">stream</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Отправляет начальную строку состояния и все заголовки, как определено объектом
          <code><a href="#reply">REPLY</a></code> связанным с
          <code><a href="#*reply*">*REPLY*</a></code>.  Возвращает
          <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_b.htm#binary">двоичный</a>
          поток, в который может быть записано тело ответа. После вызова этой функции
          дальнешие изменения в <code><a href="#*reply*">*REPLY*</a></code> не имеют никакого
          эффекта. Кроме того, для этого запроса отключена автоматическая обработка ошибок (т.е
          отправка соответствующего кода состояния браузера и т.д.), и такие функции, как
          <code><a href="#redirect">REDIRECT</a></code> или
          <code><a href="#abort-request-handler">ABORT-REQUEST-HANDLER</a></code> не будут иметь
          желаемого эффекта после отправки заголовков.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Если ваши обработчики возвращают все тело в виде строки или массива октетов, вам
            <em>не</em> следует вызывать эту функцию.
            Если обработчик вызывает 
            <code xmlns=""><a href="#send-headers">SEND-HEADERS</a></code> , его возвращаемое
            значение игнорируется.
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="reply-external-format*"></a>
      [Accessor]
      <br><b>reply-external-format*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> reply
        </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">external-format
        </clix:returns></i><br><tt>(setf (</tt><b>reply-external-format*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> reply
        </clix:lambda-list></i><tt>) <i>new-value</i>)</tt></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Получает или устанавливает внешний формат(external format) <code><i>ответа</i></code>
          который используется для вывода символьных знаков(character).
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*default-content-type*"></a>
      [Special variable]
      <br><b>*default-content-type*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Заголовок content-type(типа содержимого) который возвращается клиенту.
        </clix:description></blockquote>
<p></p>

      <p xmlns="">
      [Constants]<br><b>+http-continue+</b><br><b>+http-switching-protocols+</b><br><b>+http-ok+</b><br><b>+http-created+</b><br><b>+http-accepted+</b><br><b>+http-non-authoritative-information+</b><br><b>+http-no-content+</b><br><b>+http-reset-content+</b><br><b>+http-partial-content+</b><br><b>+http-multi-status+</b><br><b>+http-multiple-choices+</b><br><b>+http-moved-permanently+</b><br><b>+http-moved-temporarily+</b><br><b>+http-see-other+</b><br><b>+http-not-modified+</b><br><b>+http-use-proxy+</b><br><b>+http-temporary-redirect+</b><br><b>+http-bad-request+</b><br><b>+http-authorization-required+</b><br><b>+http-payment-required+</b><br><b>+http-forbidden+</b><br><b>+http-not-found+</b><br><b>+http-method-not-allowed+</b><br><b>+http-not-acceptable+</b><br><b>+http-proxy-authentication-required+</b><br><b>+http-request-time-out+</b><br><b>+http-conflict+</b><br><b>+http-gone+</b><br><b>+http-length-required+</b><br><b>+http-precondition-failed+</b><br><b>+http-request-entity-too-large+</b><br><b>+http-request-uri-too-large+</b><br><b>+http-unsupported-media-type+</b><br><b>+http-requested-range-not-satisfiable+</b><br><b>+http-expectation-failed+</b><br><b>+http-failed-dependency+</b><br><b>+http-internal-server-error+</b><br><b>+http-not-implemented+</b><br><b>+http-bad-gateway+</b><br><b>+http-service-unavailable+</b><br><b>+http-gateway-time-out+</b><br><b>+http-version-not-supported+</b><br></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Значения этих констант:  100, 101, 200, 201, 202,
          203, 204, 205, 206, 207, 300, 301, 302, 303, 304, 305, 307,
          400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411,
          412, 413, 414, 415, 416, 417, 424, 500, 501, 502, 503, 504,
          и 505. См. <code><a href="#return-code">RETURN-CODE</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns="">
      [Generic readers]<br><a class="none" name="content-length"></a><b>content-length</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">reply
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">content-length
          </clix:returns></i><br><a class="none" name="content-type"></a><b>content-type</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">reply
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">content-type
          </clix:returns></i><br><a class="none" name="headers-out"></a><b>headers-out</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">reply
          </clix:lambda-list></i>
        =&gt;
        <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">headers-out
          </clix:returns></i><br></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Это различные универсальные считыватели, которые используются для чтения информации
          об объекте <code><a href="#reply">REPLY</a></code>.  Если вы пишите обработчик -
          <a xmlns="http://www.w3.org/1999/xhtml" href="#request-dispatch">handler</a>, вам
          <em xmlns="http://www.w3.org/1999/xhtml">не следует</em> использовать использовать
          эти считыватели, а вместо этого используйте соответствующие функции со звездочками в
          конце их имени, также перечисленные в этом разделе. Эти обобщенные считыватели
          экспортируются только для пользователей которые хотят создать свои собственные
          подклассы <code><a href="#reply">REPLY</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns="">
      [Generic accessors]<br><a class="none" name="cookies-out"></a><b>cookies-out</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">reply
          </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
          </clix:returns></i><br><tt>(setf (</tt><b>cookies-out</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">reply
          </clix:lambda-list></i><tt>) <i>new-value</i>)</tt><br><a class="none" name="return-code"></a><b>return-code</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">reply
          </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
          </clix:returns></i><br><tt>(setf (</tt><b>return-code</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">reply
          </clix:lambda-list></i><tt>) <i>new-value</i>)</tt><br><a class="none" name="reply-external-format"></a><b>reply-external-format</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">reply
          </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
          </clix:returns></i><br><tt>(setf (</tt><b>reply-external-format</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">reply
          </clix:lambda-list></i><tt>) <i>new-value</i>)</tt><br></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Это различные общие методы доступа, которые используются для запроса и изменения
          объектов <code><a href="#reply">REPLY</a></code>.  Если вы пишете обработчик -
          <a xmlns="http://www.w3.org/1999/xhtml" href="#request-dispatch">handler</a>, вам
          <em xmlns="http://www.w3.org/1999/xhtml">не</em> следует использовать эти средства
          доступа(accessors), а вместо этого используйте соответствующие функции со звездочками
          в конце их имени, также перечисленные в этом разделе. Эти обобщенные акцессоры
          (accessors/средства доступа) экспортируются только для пользователей, которые
          хотят создать свои собственные подклассы <code><a href="#reply">REPLY</a></code>.
        </clix:description></blockquote>
<p></p>

    <h4 xmlns=""><a name="sessions">Сессии</a></h4>
      Hunchentoot поддерживает сессии(<em>sessions</em>): после того, как 
      <a href="#request-dispatch">обработчик запроса(request handler</a> вызвал 
      <code xmlns=""><a href="#start-session">START-SESSION</a></code>, Hunchentoot
      использует cookies или (если клиент не отправляет cookies обратно) 
      <a href="#*rewrite-for-session-urls*">перезапись URL-адресов</a>, чтобы отслеживать
      этого клиента, т.е предоставляет разновидность 'состояния' для HTTP протокола
      не поддерживающего состояния. Сессия(сеанс), связанный с клиентом, представляют собой
      <a href="#session">объект CLOS</a>, который может использоваться для  
      <a href="#session-value">хранения произвольных данных</a> между запросами.

<p>
        Hunchentoot прилагает разумные усилия для предотвращения перехвата сеансов
        злоумышленниками (см. ниже), но это не следует считать действительно безопасным.
        Не храните конфиденциальные данные в сеансах и полагайтесь на исключительно на механизм
        сеанса в качестве защиты от злоумышленников, которые хотят получить эти данные!
      </p>

<p>
        Для каждого запроса(request) существует один объект 
        <code xmlns=""><a href="#session">SESSION</a></code> доступный обработчику
        (<a href="#handler">handler</a>) через специальную переменную
        <code xmlns=""><a href="#*session*">*SESSION*</a></code>. Этот объект содержит
        всю доступную информацию о сеансе, и к нему можно получить доступ с помощью функций,
        описанных в этой главе. Обратите внимание, что внутреннюю структуру объектов
        <code xmlns=""><a href="#session">SESSION</a></code> следует считать непрозрачной и
        она может измениться в будущих выпусках Hunchentoot.
      </p>

<p>
        Сессии автоматически <a href="#session-verify">проверяются</a> на действительность и
        возраст при создании экземпляра класса 
        <code xmlns=""><a href="#request">REQUEST</a></code>, т.е если 
        <code xmlns=""><a href="#*session*">*SESSION*</a></code> не равно NIL, то этот сеанс
        действителен (что касается Hunchentoot) и не 
        <a href="#session-too-old-p">слишком старый</a>.  Старые сеансы
        <a href="#session-gc">автоматически удаляются</a>.
      </p>

<p>
        Hunchentoot также предоставляет функцию 
<code xmlns=""><a href="#session-regenerate-cookie-value">SESSION-REGENERATE-COOKIE-VALUE</a></code>,
        которая создает новое значение cookie. Это помогает предотвратить
        <a href="https://www.owasp.org/index.php/Session_fixation">атаки фиксации сеанса</a>, 
        и должна использоваться, когда пользователь входит в систему в соответствии с
        приложением.
      </p>

      <p xmlns=""><a class="none" name="session"></a>
      [Standard class]
      <br><b>session</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Объекты сессии(<code><a href="#session">SESSION</a></code>)/сеансы
          автоматически поддерживаются  Hunchentoot.  Они не должны создаваться явно
          с помощью <code xmlns="http://www.w3.org/1999/xhtml">MAKE-INSTANCE</code>, но неявно
          с помощью <code><a href="#start-session">START-SESSION</a></code> и их следует
          рассматривать как непрозрачные(закрытые) объекты.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Вы можете игнорировать Hunchentoot объекты 
           <code xmlns=""><a href="#session">SESSION</a></code> и
            <a href="#session-behaviour">реализовать свои собственные сессии</a>, если вы
            предоставите соответствующие методы для 
            <code xmlns=""><a href="#session-cookie-value">SESSION-COOKIE-VALUE</a></code>
            и <code xmlns=""><a href="#session-verify">SESSION-VERIFY</a></code>.
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="start-session"></a>
          [Function]
          <br><b>start-session</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">session
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает текущий объект <code><a href="#session">SESSION</a></code>.
          Если текущего сеанса нет, создает его и обновляет соответствующие структуры данных.
          В этом случае функция также отправит в браузер cookie сеанса.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="session-value"></a>
      [Accessor]
      <br><b>session-value</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">symbol
        <tt>&amp;optional
        </tt> session
        </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">value, present-p
        </clix:returns></i><br><tt>(setf (</tt><b>session-value</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">symbol
        <tt>&amp;optional
        </tt> session
        </clix:lambda-list></i><tt>) <i>new-value</i>)</tt></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Этот метод доступа(аццессор/accessor) можно использовать для связывания
          произовльных данных с символом <code><i>symbol</i></code> в объекте 
          <code><i>сессии</i></code> <code><a href="#session">SESSION</a></code>.
          <code><i>present-p</i></code> истинно, если такие данные были найдены,
          в противном случае -  <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>.
          Значение по умолчанию для <code><i>сессии</i></code> это
          <code><a href="#*session*">*SESSION*</a></code>.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Если <code>SETF</code> для <code xmlns=""><a href="#session-value">SESSION-VALUE</a></code> вызывается с
            параметром <code xmlns=""><i>session</i></code> равным <code>NIL</code>, то
            сессия автоматически создается с помощью 
            <code xmlns=""><a href="#start-session">START-SESSION</a></code>.
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="delete-session-value"></a>
          [Function]
          <br><b>delete-session-value</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">symbol
        <tt>&amp;optional
        </tt> session
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">|
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Удаляет значение, связанное с <code><i>symbol</i></code> из
          <code><i>сессии/session</i></code>, если он есть.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*session*"></a>
      [Special variable]
      <br><b>*session*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Текущий сеанс(сессия) в контесте запроса, или 
          <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="remove-session"></a>
          [Function]
          <br><b>remove-session</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">session
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">|
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Полностью удаляет объект <code><i>сессию</i></code> 
          <code><a href="#session">SESSION</a></code> из внутренней 
          <a xmlns="http://www.w3.org/1999/xhtml" href="#session-db">базы данных сессий</a>
          Hunchentoot-а.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="reset-sessions"></a>
          [Function]
          <br><b>reset-sessions</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> acceptor
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">|
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Удаляет <em xmlns="http://www.w3.org/1999/xhtml">все</em> сохраненные сессии для
          акцептора(<code><i>acceptor</i></code>).  По умолчанию акцепотора
          (<code><i>acceptor</i></code>) усатновлено
          <code><a href="#*acceptor*">*ACCEPTOR*</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="regenerate-session-cookie-value"></a>
          [Function]
          <br><b>regenerate-session-cookie-value</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">session
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">cookie
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Восстанавливает значение cookie. Это следует использовать
          когда пользователь входит в систему в соответствии с приложением, чтобы
          предотвратить атаки фиксации сеанса. Значение cookie зависит от
          ID, USER-AGENT, REMOTE-ADDR, START и *SESSION-SECRET*,  единственное
          значение, которое мы можем изменить это START, чтобы восстановить
          новое значение. Поскольку мы генерируем новый cookie,
          имеет смысл перезапустить сеанс вовремя. Тем не менее, из-за этого факта,
          вызов этой функции дважды в одну и ту же секунду будет повторно генерировать
          одно и тоже значение.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*rewrite-for-session-urls*"></a>
      [Special variable]
      <br><b>*rewrite-for-session-urls*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Следует ли переписывать HTML URL страницы для управления сеансом
          не использующим  cookie(cookie-less session-management).
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*content-types-for-url-rewrite*"></a>
      [Special variable]
      <br><b>*content-types-for-url-rewrite*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Типы контента(содержимого), для которых допустима перезапись URL(url-rewriting). См.
          <code><a href="#*rewrite-for-session-urls*">*REWRITE-FOR-SESSION-URLS*</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*use-remote-addr-for-sessions*"></a>
      [Special variable]
      <br><b>*use-remote-addr-for-sessions*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Должен ли удаленный IP-адрес клиента (возвращаемый <code><a href="#real-remote-addr">REAL-REMOTE-ADDR</a></code>)
          быть закодирован в строку сеанса.  Если это значение истинно, сеанс перестает быть
          доступным, если удаленный IP-адрес клиента изментся.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Это может быть, например, проблемой, если клиент использует прокси-сервер,
            который не отправляет правильные заголовки 'X-Forwarded-For'.
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="session-remote-addr"></a>
          [Generic function]
          <br><b>session-remote-addr</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">session
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">remote-addr
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Удаленный IP-адрес клиента при запуске этого сеанса (возвращаемый
          <code><a href="#real-remote-addr">REAL-REMOTE-ADDR</a></code>).
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*use-user-agent-for-sessions*"></a>
      [Special variable]
      <br><b>*use-user-agent-for-sessions*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">Должен ли заголовок 'User-Agent'
        быть закодированным в строку сеанса. Если значение истинно, сеанс перестанет быть
        доступным, если клиент отправит другой заголовок 'User-Agent'.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="session-user-agent"></a>
          [Generic function]
          <br><b>session-user-agent</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">session
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">user-agent
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Входящий заголовок 'User-Agent', который был отправлен при создании этого сеанса.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="session-max-time"></a>
      [Generic accessor]
      <br><b>session-max-time</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">session
        </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">max-time
        </clix:returns></i><br><tt>(setf (</tt><b>session-max-time</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">session
        </clix:lambda-list></i><tt>) <i>new-value</i>)</tt></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает или устанавливает время (в секундах) по истечении которого
          <code><i>сеанс</i></code> истекает, если он не используется.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*session-max-time*"></a>
      [Special variable]
      <br><b>*session-max-time*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Время по умолчанию (в сек), по истечении которого время сеанса истекает.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*session-gc-frequency*"></a>
      [Special variable]
      <br><b>*session-gc-frequency*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          GC сессии(сборка мусора сессии) (см. функцию <code><a href="#session-gc">SESSION-GC</a></code>) будет происходить с каждым запросом
          <code><a href="#*session-gc-frequency*">*SESSION-GC-FREQUENCY*</a></code> 
          (считая только запросы, которые создают новый сеанс), если эта переменная не равна
          <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>.  См. <code><a href="#session-created">SESSION-CREATED</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="session-gc"></a>
          [Function]
          <br><b>session-gc</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">|
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Удаляет слишком старые сеансы из базы данных текущих сеансов.
          см. <code><a href="#session-too-old-p">SESSION-TOO-OLD-P</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="session-too-old-p"></a>
          [Function]
          <br><b>session-too-old-p</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">session
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">generalized-boolean
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает истину, если объект <code><i>сессии</i></code>
          <code><a href="#session">SESSION</a></code> не был активен в последние
          <code xmlns="http://www.w3.org/1999/xhtml">(session-max-time&nbsp;session)</code> секунды.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="session-id"></a>
          [Generic function]
          <br><b>session-id</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">session
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">session-id
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Уникальный идентификатор ID (INTEGER) сеанса/сессии.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="session-start"></a>
          [Generic function]
          <br><b>session-start</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">session
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">universal-time
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Время начала сеанса.
        </clix:description></blockquote>
<p></p>

    <h4 xmlns=""><a name="session-behaviour">Настройка поведения сеанса</a></h4>

      Для повседневного использования сеанса вы, вероятно, просто будете использовать 
      <code xmlns=""><a href="#start-session">START-SESSION</a></code>,
      <code xmlns=""><a href="#session-value">SESSION-VALUE</a></code> и, возможно, 
      <code xmlns=""><a href="#delete-session-value">DELETE-SESSION-VALUE</a></code> и 
      <code xmlns=""><a href="#*session*">*SESSION*</a></code>. Однако есть два способа 
      настроить способ поддержки сессий Hunchentoot.

<p>
        Один из способов - в основном оставить механизм сеанса нетронутым, но немного 
        подправить его: 
        </p>

<ul>
          <li>Общедоступная(видимая) часть сеанса кодируется с использованием 
          <a href="#*session-secret*">secret</a>(секрета), который вы можете установить
          самостоятельно.</li>
          <li>И он хранится с использованием <a href="#session-cookie-name">имени</a> cookie 
          (или параметра GET), которое вы можете переопределить.</li>
          <li>Каждый сеанс получает <a href="#next-session-id">новый идентификатор - ID</a> 
          при создании, и вы можете реализовать более надежный способ сделать это.</li>
          <li>Вы можете организовать вызов при каждом <a href="#session-created">создании</a>
          сеанса для запуска какого-либо действия. Вы также можете сделать это, чтобы 
          изобрести собственную  <a href="#session-gc">сборку мусора/
          garbage collection</a> сеанса.</li>
          <li>По умолчанию все сеансы хранятся в глобальном ассоц. списке - alist в памяти. 
          Вы не можете изменить часть alist, но можете распределить свои сеансы 
          по разным <a href="#session-db">"базам данных/databases"</a>.</li>
          <li>По умолчанию каждая операция, которая изменяет сеансы или одну из баз данных
           сеансов, охраняется глобальной блокировкой, но вы можете организовать 
           <a href="#session-db-lock">provide</a>(предоставление) для этого
           различные блокировки. </li>
        </ul>

<p></p>

<p>
        Другой способ настроить сеансы Hunchentoot - полностью заменить их. На самом деле 
        это довольно просто: создайте свой собственный класс для хранения состояния (которое 
        не обязательно и, вероятно, не должно наследовать от 
        <code xmlns=""><a href="#session">SESSION</a></code>) и реализуйте методы для <code xmlns=""><a href="#session-verify">SESSION-VERIFY</a></code>
        и <code xmlns=""><a href="#session-cookie-value">SESSION-COOKIE-VALUE</a></code>- вот
        и все. Hunchentoot будет продолжать использовать  cookie и/или переписывать 
        URL-адреса, чтобы отслеживать состояние сеанса, и сохранит "текущий сеанс" 
        (независимо от того, что есть в вашей реализации) в 
        <code xmlns=""><a href="#*session*">*SESSION*</a></code. Все остальное (например,
        постоянные сеансы, сборщик мусора, получение и установка значений) вам придется
        позаботиться самим, а другие функции сеанса (например, <code xmlns=""><a href="#start-session">START-SESSION</a></code> или
        <code xmlns=""><a href="#session-value">SESSION-VALUE</a></code>) больше не будут
        работать. (Почти) полная свобода, но и большая ответственность ... :) 
      </p>

      <p xmlns=""><a class="none" name="*session-secret*"></a>
      [Special variable]
      <br><b>*session-secret*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Случайная строка ASCII, используемая для кодирования общедоступных данных сеанса. 
          Эта переменная изначально не связана и будет установлена (с помощью 
          <code><a href="#reset-session-secret">RESET-SESSION-SECRET</a></code>) при первом
          создании сеанса, если это необходимо. Вы можете предотвратить это, если установите
          значение самостоятельно перед запуском акцепторов(<a xmlns="http://www.w3.org/1999/xhtml" href="#acceptors">acceptors</a>).
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="reset-session-secret"></a>
          [Function]
          <br><b>reset-session-secret</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">secret
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Устанавливает <code><a href="#*session-secret*">*SESSION-SECRET*</a></code> в
          новое случайное значение. Все старые сеансы перестанут быть действительными. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="session-cookie-name"></a>
          [Generic function]
          <br><b>session-cookie-name</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">name
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает имя (строку)  cookie (или параметра GET), который используется 
          для хранения сеанса на стороне клиента. По умолчанию используется строка 
          <code xmlns="http://www.w3.org/1999/xhtml">"hunchentoot-session"</code>, но вы 
          можете специализировать эту функцию, если хотите другое имя. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="session-created"></a>
          [Generic function]
          <br><b>session-created</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor new-session
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Эта функция вызывается всякий раз, когда создается новый сеанс. Существует метод 
          по умолчанию, который может запускать <a xmlns="http://www.w3.org/1999/xhtml" href="#session-gc">GC сеанса</a> на основе значения
          <code><a href="#*session-gc-frequency*">*SESSION-GC-FREQUENCY*</a></code>.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Возвращаемое значение игнорируется.
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="next-session-id"></a>
          [Generic function]
          <br><b>next-session-id</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">id
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает следующий последовательный идентификатор сеанса, целое число, 
          которое должно быть уникальным для каждого сеанса. Метод по умолчанию использует 
          простой глобальный счетчик и не защищен блокировкой. Для высокопроизводительной
          производственной среды вы можете рассмотреть возможность использования более 
          надежной реализации. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="session-db"></a>
      [Generic accessor]
      <br><b>session-db</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
        </clix:lambda-list></i>
      =&gt;
      <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">database
        </clix:returns></i><br><tt>(setf (</tt><b>session-db</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
        </clix:lambda-list></i><tt>) <i>new-value</i>)</tt></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает текущую базу данных сеанса, которая представляет собой список, 
          где каждая car - это идентификатор сеанса, а cdr - это сам соответствующий объект
          <code><a href="#session">SESSION</a></code>. По умолчанию для всех акцепторов
          используется глобальный список. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="session-db-lock"></a>
          [Generic function]
          <br><b>session-db-lock</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">acceptor
        <tt>&amp;key
        </tt> whole-db-p
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">lock
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Функция, которая возвращает блокировку, которая будет использоваться для 
          предотвращения одновременного доступа к сеансам. Первый аргумент будет акцептором
          (<a xmlns="http://www.w3.org/1999/xhtml" href="#acceptors">acceptor</a>), который
          обрабатывает текущий запрос(<a xmlns="http://www.w3.org/1999/xhtml" href="#requests">request</a>), 
          второй аргумент - истина, если вся (текущая) база данных сеанса изменена. 
          Если он равен <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>, изменяется 
          только один существующий сеанс в базе данных.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Эта функция может возвращать NIL, что означает, что сеансы или базы данных сеансов
            будут изменены без удерживающей блокировки (например, для однопоточных сред). 
            По умолчанию всегда возвращается глобальная блокировка (игнорируя аргумент 
            <code xmlns=""><i>acceptor</i></code>) для Lisp-ов, поддерживающих потоки, и 
            NIL в противном случае. 
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="session-verify"></a>
          [Generic function]
          <br><b>session-verify</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">request
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">session-or-nil
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Пытается получить идентификатор сеанса из cookies (или, альтернативно, из 
          параметров GET), отправленных клиентом (см. 
          <code><a href="#session-cookie-name">SESSION-COOKIE-NAME</a></code> и
          <code><a href="#session-cookie-value">SESSION-COOKIE-VALUE</a></code>). 
          Затем этот идентификатор проверяется на соответствие объекту 
          <code><i>запроса</i></code> <code><a href="#request">REQUEST</a></code>. 
          В случае успеха соответствующий объект сеанса (если он не слишком старый) 
          возвращается (и обновляется). В противном случае возвращается 
          <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Предоставляется метод по умолчанию, и вам нужно только написать свой собственный,
            если вы хотите поддерживать свои собственные сеансы. 
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="session-cookie-value"></a>
          [Generic function]
          <br><b>session-cookie-value</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">session
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">string
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает строку, которую можно использовать для безопасного восстановления 
          сеанса <code><i>session</i></code>, если он уже был установлен. Она используется 
          в качестве значения, хранящегося в cookie сеанса или в соответствующем параметре GET, 
          и проверяется с помощью <code><a href="#session-verify">SESSION-VERIFY</a></code>.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Предоставляется метод по умолчанию, и нет причин менять его, если вы не хотите
            использовать свои собственные объекты сеанса.
          </p>

        </clix:description></blockquote>
<p></p>

    <h4 xmlns=""><a name="cookies">Cookies</a></h4>

      Исходящие cookie хранятся в объекте запроса 
      <code xmlns=""><a href="#reply">REPLY</a></code> (см. 
      <code xmlns=""><a href="#cookie-out">COOKIE-OUT</a></code> и
      <code xmlns=""><a href="#cookies-out*">COOKIES-OUT*</a></code>)). Это объекты CLOS,
      определенные следующим образом: 

      <pre>(defclass cookie ()
  ((name :initarg :name
         :reader <a class="noborder" name="cookie-name">cookie-name</a>
         :type string
         :documentation "The name of the cookie - a string.")
   (value :initarg :value
          :accessor <a class="noborder" name="cookie-value">cookie-value</a>
          :initform ""
          :documentation "The value of the cookie. Will be URL-encoded when sent to the browser.")
   (expires :initarg :expires
            :initform nil
            :accessor <a class="noborder" name="cookie-expires">cookie-expires</a>
            :documentation "The time (a universal time) when the cookie expires (or NIL).")
   (max-age :initarg :max-age
            :initform nil
            :accessor <a class="noborder" name="cookie-max-age">cookie-max-age</a>
            :documentation "The time delta (in seconds) after which the cookie expires (or NIL).")
   (path :initarg :path
         :initform nil
         :accessor <a class="noborder" name="cookie-path">cookie-path</a>
         :documentation "The path this cookie is valid for (or NIL).")
   (domain :initarg :domain
           :initform nil
           :accessor <a class="noborder" name="cookie-domain">cookie-domain</a>
           :documentation "The domain this cookie is valid for (or NIL).")
   (secure :initarg :secure
           :initform nil
           :accessor <a class="noborder" name="cookie-secure">cookie-secure</a>
           :documentation "A generalized boolean denoting whether this is a secure cookie.")
   (http-only :initarg :http-only
              :initform nil
              :accessor <a class="noborder" name="cookie-http-only">cookie-http-only</a>
              :documentation "A generalized boolean denoting whether this is a <a href="http://msdn2.microsoft.com/en-us/library/ms533046.aspx">HttpOnly</a> cookie.")))
      </pre>

      Считыватель(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_r.htm#reader">reader</a>) 
      <code xmlns=""><a href="#cookie-name">COOKIE-NAME</a></code> и медоты доступа(ацессоры)
      <code xmlns=""><a href="#cookie-value">COOKIE-VALUE</a></code>, 
      <code xmlns=""><a href="#cookie-expires">COOKIE-EXPIRES</a></code>, 
      <code xmlns=""><a href="#cookie-max-age">COOKIE-MAX-AGE</a></code>,
      <code xmlns=""><a href="#cookie-path">COOKIE-PATH</a></code>, 
      <code xmlns=""><a href="#cookie-domain">COOKIE-DOMAIN</a></code>, 
      <code xmlns=""><a href="#cookie-secure">COOKIE-SECURE</a></code> и 
      <code xmlns=""><a href="#cookie-http-only">COOKIE-HTTP-ONLY</a></code> экспортируются 
      из пакета <code>HUNCHENTOOT</code>. На данный момент само имя класса не экспортируется. 

      <p xmlns=""><a class="none" name="set-cookie"></a>
          [Function]
          <br><b>set-cookie</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          name <tt>&amp;key</tt> value expires path
          domain secure http-only reply
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">cookie</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Создает объект <code xmlns="http://www.w3.org/1999/xhtml">COOKIE</code> 
          из параметров, предоставленных этой функции, и добавляет их в исходящие
          cookie объекта <code><i>ответа</i></code> 
          <a xmlns="http://www.w3.org/1999/xhtml" href="#replies"><code>REPLY</code> </a>. 
          Если cookie с таким именем (с учетом регистра) уже существует, он заменяется. 
          По умолчанию <code><i>ответ</i></code> - <code><a href="#*reply*">*REPLY*</a></code>.
           <code><i>Значение</i></code> по умолчанию - пустая строка. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="set-cookie*"></a>
          [Function]
          <br><b>set-cookie*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">cookie <tt>&amp;optional</tt> reply</clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">cookie</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Добавляет  <code><i>cookie</i></code> объект 
          <code xmlns="http://www.w3.org/1999/xhtml">COOKIE</code> к исходящим cookie 
          объекта  <code><i>ответа/reply</i></code> 
          <a xmlns="http://www.w3.org/1999/xhtml" href="#replies"><code>REPLY</code>. 
          Если cookie с таким именем (с учетом регистра) уже существует, он заменяется. 
          По умолчанию <code><i>ответ/reply</i></code> - 
          <code><a href="#*reply*">*REPLY*</a></code>.
        </clix:description></blockquote>
<p></p>

    <h4 xmlns=""><a name="logging">>Logging(Протоколирование)</a></h4>
      Hunchentoot может регистрировать доступы и диагностические сообщения к 
      двум отдельным адресатам, которые могут быть либо файлами в файловой системе, 
      либо потоками. Ведение журнала(протоколирование) также можно отключить, установив 
      для слотов 
      <clix:code xmlns:clix="http://bknr.net/clixdoc">ACCESS-LOG-DESTINATION</clix:code> и
      <clix:code xmlns:clix="http://bknr.net/clixdoc">MESSAGE-LOG-DESTINATION</clix:code> в
      <code xmlns=""><a href="#acceptor">ACCEPTOR</a></code> значение <code>NIL</code>. 
      Два слота могут быть инициализированы путем предоставления аргументов инициализации
      :ACCESS-LOG-DESTINATION и :MESSAGE-LOG-DESTINATION при создании акцептора или заданы 
      путем установки слотов через его  аксессоры
      <code xmlns=""><a href="#acceptor-message-log-destination">ACCEPTOR-MESSAGE-LOG-DESTINATION</a></code> и
      <code xmlns=""><a href="#acceptor-access-log-destination">ACCEPTOR-ACCESS-LOG-DESTINATION</a></code>.

<p>
        Когда путь для сообщения или журнала приема задан как переменная, 
        содержащая выходной поток, hunchentoots записывает соответствующие записи журнала 
        в этот поток. По умолчанию Hunchentoot записывает журнал в *STANDARD-ERROR*. 
      </p>

<p>
        Протоколирование доступа осуществляется в формате, аналогичном тому, который 
        может записывать веб-сервер Apache, поэтому возможен анализ файла журнала с 
        использованием стандартных инструментов. Ошибки при обработке запроса записываются 
        в отдельный файл.
      </p>

<p>
        Стандартный механизм протоколирования намеренно прост и медленен. Файлы журнала 
        открываются для каждой записи журнала и снова закрываются после записи, а доступ 
        к ним защищен глобальной блокировкой. Производные классы-акцепторы могут 
        реализовывать методы для обобщенных функций 
        <code xmlns=""><a href="#acceptor-log-message">ACCEPTOR-LOG-MESSAGE</a></code> и
        <code xmlns=""><a href="#acceptor-log-access">ACCEPTOR-LOG-ACCESS</a></code>, чтобы 
        вести журнал по-разному (например, на центральный сервер журналирования или в 
        другом формате файла.
      </p>

<p>
        Ошибки, происходящие в обработчике(<a href="#request-dispatch">handler</a>), 
        которые не были обнаружены самим обработчиком, обрабатываются Hunchentoot путем 
        их записи в установленный <code xmlns=""><a href="#acceptor-message-log-destination">ACCEPTOR-MESSAGE-LOG-DESTINATION</a></code>.
      </p>

      <p xmlns=""><a class="none" name="log-message*"></a>
          [Function]
          <br><b>log-message*</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">log-level format-string
        <tt>&amp;rest
        </tt> format-arguments
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Удобная функция, которая вызывает регистратор сообщений текущего акцептора(acceptor)
          (если он есть) с теми же аргументами, которые он принимает. Возвращает 
          <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>, если регистратора сообщений 
          нет или чего-то еще, что возвращает регистратор сообщений.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Это функция, которую сам Hunchentoot использует для регистрации ошибок,
            обнаруживаемых во время обработки запроса. 
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*log-lisp-errors-p*"></a>
      [Special variable]
      <br><b>*log-lisp-errors-p*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Должны ли регистрироваться ошибки Lisp в обработчиках запросов. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*log-lisp-backtraces-p*"></a>
      [Special variable]
      <br><b>*log-lisp-backtraces-p*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Следует ли регистрировать обратную трассировку Lisp. Имеет эффект, только если 
          <code><a href="#*log-lisp-errors-p*">*LOG-LISP-ERRORS-P*</a></code> также истинно. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*log-lisp-warnings-p*"></a>
      [Special variable]
      <br><b>*log-lisp-warnings-p*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Должны ли регистрироваться предупреждения Lisp в обработчиках запросов. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*lisp-errors-log-level*"></a>
      [Special variable]
      <br><b>*lisp-errors-log-level*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Уровень регистрации ошибок Лиспа. Должен быть одним из:
          <code xmlns="http://www.w3.org/1999/xhtml">:ERROR</code> (по умолчанию), 
          <code xmlns="http://www.w3.org/1999/xhtml">:WARNING</code>,
          или <code xmlns="http://www.w3.org/1999/xhtml">:INFO</code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*lisp-warnings-log-level*"></a>
      [Special variable]
      <br><b>*lisp-warnings-log-level*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Уровень журнала для предупреждений Lisp. Должен быть одним из:
          <code xmlns="http://www.w3.org/1999/xhtml">:ERROR</code>,
          <code xmlns="http://www.w3.org/1999/xhtml">:WARNING</code> (по умолчанию) или
          <code xmlns="http://www.w3.org/1999/xhtml">:INFO</code>.
        </clix:description></blockquote>
<p></p>

    <h4 xmlns=""><a name="conditions">Условия и обработка ошибок</a></h4>

<p>
        В этом разделе описывается, как Hunchentoot справляется с исключительными ситуациями. 
        См. Также раздел о <a href="#logging">протоколировании</a>.
      </p>

<p>
        Когда при обработке запроса возникает ошибка, по умолчанию Hunchentoot 
        перехватывает ошибку, регистрирует ее и, при необходимости, отображает 
        ее клиенту в HTML-ответе. Это поведение можно настроить с помощью значений 
        ряда специальных переменных, которые описаны ниже. 
      </p>

      <p xmlns=""><a class="none" name="*catch-errors-p*"></a>
      [Special variable]
      <br><b>*catch-errors-p*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Если значение этой переменной равно 
          <code xmlns="http://www.w3.org/1999/xhtml">NIL</code> (по умолчанию оно
          <code xmlns="http://www.w3.org/1999/xhtml">T</code>), то ошибки, возникающие во 
          время обработки запроса, не перехватываются, 
          <a xmlns="http://www.w3.org/1999/xhtml" href="#logging">как обычно</a>, а вместо 
          этого вызывается(<a xmlns="http://www.w3.org/1999/xhtml" href="http://www.lispworks.com/documentation/HyperSpec/Body/f_invoke.htm">invoked</a>)
          <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_d.htm#debugger">debugger</a>
          (отладчик) вашего Lisp. Очевидно, что в производственной среде для этой переменной
          всегда должно быть установлено 
          <em xmlns="http://www.w3.org/1999/xhtml">true</em>(истинное) значение. См. 
          <code><a href="#maybe-invoke-debugger">MAYBE-INVOKE-DEBUGGER</a></code>, если вы 
          хотите настроить это поведение. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*show-lisp-errors-p*"></a>
      [Special variable]
      <br><b>*show-lisp-errors-p*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Следует ли отображать ошибки Lisp в выводе HTML. Обратите внимание, что 
          это влияет только на стандартные ответы, сгенерированные Lisp. Если для 
          кода состояния "internal server error"(внутренняя ошибка сервера) присутствует
          шаблон ошибки, эта специальная переменная не используется (см.  
          <code><a href="#acceptor-status-message">acceptor-status-message</a></code>).
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*show-lisp-backtraces-p*"></a>
      [Special variable]
      <br><b>*show-lisp-backtraces-p*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Следует ли отображать обратную трассировку Lisp в выводе HTML, если 
          <code><a href="#*show-lisp-errors-p*">*SHOW-LISP-ERRORS-P*</a></code> истинно и 
          возникает ошибка. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="maybe-invoke-debugger"></a>
          [Generic function]
          <br><b>maybe-invoke-debugger</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">condition
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">|
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Эта обобщенная функция вызывается всякий раз, когда в Hunchentoot сигнализируется 
          <i>условие</i></code> <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.lispworks.com/documentation/HyperSpec/Body/09_.htm">condition</a> 
          Возможно, вы захотите специализировать её на определенных классах условий для 
          целей отладки. Метод по умолчанию <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.lispworks.com/documentation/HyperSpec/Body/f_invoke.htm">вызывает отладчик</a> 
          с условием(<code><i>condition</i></code>), если
          <code><a href="#*catch-errors-p*">*CATCH-ERRORS-P*</a></code> равно 
          <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="hunchentoot-condition"></a>
      [Condition type]
      <br><b>hunchentoot-condition</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Суперкласс для всех условий, связанных с Hunchentoot.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="hunchentoot-error"></a>
      [Condition type]
      <br><b>hunchentoot-error</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Суперкласс для всех ошибок, связанных с Hunchentoot и подклассом 
          <code><a href="#hunchentoot-condition">HUNCHENTOOT-CONDITION</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="parameter-error"></a>
      [Condition type]
      <br><b>parameter-error</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Сообщает(сигнализирует), если функция была вызвана с несогласованными или 
          недопустимыми параметрами. Подкласс
          <code><a href="#hunchentoot-error">HUNCHENTOOT-ERROR</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="hunchentoot-warning"></a>
      [Condition type]
      <br><b>hunchentoot-warning</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Суперкласс для всех предупреждений, связанных с Hunchentoot и подклассом 
          <code><a href="#hunchentoot-condition">HUNCHENTOOT-CONDITION</a></code>.
        </clix:description></blockquote>
<p></p>

    <h4 xmlns=""><a name="misc">Разное</a></h4>

      Различные функции и переменные, не попавшие ни в одну из других категорий. 

      <p xmlns=""><a class="none" name="abort-request-handler"></a>
          [Function]
          <br><b>abort-request-handler</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> result
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Эта функция может быть вызвана обработчиком запроса в любое время, 
          чтобы немедленно прервать обработку запроса. Это работает так, как если бы 
          обработчик вернул <code><i>result</i></code>. См. Исходный код 
          <code><a href="#redirect">REDIRECT</a></code> для примера. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="handle-if-modified-since"></a>
          [Function]
          <br><b>handle-if-modified-since</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">time <tt>&amp;optional</tt> request</clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">|</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Эта функция предназначена для использования внутри 
          <a xmlns="http://www.w3.org/1999/xhtml" href="#request-dispatch">handler</a>
          (обработчика). Если клиент отправил заголовок 'If-Modified-Since' (см. 
          <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.faqs.org/rfcs/rfc2616.html">RFC&nbsp;2616</a>, раздел 14.25) 
          и указанное время - <code><i>time</i></code> соответствует всемирному времени, 
          то заголовок <code><a href="#+http-not-modified+">+HTTP-NOT-MODIFIED+</a></code> 
          без содержимого немедленно возвращается клиенту.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Обратите внимание, что для того, чтобы эта функция была полезной, вы обычно 
            должны отправлять заголовки 'Last-Modified' обратно клиенту. См. Пример кода 
            <code xmlns=""><a href="#create-static-file-dispatcher-and-handler">CREATE-STATIC-FILE-DISPATCHER-AND-HANDLER</a></code>.
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="handle-static-file"></a>
          [Function]
          <br><b>handle-static-file</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">path <tt>&amp;optional</tt> content-type</clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">nil</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Отправляет клиенту файл, обозначенный указателем пути <code><i>path</i></code>
          с типом содержимого <code><i>content-type</i></code>. Устанавливает необходимые
          обработчики. В частности, функция использует 
          <code><a href="#handle-if-modified-since">HANDLE-IF-MODIFIED-SINCE</a></code>.
          <p xmlns="http://www.w3.org/1999/xhtml">
              Если <code xmlns=""><i>content-type</i></code> равен <code>NIL</code>, 
              функция пытается определить правильный тип содержимого по суффиксу файла или 
              в крайнем случае возвращается к <code>"application/octet-stream"</code>.
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
             Обратите внимание, что эта функция вызывает 
             <code xmlns=""><a href="#send-headers">SEND-HEADERS</a></code> изнутри, поэтому 
             после того, как вы ее вызвали, заголовки отправляются, а возвращаемое значение 
             вашего обработчика игнорируется. 
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="redirect"></a>
          [Function]
          <br><b>redirect</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">target <tt>&amp;key</tt> host port protocol add-session-id code</clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">|</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Отправляет соответствующие заголовки для перенаправления клиента на 
          <code><i>target</i></code>(цель) (строку).
          <p xmlns="http://www.w3.org/1999/xhtml">
            Если <code xmlns=""><i>target</i></code>(цель) - это полный URL-адрес, 
            начинающийся со схемы, <code xmlns=""><i>host</i></code>, 
            <code xmlns=""><i>port</i></code> и <code xmlns=""><i>protocol</i></code>
            игнорируются. В противном случае <code xmlns=""><i>target</i></code> должна
            обозначать часть пути URL-адреса, <code xmlns=""><i>protocol</i></code> должен 
            быть одним из ключевых слов <code>:HTTP</code> или <code>:HTTPS</code>, а 
            URL-адрес для перенаправления будет состоять из  <code xmlns=""><i>host</i></code>,
            <code xmlns=""><i>port</i></code>, <code xmlns=""><i>protocol</i></code>,
            и <code xmlns=""><i>target</i></code>.
          </p>

          <p xmlns="http://www.w3.org/1999/xhtml">
            <code xmlns=""><i>code</i></code> должен быть кодом статуса перенаправления 
            HTTP 3xx для отправки клиенту. По умолчанию 302 («Найдено»). Если 
            <code xmlns=""><i>host</i></code>(хост) не указан, будет использоваться текущий 
            хост (см. <code xmlns=""><a href="#host">HOST</a></code>). Если 
            <code xmlns=""><i>protocol</i></code> является ключевым словом 
            <code>:HTTPS</code>, клиент будет перенаправлен на URL-адрес https, если это
            <code>:HTTP</code>, он будет отправлен на URL-адрес http. Если и 
            <code xmlns=""><i>host</i></code>, и <code xmlns=""><i>protocol</i></code> 
            не указаны, значение протокола будет соответствовать текущему запросу. 
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="require-authorization"></a>
          [Function]
          <br><b>require-authorization</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc"><tt>&amp;optional</tt> realm</clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">|</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Отправляет соответствующие заголовки с требованием базовой HTTP-аутентификации 
          (см. <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.faqs.org/rfcs/rfc2617.html">RFC&nbsp;2617</a>) для области <code><i>realm</i></code>. 
          Значение по умолчанию для <code><i>realm</i></code>(области) это
          <code xmlns="http://www.w3.org/1999/xhtml">"Hunchentoot"</code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="no-cache"></a>
          [Function]
          <br><b>no-cache</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">|
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Добавляет соответствующие заголовки, чтобы полностью предотвратить кеширование 
          в большинстве браузеров.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="ssl-p"></a>
          [Function]
          <br><b>ssl-p</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> acceptor
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">generalized-boolean
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Безопасно ли текущее соединение с клиентом. См. 
          <code><a href="#acceptor-ssl-p">ACCEPTOR-SSL-P</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="reason-phrase"></a>
          [Function]
          <br><b>reason-phrase</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">return-code
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">string
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает фразу причины для кода возврата HTTP <code><i>return-code</i></code>
         (который должен быть целым числом) или 
         <code xmlns="http://www.w3.org/1999/xhtml">NIL</code> для кодов возврата, 
         которые Hunchentoot не знает. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="rfc-1123-date"></a>
          [Function]
          <br><b>rfc-1123-date</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
          <tt>&amp;optional
          </tt> time
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">string
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Создает строку времени в соответствии с  <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.faqs.org/rfcs/rfc1123.html">RFC 1123</a>. 
          По умолчанию текущее время. Это можно использовать для отправки заголовка 
          'Last-Modified' - см. <code><a href="#handle-if-modified-since">HANDLE-IF-MODIFIED-SINCE</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="url-encode"></a>
          [Function]
          <br><b>url-encode</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">string
        <tt>&amp;optional
        </tt> external-format
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">string
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          кодирует URL-строку, используя внешний формат <code><i>external-format</i></code>. 
          По умолчанию для внешнего формата используется значение <code><a href="#*hunchentoot-default-external-format*">*HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="url-decode"></a>
          [Function]
          <br><b>url-decode</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">string
        <tt>&amp;optional
        </tt> external-format
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">string
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Декодирует  кодированную URL строку, которая, как предполагается, закодирована с
          использованием внешнего формата <code><i>external-format</i></code>, то есть это 
          обратное к <code><a href="#url-encode">URL-ENCODE</a></code>. Предполагается, 
          что эта функция вам понадобится редко, если вообще когда-либо. Но на всякий случай -
          вот она. По умолчанию для <code><i>external-format</i></code> используется значение
          <code><a href="#*hunchentoot-default-external-format*">*HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*</a></code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="escape-for-html"></a>
          [Function]
          <br><b>escape-for-html</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">string
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Экранирует символы #\&lt;, #\&gt;, #\', #\" и #\&amp; для вывода HTML.  
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="http-token-p"></a>
          [Function]
          <br><b>http-token-p</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">object</clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">generalized-boolean</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Эта функция проверяет, является ли  <code><i>object</i></code> непустой строкой, 
          которая является <em xmlns="http://www.w3.org/1999/xhtml">token</em>(токеном) в
          соответствии с <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.faqs.org/rfcs/rfc2068.html">RFC 2068</a> (т.е. может ли он использоваться, например, для имен файлов cookie). 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="mime-type"></a>
          [Function]
          <br><b>mime-type</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">pathspec
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">result
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          По заданному указателю имени пути <code><i>pathspec</i></code> возвращает 
          <a xmlns="http://www.w3.org/1999/xhtml" href="http://en.wikipedia.org/wiki/Internet_media_type">MIME type</a> (в виде строки), соответствующий суффиксу файла, обозначенному 
          <code><i>pathspec</i></code> (или <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>).
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="within-request-p"></a>
          [Function]
          <br><b>within-request-p</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">
        </clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">generalized-boolean
        </clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Возвращает истину, если вызывается в контексте запроса. В противном случае - 
          <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*tmp-directory*"></a>
      [Special variable]
      <br><b>*tmp-directory*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Это должен быть путь, обозначающий каталог, в котором могут храниться 
          временные файлы. 
          Он используется для <a xmlns="http://www.w3.org/1999/xhtml" href="#upload">загрузки
          файлов</a>.
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*header-stream*"></a>
      [Special variable]
      <br><b>*header-stream*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Если эта переменная не равна <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>, 
          она должна быть привязана к потоку, в который будут записываться входящие и исходящие
          заголовки для целей отладки. 
        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*cleanup-function*"></a>
      [Special variable]
      <br><b>*cleanup-function*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Обозначение функции без аргументов, которая вызывается регулярно, если 
          <code><a href="#*cleanup-interval*">*CLEANUP-INTERVAL*</a></code> не равно 
          <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>. Начальное значение - 
          это имя функции, которая вызывает сборку мусора в 32-битных версиях LispWorks.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Эта переменная доступна только в LispWorks. 
          </p>

        </clix:description></blockquote>
<p></p>

      <p xmlns=""><a class="none" name="*cleanup-interval*"></a>
      [Special variable]
      <br><b>*cleanup-interval*</b></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
          Должен быть <code xmlns="http://www.w3.org/1999/xhtml">NIL</code> или положительное 
          целое число. Система вызывает <code><a href="#*cleanup-function*">*CLEANUP-FUNCTION*</a></code> всякий раз, когда <code><a href="#*cleanup-interval*">*CLEANUP-INTERVAL*</a></code>
          были созданы новые рабочие потоки (подсчитываемые глобально для всех приемников), 
          если значение не равно code <code xmlns="http://www.w3.org/1999/xhtml">NIL</code>.
          Начальное значение - 100.
          <p xmlns="http://www.w3.org/1999/xhtml">
            Эта переменная доступна только в LispWorks. 
          </p>

        </clix:description></blockquote>
<p></p>

  <h3 xmlns=""><a class="none" name="testing">Тестирование</a></h3>
    Hunchentoot поставляется с тестовым скриптом, который проверяет, отвечает ли пример 
    веб-сервера ожидаемым образом. Этот тестовый сценарий использует HTTP клиентскую библиотеку 
    Drakma  и, таким образом, разделяет значительную часть своего базового кода с самим
    Hunchentoot. Тем не менее, запуск тестового сценария является полезным тестом на 
    достоверность, и также можно запустить сценарий на разных машинах, чтобы проверить 
    новый порт Hunchentoot (или, если на то пошло, Drakma).

<p>
      Чтобы запустить проверку достоверности, <a href="#teen-age">запустите пример веб-сервера</a>.
      Затем в вашем слушателе Lisp введите 
</p>

<pre>(<a class="noborder" href="hunchentoot-test:test-hunchentoot">hunchentoot-test:test-hunchentoot</a> "http://localhost:4242")</pre>
Вы увидите некоторые диагностические данные и итоговую строку, в которой сообщается, 
не удалось ли выполнить какие-либо тесты. (Вы также можете использовать примеры файлов 
сертификатов и ключей в тестовом каталоге и вместо этого запустить и протестировать 
https-сервер.) 

<p></p>

    <p xmlns=""><a class="none" name="hunchentoot-test:test-hunchentoot"></a>
          [Function]
          <br><b>hunchentoot-test:test-hunchentoot</b> <i><clix:lambda-list xmlns:clix="http://bknr.net/clixdoc">base-url <tt>&amp;key</tt></clix:lambda-list></i>
            =&gt;
            <i><clix:returns xmlns:clix="http://bknr.net/clixdoc">|</clix:returns></i></p>

<blockquote><clix:description xmlns:clix="http://bknr.net/clixdoc">
        Запускает встроенный тест уверенности. <code><i>base-url</i></code> - это базовый URL,
        используемый для тестирования, он не должен иметь косой черты в конце. Допустимые
        аргументы ключевые слова предназначены для будущего расширения и в настоящее время 
        не должны использоваться.
        <p xmlns="http://www.w3.org/1999/xhtml">
          Сценарий ожидает, что тестовый сервер Hunchentoot будет запущен с заданным 
          <code xmlns=""><i>base-url</i></code>, и получит различные страницы с этого сервера,
          ожидая определенных ответов. 
        </p>

      </clix:description></blockquote>
<p></p>

  <h3 xmlns=""><a class="none" name="debugging">Отладка</a></h3>
    По умолчанию Hunchentoot перехватывает все ошибки, возникающие при 
	выполнении обработчиков запросов, записывает их в файл журнала и отображает 
	статическую страницу ошибок для пользователя. При разработке приложений вы 
	можете изменить это поведение, чтобы отладчик запускался при возникновении ошибки. 
	Вы можете установить для <code xmlns=""><a href="#*catch-errors-p*">*CATCH-ERRORS-P*</a></code> значение <code>NIL</code>, чтобы это произошло. В качестве альтернативы вы можете 
	захотеть, чтобы Hunchentoot отображал подробную информацию об ошибке на 
	странице ответа на ошибку. Вы можете установить для 
	<code xmlns=""><a href="#*show-lisp-errors-p*">*SHOW-LISP-ERRORS-P*</a></code>
	истинное значение, чтобы это произошло. Если вы не хотите видеть трассировку
	вызовов Lisp на этих страницах ошибок, вы можете установить 
	 <code xmlns=""><a href="#*show-lisp-backtraces-p*">*SHOW-LISP-BACKTRACES-P*</a></code>
	в <code>NIL</code>.

  <h3 xmlns=""><a class="none" name="history">История</a></h3>

    Предшественник Hunchentoot TBNL (сокращенно от «To Be Named Later») 
	вырос с годами как инструментарий, который я использовал для различных 
	коммерческих и частных проектов. В августе 2003 года Дэниел Барлоу начал 
	обзор <a href="http://article.gmane.org/gmane.lisp.web/148">review of
      web APIs</a> в списке рассылки <a href="http://www.red-bean.com/lispweb/">lispweb</a>,
	и я <a href="http://article.gmane.org/gmane.lisp.web/153">описал</a> API 
	моей до сих пор не выпущенной группы кода (и назвал ее «TBNL»).

<p>
      Оказалось, что <a href="http://www.jeffcaldwell.com/">Джефф Колдуэлл</a> работал 
	над чем-то подобным, поэтому он написал мне по электронной почте и предложил 
	присоединиться к нашим усилиям. Поскольку в ближайшее время у меня не было 
	планов выпускать свой код (который был плохо организован, недокументирован 
	и в основном специфичен для CMUCL), я передал его Джеффу, и он работал над 
	выпуском. Он добавил строки документации, отредактировал, добавил кое-что и 
	основал его на KMRCL, чтобы сделать его переносимым между несколькими 
	реализациями Lisp. 
    </p>

<p>
      К сожалению, Джефф, по крайней мере, так же занят, как и я, поэтому 
	у него не было времени закончить полную версию. Но весной 2004 года 
	мне понадобилась документированная версия кода для моего клиента, 
	который подумал, что было бы хорошо, если бы этот инструментарий был 
	общедоступным под лицензией с открытым исходным кодом. Поэтому я взял 
	код Джеффа, снова отредактировал (для синхронизации с изменениями, 
	которые я сделал за это время) и добавил документацию. В результате 
	появился TBNL 0.1.0 (который изначально требовал mod_lisp в качестве интерфейса).
    </p>

<p>
      В марте 2005 года Боб Хатчинсон разослал патчи, которые позволили TBNL 
	использовать другие внешние интерфейсы, кроме mod_lisp. Это заставило 
	меня понять, что TBNL уже был почти полноценным веб-сервером, поэтому 
	в конце концов я написал Hunchentoot, который был полноценным веб-сервером, 
	реализованным как оболочка вокруг TBNL. Hunchentoot 0.1.0 был выпущен в 
	конце 2005 года и изначально предназначался только для LispWorks. 
    </p>

<p>
      Hunchentoot 0.4.0, выпущенный в октябре 2006 года, был первым выпуском, 
	который также работал с другими реализациями Common Lisp. Это серьезная 
	переработка, которая также включает большую часть TBNL и полностью 
	заменяет ее.
    </p>

<p>
      Hunchentoot 1.0.0, выпущенный в феврале 2009 года, снова представляет собой 
	серьезную переработку, и ее следует считать незавершенной. Он перешел на 
	использование библиотек <a href="http://common-lisp.net/project/usocket/">usocket</a>
	и <a href="http://common-lisp.net/project/bordeaux-threads/">Bordeaux
      Threads</a> для не-LispWorks Lisps, тем самым удалив большую часть кода, 
	зависящего от платформы. Поведение многопоточности стало управляемым благодаря 
	появлению мастеров задач(taskmasters). Поддержка mod_lisp и некоторые другие 
	вещи были удалены в этом выпуске, чтобы упростить кодовую базу (отчасти из-за 
	отсутствия интереса). Несколько архитектурных изменений (многие из них не имеют 
	обратной совместимости) были внесены, чтобы упростить настройку поведения 
	Hunchentoot. Значительную часть редизайна 1.0.0 выполнил 
	<a href="http://netzhansa.blogspot.com/">Ханс Хюбнер</a>. 
    </p>

  <h3 xmlns=""><a class="none" name="index">Индекс Символов</a></h3>

    Вот все экспортированные символы пакета <code>HUNCHENTOOT</code> 
	в алфавитном порядке, связанные с соответствующими записями 
	в документации: 

    <ul xmlns="">
<li>
<code><a href="#*acceptor*">*acceptor*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*catch-errors-p*">*catch-errors-p*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*cleanup-function*">*cleanup-function*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*cleanup-interval*">*cleanup-interval*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*content-types-for-url-rewrite*">*content-types-for-url-rewrite*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*default-connection-timeout*">*default-connection-timeout*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*default-content-type*">*default-content-type*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*dispatch-table*">*dispatch-table*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*file-upload-hook*">*file-upload-hook*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*header-stream*">*header-stream*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*hunchentoot-default-external-format*">*hunchentoot-default-external-format*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*lisp-errors-log-level*">*lisp-errors-log-level*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*lisp-warnings-log-level*">*lisp-warnings-log-level*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*log-lisp-backtraces-p*">*log-lisp-backtraces-p*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*log-lisp-errors-p*">*log-lisp-errors-p*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*log-lisp-warnings-p*">*log-lisp-warnings-p*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*methods-for-post-parameters*">*methods-for-post-parameters*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*reply*">*reply*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*request*">*request*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*rewrite-for-session-urls*">*rewrite-for-session-urls*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*session*">*session*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*session-gc-frequency*">*session-gc-frequency*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*session-max-time*">*session-max-time*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*session-secret*">*session-secret*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*show-lisp-backtraces-p*">*show-lisp-backtraces-p*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*show-lisp-errors-p*">*show-lisp-errors-p*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*tmp-directory*">*tmp-directory*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*use-remote-addr-for-sessions*">*use-remote-addr-for-sessions*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#*use-user-agent-for-sessions*">*use-user-agent-for-sessions*</a></code><span class="entry-type">Special variable</span>
</li>
<li>
<code><a href="#+http-accepted+">+http-accepted+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-authorization-required+">+http-authorization-required+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-bad-gateway+">+http-bad-gateway+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-bad-request+">+http-bad-request+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-conflict+">+http-conflict+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-continue+">+http-continue+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-created+">+http-created+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-expectation-failed+">+http-expectation-failed+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-failed-dependency+">+http-failed-dependency+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-forbidden+">+http-forbidden+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-gateway-time-out+">+http-gateway-time-out+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-gone+">+http-gone+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-internal-server-error+">+http-internal-server-error+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-length-required+">+http-length-required+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-method-not-allowed+">+http-method-not-allowed+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-moved-permanently+">+http-moved-permanently+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-moved-temporarily+">+http-moved-temporarily+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-multi-status+">+http-multi-status+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-multiple-choices+">+http-multiple-choices+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-no-content+">+http-no-content+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-non-authoritative-information+">+http-non-authoritative-information+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-not-acceptable+">+http-not-acceptable+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-not-found+">+http-not-found+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-not-implemented+">+http-not-implemented+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-not-modified+">+http-not-modified+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-ok+">+http-ok+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-partial-content+">+http-partial-content+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-payment-required+">+http-payment-required+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-precondition-failed+">+http-precondition-failed+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-proxy-authentication-required+">+http-proxy-authentication-required+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-request-entity-too-large+">+http-request-entity-too-large+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-request-time-out+">+http-request-time-out+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-request-uri-too-large+">+http-request-uri-too-large+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-requested-range-not-satisfiable+">+http-requested-range-not-satisfiable+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-reset-content+">+http-reset-content+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-see-other+">+http-see-other+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-service-unavailable+">+http-service-unavailable+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-switching-protocols+">+http-switching-protocols+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-temporary-redirect+">+http-temporary-redirect+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-unsupported-media-type+">+http-unsupported-media-type+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-use-proxy+">+http-use-proxy+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#+http-version-not-supported+">+http-version-not-supported+</a></code><span class="entry-type">Constant</span>
</li>
<li>
<code><a href="#abort-request-handler">abort-request-handler</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#accept-connections">accept-connections</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#acceptor">acceptor</a></code><span class="entry-type">Standard class</span>
</li>
<li>
<code><a href="#acceptor-access-log-destination">acceptor-access-log-destination</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#acceptor-address">acceptor-address</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#acceptor-dispatch-request">acceptor-dispatch-request</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#acceptor-document-root">acceptor-document-root</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#acceptor-error-template-directory">acceptor-error-template-directory</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#acceptor-input-chunking-p">acceptor-input-chunking-p</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#acceptor-listen-backlog">acceptor-listen-backlog</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#acceptor-log-access">acceptor-log-access</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#acceptor-log-message">acceptor-log-message</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#acceptor-message-log-destination">acceptor-message-log-destination</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#acceptor-name">acceptor-name</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#acceptor-output-chunking-p">acceptor-output-chunking-p</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#acceptor-persistent-connections-p">acceptor-persistent-connections-p</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#acceptor-port">acceptor-port</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#acceptor-read-timeout">acceptor-read-timeout</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#acceptor-remove-session">acceptor-remove-session</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#acceptor-reply-class">acceptor-reply-class</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#acceptor-request-class">acceptor-request-class</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#acceptor-ssl-certificate-file">acceptor-ssl-certificate-file</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#acceptor-ssl-p">acceptor-ssl-p</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#acceptor-ssl-privatekey-file">acceptor-ssl-privatekey-file</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#acceptor-ssl-privatekey-password">acceptor-ssl-privatekey-password</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#acceptor-status-message">acceptor-status-message</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#acceptor-write-timeout">acceptor-write-timeout</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#authorization">authorization</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#aux-request-value">aux-request-value</a></code><span class="entry-type">Accessor</span>
</li>
<li>
<code><a href="#content-length">content-length</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#content-length*">content-length*</a></code><span class="entry-type">Accessor</span>
</li>
<li>
<code><a href="#content-type">content-type</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#content-type*">content-type*</a></code><span class="entry-type">Accessor</span>
</li>
<li>
<code><a href="#cookie-in">cookie-in</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#cookie-out">cookie-out</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#cookies-in">cookies-in</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#cookies-in*">cookies-in*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#cookies-out">cookies-out</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#cookies-out*">cookies-out*</a></code><span class="entry-type">Accessor</span>
</li>
<li>
<code><a href="#create-folder-dispatcher-and-handler">create-folder-dispatcher-and-handler</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#create-prefix-dispatcher">create-prefix-dispatcher</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#create-regex-dispatcher">create-regex-dispatcher</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#create-request-handler-thread">create-request-handler-thread</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#create-static-file-dispatcher-and-handler">create-static-file-dispatcher-and-handler</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#define-easy-handler">define-easy-handler</a></code><span class="entry-type">Macro</span>
</li>
<li>
<code><a href="#delete-aux-request-value">delete-aux-request-value</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#delete-session-value">delete-session-value</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#detach-socket">detach-socket</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#dispatch-easy-handlers">dispatch-easy-handlers</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#easy-acceptor">easy-acceptor</a></code><span class="entry-type">Standard class</span>
</li>
<li>
<code><a href="#easy-ssl-acceptor">easy-ssl-acceptor</a></code><span class="entry-type">Standard class</span>
</li>
<li>
<code><a href="#escape-for-html">escape-for-html</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#execute-acceptor">execute-acceptor</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#get-parameter">get-parameter</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#get-parameters">get-parameters</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#get-parameters*">get-parameters*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#handle-if-modified-since">handle-if-modified-since</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#handle-incoming-connection">handle-incoming-connection</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#handle-request">handle-request</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#handle-static-file">handle-static-file</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#header-in">header-in</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#header-in*">header-in*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#header-out">header-out</a></code><span class="entry-type">Accessor</span>
</li>
<li>
<code><a href="#headers-in">headers-in</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#headers-in*">headers-in*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#headers-out">headers-out</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#headers-out*">headers-out*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#host">host</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#http-token-p">http-token-p</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#hunchentoot-condition">hunchentoot-condition</a></code><span class="entry-type">Condition type</span>
</li>
<li>
<code><a href="#hunchentoot-error">hunchentoot-error</a></code><span class="entry-type">Condition type</span>
</li>
<li>
<code><a href="#hunchentoot-test:test-hunchentoot">hunchentoot-test:test-hunchentoot</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#hunchentoot-warning">hunchentoot-warning</a></code><span class="entry-type">Condition type</span>
</li>
<li>
<code><a href="#initialize-connection-stream">initialize-connection-stream</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#local-addr">local-addr</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#local-addr*">local-addr*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#local-port">local-port</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#local-port*">local-port*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#log-message*">log-message*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#maybe-invoke-debugger">maybe-invoke-debugger</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#mime-type">mime-type</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#multi-threaded-taskmaster">multi-threaded-taskmaster</a></code><span class="entry-type">Standard class</span>
</li>
<li>
<code><a href="#next-session-id">next-session-id</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#no-cache">no-cache</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#one-thread-per-connection-taskmaster">one-thread-per-connection-taskmaster</a></code><span class="entry-type">Standard class</span>
</li>
<li>
<code><a href="#parameter">parameter</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#parameter-error">parameter-error</a></code><span class="entry-type">Condition type</span>
</li>
<li>
<code><a href="#post-parameter">post-parameter</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#post-parameters">post-parameters</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#post-parameters*">post-parameters*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#process-connection">process-connection</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#process-request">process-request</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#query-string">query-string</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#query-string*">query-string*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#raw-post-data">raw-post-data</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#real-remote-addr">real-remote-addr</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#reason-phrase">reason-phrase</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#recompute-request-parameters">recompute-request-parameters</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#redirect">redirect</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#referer">referer</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#regenerate-session-cookie-value">regenerate-session-cookie-value</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#remote-addr">remote-addr</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#remote-addr*">remote-addr*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#remote-port">remote-port</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#remote-port*">remote-port*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#remove-session">remove-session</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#reply">reply</a></code><span class="entry-type">Standard class</span>
</li>
<li>
<code><a href="#reply-external-format">reply-external-format</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#reply-external-format*">reply-external-format*</a></code><span class="entry-type">Accessor</span>
</li>
<li>
<code><a href="#request">request</a></code><span class="entry-type">Standard class</span>
</li>
<li>
<code><a href="#request-acceptor">request-acceptor</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#request-method">request-method</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#request-method*">request-method*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#request-uri">request-uri</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#request-uri*">request-uri*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#require-authorization">require-authorization</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#reset-connection-stream">reset-connection-stream</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#reset-session-secret">reset-session-secret</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#reset-sessions">reset-sessions</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#return-code">return-code</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#return-code*">return-code*</a></code><span class="entry-type">Accessor</span>
</li>
<li>
<code><a href="#rfc-1123-date">rfc-1123-date</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#script-name">script-name</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#script-name*">script-name*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#send-headers">send-headers</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#server-protocol">server-protocol</a></code><span class="entry-type">Generic reader</span>
</li>
<li>
<code><a href="#server-protocol*">server-protocol*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#session">session</a></code><span class="entry-type">Standard class</span>
</li>
<li>
<code><a href="#session-cookie-name">session-cookie-name</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#session-cookie-value">session-cookie-value</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#session-created">session-created</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#session-db">session-db</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#session-db-lock">session-db-lock</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#session-gc">session-gc</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#session-id">session-id</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#session-max-time">session-max-time</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#session-remote-addr">session-remote-addr</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#session-start">session-start</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#session-too-old-p">session-too-old-p</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#session-user-agent">session-user-agent</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#session-value">session-value</a></code><span class="entry-type">Accessor</span>
</li>
<li>
<code><a href="#session-verify">session-verify</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#set-cookie">set-cookie</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#set-cookie*">set-cookie*</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#shutdown">shutdown</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#single-threaded-taskmaster">single-threaded-taskmaster</a></code><span class="entry-type">Standard class</span>
</li>
<li>
<code><a href="#ssl-acceptor">ssl-acceptor</a></code><span class="entry-type">Standard class</span>
</li>
<li>
<code><a href="#ssl-p">ssl-p</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#start">start</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#start-listening">start-listening</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#start-session">start-session</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#start-thread">start-thread</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#stop">stop</a></code><span class="entry-type">Generic function</span>
</li>
<li>
<code><a href="#taskmaster">taskmaster</a></code><span class="entry-type">Standard class</span>
</li>
<li>
<code><a href="#taskmaster-acceptor">taskmaster-acceptor</a></code><span class="entry-type">Generic accessor</span>
</li>
<li>
<code><a href="#url-decode">url-decode</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#url-encode">url-encode</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#user-agent">user-agent</a></code><span class="entry-type">Function</span>
</li>
<li>
<code><a href="#within-request-p">within-request-p</a></code><span class="entry-type">Function</span>
</li>
</ul>

  <h3 xmlns=""><a class="none" name="ack">Благодарности</a></h3>

    Thanks to Jeff Caldwell - TBNL would not have been released
    without his efforts.  Thanks
    to <a href="http://www.cliki.net/Stefan%20Scholl">Stefan
    Scholl</a> and Travis Cross for various additions and fixes to
    TBNL, to <a href="http://www.foldr.org/~michaelw/">Michael
    Weber</a> for initial file upload code, and
    to <a href="http://www.ltn.lv/~jonis/">Janis Dzerins</a> for
    his <a href="http://common-lisp.net/project/rfc2388/">RFC&nbsp;2388
    code</a>. Thanks to Bob Hutchison for his code for multiple
    front-ends (which made me realize that TBNL was already pretty
    close to a "real" web server) and the initial UTF-8 example.
    Thanks to <a href="http://netzhansa.blogspot.com/">Hans HÃ¼bner</a>
    for a lot of architectural and implementation enhancements for the
    1.0.0 release and also for transferring the documentation to sane
    XHTML.  Thanks to John
    Foderaro's <a href="http://opensource.franz.com/aserve/index.html">AllegroServe</a>
    for inspiration.  Thanks to <a href="http://www.htg1.de/">Uwe von
    Loh</a> for
    the <a href="http://www.htg1.de/hunchentoot/hunchentoot.html">Hunchentoot
    logo</a>.

<p>
      Hunchentoot originally used code
      from <a href="http://www.cliki.net/ACL-COMPAT">ACL-COMPAT</a>,
      specifically the chunking code from Jochen Schmidt.  (This has been
      replaced by <a href="http://weitz.de/chunga/">Chunga</a>.)  When I ported
      Hunchentoot to other Lisps than LispWorks, I stole code from
      ACL-COMPAT, <a href="http://www.cliki.net/kmrcl">KMRCL</a>,
      and <a href="http://www.cliki.net/trivial-sockets">trivial-sockets</a> for
      implementation-dependent stuff like sockets and MP.  (This has been replaced by
      <a href="http://common-lisp.net/project/bordeaux-threads/">Bordeaux
      Threads</a>
      and <a href="http://common-lisp.net/project/usocket/">usocket</a>.)
    </p>

<p>
      Parts of this documentation were prepared
      with <a href="http://weitz.de/documentation-template/">DOCUMENTATION-TEMPLATE</a>,
      no animals were harmed.
    </p>

<p>
    <a href="http://weitz.de/index.html">BACK TO MY HOMEPAGE
    </a>
  </p>

</body></html>
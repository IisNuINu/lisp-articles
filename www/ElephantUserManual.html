<html lang="en"><head>
<title>Elephant Руководство пользователя </title>
<meta http-equiv="Content-Type" content="text/html; charset=utf8">
<meta name="description" content="Elephant User Manual">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--

     Elephant System
     Original Version, Copyright (C) 2004 Ben Lee and Andrew Blumberg.
     Version 0.5, Copyright (C) 2006 Robert L. Read.
     Versions 0.6-1.0, Copyright (C) 2006-2009 Ian Eslick and Robert L.
     Read.
     Portions copyright respective contributors (see `CREDITS').
     Elephant Manual
     Original Version, Copyright (C) 2004 Ben Lee.
     Versions 0.5-0.6, Copyright (C) 2006 Robert L. Read.
     Version 1.0, Copyright (C) 2006-2007 Ian Eslick, Glenn Tarcea and
     Robert L. Read
     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License.
     See the Copyright and License chapter for details about copyright,
     license and warranty for this manual and the Elephant system.

   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<h1 class="settitle">Elephant Руководство пользователя </h1>
<div class="node">

<p></p>

<hr>
<a name="Top"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Table-of-Contents">Содержание</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="unnumbered">Copyright</h2>

<blockquote>
Elephant System <br>
Original Version, Copyright © 2004 Ben Lee and Andrew Blumberg. <br>
Version 0.5, Copyright © 2006 Robert L. Read. <br>
Versions 0.6-1.0, Copyright © 2006-2009 Ian Eslick and Robert L. Read. <br>
Portions copyright respective contributors (see <samp><span class="file">CREDITS</span></samp>). <br>

<p>Elephant Руководство <br>
Original Version, Copyright © 2004 Ben Lee. <br>
Versions 0.5-0.6, Copyright © 2006 Robert L. Read. <br>
Version 1.0, Copyright © 2006-2007 Ian Eslick, Glenn Tarcea and Robert L. Read <br>

        </p>

<p>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License.  See the
Copyright and License chapter for details about copyright, license and
warranty for this manual and the Elephant system.

</p>

</blockquote>

<ul class="menu">
<li><a accesskey="1" href="#Table-of-Contents">Содержание</a>
</li></ul>

<h2 class="chapheading">Главы</h2>

<ul class="menu">
<li><a accesskey="1" href="#Introduction">Введение</a>:    Введение в систему постоянных объектов Elephant. 
</li><li><a accesskey="2" href="#Tutorial">Учебник</a>:        Базовое руководство по ``началу работы''. 
</li><li><a accesskey="3" href="#Installation">Инсталяция</a>:    Процедуры установки и тестирования(test-suite). 
</li><li><a accesskey="4" href="#User-Guide">Руководство пользователя</a>:      подробное обсуждение всех возможностей и функций Elephant. 
</li><li><a accesskey="5" href="#User-API-Reference">Справочник по пользовательскому API</a>:  документация по функциям и классам пользовательского API. 
</li><li><a accesskey="6" href="#Design-Patterns">Шаблоны проектирования</a>:     сценарии проектирования для приложений Elephant. 
</li><li><a accesskey="7" href="#Elephant-Architecture"> Архитектура  Elephant</a>:      обзор внутренней архитектуры elephant. 
</li><li><a accesskey="8" href="#Data-Store-API-Reference">Справочник по API хранилища данных</a>:   документация на уровне функций для разработчиков хранилищ данных. 
</li><li><a accesskey="9" href="#Copyright-and-License">Copyright and License</a>:      ваши права и свободы. 
</li></ul>

<h2 class="chapheading">Приложения</h2>

<ul class="menu">
<li><a accesskey="1" href="#Concept-Index">Указатель концепций</a>
</li><li><a accesskey="2" href="#Object-Index">Указатель объектов</a>
</li><li><a accesskey="3" href="#Function-_002f-Macro-Index">Указатель Функций/Макросов</a>
</li><li><a accesskey="4" href="#Variable-Index">Указатель Переменных</a>
</li><li><a accesskey="5" href="#Colophon">концовка</a>
</li></ul>

<div class="node">

<p></p>

<hr>
<a name="Table-of-Contents"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction">Introduction</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered"></h2>

<!-- node-name,  next,  previous,  up -->
   <div class="contents">
<h2>Оглавление</h2>
<ul>
<li><a name="toc_Top" href="#Top">Авторские права</a>
</li><li><a name="toc_Table-of-Contents" href="#Table-of-Contents"></a>
</li><li><a name="toc_Introduction" href="#Introduction">1 Введение</a>
<ul>
<li><a href="#Introduction">1.1 История</a>
</li><li><a href="#Introduction">1.2 Цели Elephant</a>
</li><li><a href="#Introduction">1.3 Дополнительная информация</a>
</li></ul>
</li><li><a name="toc_Tutorial" href="#Tutorial">2 Учебник</a>
<ul>
<li><a href="#Overview">2.1 Обзор</a>
</li><li><a href="#Getting-Started">2.2 Начало работы</a>
</li><li><a href="#The-Store-Root">2.3 Корень Хранилища</a>
</li><li><a href="#Serialization">2.4 Сериализация</a>
</li><li><a href="#Persistent-Classes">2.5 Постоянные классы</a>
</li><li><a href="#Rules-about-Persistent-Classes">2.6 Правила о постоянных классах</a>
</li><li><a href="#Persistent-collections">2.7 Постоянные коллекции</a><ul>
<li><a href="#Persistent-collections">2.7.1 Использованиеg PSets</a>
</li><li><a href="#Persistent-collections">2.7.2 Использование BTrees</a>
</li></ul>
</li><li><a href="#Indexing-Persistent-Classes">2.8 Индексирование постоянных классов</a>
</li><li><a href="#Using-Transactions">2.9 Использование транзакций</a>
<ul>
<li><a href="#Using-Transactions">2.9.1 Зачем нам нужны транзакции?</a>
</li><li><a href="#Using-Transactions">2.9.2 Использование <code>with-transaction</code></a>
</li><li><a href="#Using-Transactions">2.9.3 Вложенные транзакции</a>
</li><li><a href="#Using-Transactions">2.9.4 Идемпотентные побочные эффекты</a>
</li><li><a href="#Using-Transactions">2.9.5 Транзакции и производительность</a>
</li><li><a href="#Using-Transactions">2.9.6 Транзакции и приложения(применения)</a>
</li></ul>
</li><li><a href="#Advanced-Topics">2.10 Расширенные темы</a>
</li></ul>
</li><li><a name="toc_Installation" href="#Installation">3 Установка</a>
<ul>
<li><a href="#Requirements">3.1 Требования</a>
<ul>
<li><a href="#Requirements">3.1.1 Поддерживаемые комбинации Lisp, платформ и хранилищ данных</a>
</li><li><a href="#Requirements">3.1.2 Зависимости от библиотек</a>
</li></ul>
</li><li><a href="#Configuring-Elephant">3.2 Настройка Elephant</a>
</li><li><a href="#Loading-Elephant">3.3 Загрузка Elephant</a>
<ul>
<li><a href="#Loading-Elephant">3.3.1 Загрузка Elephant через  ASDF</a>
</li><li><a href="#Loading-Elephant">3.3.2 Процесс двухфазной нагрузки</a>
</li><li><a href="#Loading-Elephant">3.3.3 Пакеты</a>
</li><li><a href="#Loading-Elephant">3.3.4 Открытие Хранилища</a>
</li></ul>
</li><li><a href="#Berkeley-DB">3.4 Berkeley DB</a>
</li><li><a href="#Berkeley-DB-Example">3.5 Настройка Berkeley DB</a>
</li><li><a href="#Upgrading-Berkeley-DB-Databases">3.6 Обновление баз данных Berkeley DB </a>
<ul>
<li><a href="#Upgrading-Berkeley-DB-Databases">3.6.1 Обновление до 0.9</a>
</li><li><a href="#Upgrading-Berkeley-DB-Databases">3.6.2 Обновление из Elephant 0.5</a>
</li></ul>
</li><li><a href="#CL_002dSQL">3.7 CL-SQL</a>
</li><li><a href="#CL_002dSQL-Example">3.8 CL-SQL Пример</a>
</li><li><a href="#Elephant-on-Windows">3.9 Elephant в Windows</a>
</li><li><a href="#Test-Suites">3.10 Наборы тестов</a>
</li><li><a href="#Documentation">3.11 Документация</a>
</li></ul>
</li><li><a name="toc_User-Guide" href="#User-Guide">4 Руководство пользователя</a>
<ul>
<li><a href="#The-Store-Controller">4.1 Контроллер Хранилища</a>
</li><li><a href="#Serialization-details">4.2 Детали сериализации</a>
<ul>
<li><a href="#Serialization-details">4.2.1 Ограничения Store-by-Value(хранения по значению)</a>
</li><li><a href="#Serialization-details">4.2.2 Атомарные типы</a>
</li><li><a href="#Serialization-details">4.2.3 Агрегатные типы</a>
</li></ul>
</li><li><a href="#Persistent-Classes-and-Objects">4.3 Постоянные классы и объекты</a>
<ul>
<li><a href="#Persistent-Classes-and-Objects">4.3.1 Определение постоянного класса</a>
</li><li><a href="#Persistent-Classes-and-Objects">4.3.2 Создание экземпляра</a>
</li><li><a href="#Persistent-Classes-and-Objects">4.3.3 Жизненный цикл постоянного экземпляра</a>
</li><li><a href="#Persistent-Classes-and-Objects">4.3.4 Использование временных слотов</a>
</li><li><a href="#Persistent-Classes-and-Objects">4.3.5 Использование постоянных слотов</a>
</li><li><a href="#Persistent-Classes-and-Objects">4.3.6 Переопределение класса</a>
</li><li><a href="#Persistent-Classes-and-Objects">4.3.7 Поддержка для <code>change-class</code></a>
</li></ul>
</li><li><a href="#Class-Indices">4.4 Индексы классов</a>
<ul>
<li><a href="#Class-Indices">4.4.1 Синхронизация классов и хранилищ данных</a>
</li></ul>
</li><li><a href="#Persistent-Sets">4.5  Постоянные  Sets(наборы)</a>
</li><li><a href="#Persistent-BTrees">4.6 Постоянные BTrees(бинарные деревья)</a>
</li><li><a href="#BTree-Cursors">4.7 Курсоры BTree</a>
</li><li><a href="#BTree-Indexing">4.8 Индексирование BTree</a>
</li><li><a href="#Index-Cursors">4.9 Индексные курсоры</a>
</li><li><a href="#Multi_002dthreaded-Applications">4.10 Многопоточные приложения</a>
<ul>
<li><a href="#Multi_002dthreaded-Applications">4.10.1 Общие ресурсы</a>
</li><li><a href="#Multi_002dthreaded-Applications">4.10.2 Безопасность потоков и транзакции хранилища данных</a>
</li><li><a href="#Multi_002dthreaded-Applications">4.10.3 Минимизация зависимости от специальных локальных потоков</a>
</li></ul>
</li><li><a href="#Transaction-Details">4.11 Детали транзакции</a>
<ul>
<li><a href="#Transaction-Details">4.11.1 внутри  <code>with-transaction</code> </a>
</li><li><a href="#Transaction-Details">4.11.2 внутри  <code>execute-transaction</code> </a>
</li><li><a href="#Transaction-Details">4.11.3 Создание собственной транзакционной платформы</a>
</li><li><a href="#Transaction-Details">4.11.4 Анализ поведения динамических транзакций</a>
</li></ul>
</li><li><a href="#Multi_002drepository-Operation">4.12 Работа с несколькими репозиториями</a>
</li><li><a href="#Multiple-Processes-and-Distributed-Applications">4.13 Множественные процессы и распределенные приложения</a>
</li><li><a href="#Repository-Migration-and-Upgrade">4.14  Миграция и обновление репозитория</a>
</li><li><a href="#Performance-Tuning">4.15 Настройка производительности</a>
</li><li><a href="#Garbage-Collection">4.16 Сборка мусора</a>
</li><li><a href="#Berkeley-DB-Data-Store">4.17  Хранилище данных Berkeley DB</a>
<ul>
<li><a href="#Berkeley-DB-Data-Store">4.17.1 Обзор архитектуры</a>
</li><li><a href="#Berkeley-DB-Data-Store">4.17.2 Открытие хранилища</a>
</li><li><a href="#Berkeley-DB-Data-Store">4.17.3 Запуск транзакции</a>
</li><li><a href="#Berkeley-DB-Data-Store">4.17.4 Специальные команды</a>
</li><li><a href="#Berkeley-DB-Data-Store">4.17.5 Настройка производительности</a>
</li></ul>
</li><li><a href="#CLSQL-Data-Store">4.18 Хранилище данных CLSQL</a>
<ul>
<li><a href="#CLSQL-Data-Store">4.18.1 Базовая реализация CLSQL</a>
</li></ul>
</li><li><a href="#Postmodern-Data-Store">4.19 Постмодернистское хранилище данных</a>
</li><li><a href="#Native-Lisp-Data-Store">4.20 Собственное хранилище данных Lisp</a>
</li></ul>
</li><li><a name="toc_User-API-Reference" href="#User-API-Reference">5 Справочник по пользовательскому API</a>
<ul>
<li><a href="#Store-Controller-API">5.1 Контроллеры Хранилища</a>
</li><li><a href="#Persistent-Object-API">5.2 Постоянные объекты</a>
</li><li><a href="#Persistent-Object-Indexing-API">5.3 Индексирование постоянных объектов</a>
<ul>
<li><a href="#Persistent-Object-Indexing-API">5.3.1 Средства доступа(Accessors) к индексированным объектам </a>
</li></ul>
</li><li><a href="#Persistent-Set-API">5.4 Постоянные Sets(наборы)</a>
</li><li><a href="#BTree-API">5.5 BTrees</a>
</li><li><a href="#BTree-Cursor-API">5.6 Курсоры Btree</a>
</li><li><a href="#Index-Cursor-API">5.7 Индексные курсоры</a>
</li><li><a href="#Transaction-API">5.8  Транзакции</a>
</li><li><a href="#Migration-and-Upgrading-API">5.9 Миграция и обновление</a>
</li></ul>
</li><li><a name="toc_Design-Patterns" href="#Design-Patterns">6 Шаблоны проектирования</a>
<ul>
<li><a href="#Persistent-System-Objects">6.1 Постоянные системные объекты</a>
</li><li><a href="#File-System-Replacement">6.2 Замена файловой системы</a>
</li><li><a href="#Checkpointing-Conventional-Program-State">6.3 Проверка обычного состояния программы</a>
<ul>
<li><a href="#Checkpointing-Conventional-Program-State">6.3.1 Допущения</a>
</li><li><a href="#Checkpointing-Conventional-Program-State">6.3.2 Набор снимков</a>
</li><li><a href="#Checkpointing-Conventional-Program-State">6.3.3 Реализация набора снимков</a>
</li><li><a href="#Checkpointing-Conventional-Program-State">6.3.4 Изоляция нескольких наборов моментальных снимков</a>
</li></ul>
</li><li><a href="#Elephant-as-Database">6.4 Elephant как база данных</a>
</li><li><a href="#Multithreaded-Web-Applications">6.5 Многопоточные веб-приложения</a>
</li><li><a href="#Real_002dWorld-Application-Examples">6.6 Примеры реальных приложений</a>
<ul>
<li><a href="#Real_002dWorld-Application-Examples">6.6.1 Konsenti</a>
</li><li><a href="#Real_002dWorld-Application-Examples">6.6.2 Conceptminer</a>
</li></ul>
</li></ul>
</li><li><a name="toc_Elephant-Architecture" href="#Elephant-Architecture">7 архитектура Elephant</a>
<ul>
<li><a href="#Elephant-Architecture">7.1 Инициализация контроллера хранилища</a>
</li><li><a href="#Elephant-Architecture">7.2 Создание постоянного объекта</a>
</li><li><a href="#Elephant-Architecture">7.3 Протокол постоянного слота</a>
</li><li><a href="#Elephant-Architecture">7.4 Протоколы постоянных коллекций</a>
</li><li><a href="#Elephant-Architecture">7.5 Реализация транзакций</a>
<ul>
<li><a href="#Elephant-Architecture">7.5.1 Реализация транзакции Execute</a>
</li><li><a href="#Elephant-Architecture">7.5.2 Чередование транзакций с несколькими хранилищами</a>
</li></ul>
</li></ul>
</li><li><a name="toc_Data-Store-API-Reference" href="#Data-Store-API-Reference">8 Справочник по API хранилища данных</a>
<ul>
<li><a href="#DSR-Registration">8.1 Регистрация</a>
</li><li><a href="#DSR-Store-Controllers">8.2 Контроллеры хранилища</a>
</li><li><a href="#DSR-Persistent-Objects-and-Slot-Access">8.3 Доступ к слоту</a>
</li><li><a href="#DSR-Collections">8.4 Коллекции</a>
</li><li><a href="#DSR-Cursors">8.5 Курсоры</a>
</li><li><a href="#DSR-Transactions">8.6 Транзакции</a>
</li><li><a href="#DSR-Multithreading-Considerations">8.7 Особенности многопоточности</a>
</li><li><a href="#DSR-Handling-Serialization">8.8 Обработка сериализации</a>
</li></ul>
</li><li><a name="toc_Copyright-and-License" href="#Copyright-and-License">9 Авторское право и лицензия</a>
<ul>
<li><a href="#Copyright-and-License">9.1 Лицензирование  Elephant</a>
</li><li><a href="#Copyright-and-License">9.2 Авторские права и лицензии на руководство по эксплуатации Elephant</a>
</li><li><a href="#Copyright-and-License">9.3 Сторонние библиотеки</a>
</li><li><a href="#Copyright-and-License">9.4 Вопросы лицензирования хранилища данных</a>
</li></ul>
</li><li><a name="toc_Concept-Index" href="#Concept-Index">Приложение A Указатель концепций</a>
</li><li><a name="toc_Object-Index" href="#Object-Index">Приложение B Указатель объектов</a>
</li><li><a name="toc_Function-_002f-Macro-Index" href="#Function-_002f-Macro-Index">Приложение C Указатель функций / макросов</a>
</li><li><a name="toc_Variable-Index" href="#Variable-Index">Приложение D Переменный указатель</a>
</li><li><a name="toc_Colophon" href="#Colophon">Концовка</a>
</li></ul>
</div>

<!-- *-texinfo-*- -->
<div class="node">

<p></p>

<hr>
<a name="Introduction"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tutorial">Tutorial</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Table-of-Contents">Table of Contents</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name, next, previous, up -->
<h2 class="chapter">1  Введение</h2>

<p><a name="index-History-1"></a><a name="index-Goals-2"></a>

   </p>

<p>Elephant - это протокол постоянных объектов и база данных для Common Lisp. 
Компонент постоянного протокола Elephant переопределяет создание класса и 
доступ к стандартным слотам с использованием протокола метаобъектов (MOP), 
чтобы сделать значения слотов постоянными. Функциональность базы данных включает 
возможность постоянно индексировать и извлекать упорядоченные наборы экземпляров 
классов и обычных значений lisp. У Elephant есть обширный набор тестов, и его 
основная функциональность становится достаточно зрелой.

   </p>

<p>Кодовая база Elephant доступна по лицензии LLGPL. Каждое хранилище данных 
поставляется с собственной отдельной лицензией, и вам придется самостоятельно 
оценить последствия их использования. 

</p>

<h3 class="section">1.1 История</h3>

<p>Первоначально Elephant задумывался как облегченный интерфейсный слой поверх 
библиотеки Berkeley DB, широко распространенной встраиваемой базы данных, 
которую многие системы unix устанавливают по умолчанию. Berkeley DB является 
ACID-совместимой, транзакционной, технологической и поточно-ориентированной и 
быстрой по сравнению с реляционными базами данных.

   </p>

<p>Elephant был расширен для обеспечения поддержки нескольких бэкэндов, 
в частности бэкэнда реляционной базы данных на основе CL-SQL, который 
был протестирован с Postgres и SQLite 3, и, вероятно, легко поддерживает 
другие реляционные системы. Он поддерживает, с некоторой осторожностью, 
работу с несколькими репозиториями и обеспечивает удобный перенос данных 
между репозиториями.


   </p>

<p>Поддержка реляционных бэкэндов и переход на LLGPL должны были позволить 
более широкое использование Elephant как в некоммерческих, так и в коммерческих целях. 
В будущих выпусках запланировано несколько дополнительных бэкендов, 
в том числе нативная реализация Lisp, выпущенная под LLGPL.

   </p>

<p>В настоящее время Elephant уделяет особое внимание расширению 
набора функций, включая собственный бэкэнд Lisp, простой язык 
запросов и гибкие модели сохраняемости, которые выборочно нарушают 
одно или несколько ограничений ACID для повышения производительности. 

</p>

<h3 class="section">1.2  Цели Elephant</h3>

     <ul>
<li><strong> Прозрачность:</strong> большинство значений Lisp легко сохранить 
без значительных усилий или специального синтаксиса. Вы можете полностью 
взаимодействовать с БД из Лиспа. Нет необходимости использовать 
предметно-ориентированные языки, такие как SQL, для доступа к постоянным ресурсам. 
Elephant загружается через ASDF и не требует внешнего сервера (за исключением 
некоторых бэкэндов SQL, таких как Postgres).

     </li><li><strong>Простота:</strong>  небольшая библиотека с несколькими 
сюрпризами для программиста. Lisp и Berkeley DB вместе - отличный субстрат; 
Elephant старается максимально использовать свои возможности. Поддержка дополнительных 
серверных модулей - это параметры времени загрузки, которые более или менее 
прозрачны для пользователя.

     </li><li><strong>Безопасность:</strong> ACID, транзакции. Одновременно 
с хорошей многопользовательской (BDB) и многопоточной семантикой (BDB/SQL), 
изоляцией, блокировкой и обнаружением взаимоблокировок. (Для обнаружения 
тупиковых ситуаций требуется запуск внешнего процесса для Berkeley DB) 

     </li><li><strong>Производительность:</strong>  используйте производительность
Berkeley DB и/или надежность реляционной базы данных. В дополнение к быстрым 
параллельным/транзакционным режимам, elephant (в конечном итоге) предложит 
ускоренный однопользовательский, а также режим чисто в памяти, который должен 
быть сопоставим с решениями в стиле распространенности, но будет использовать 
общий интерфейс программиста.

     </li><li><strong>Историческая преемственность:</strong>  Elephant не пытается 
значительно усовершенствовать предыдущие хранилища постоянных объектов Lisp, 
такие как AllegroStore (также основанный на Berkeley DB), новый AllegroCache, 
систему символов Statice и PLOB. Любой, кто знаком с этими системами, 
узнает интерфейс Elephant.

     </li><li><strong>Гибкость лицензии:</strong>  Elephant выпускается под лицензией LLGPL.
Поскольку он поддерживает множественную реализацию серверной части, можно выбрать 
серверную часть с лицензированием и другими функциями, соответствующими вашим 
потребностям. 

</li></ul>

<h3 class="section">1.3 Дополнительная информация</h3>

<p>Присоединяйтесь к спискам рассылки Elephant, чтобы задавать вопросы и 
получать новости. Вы также можете просмотреть архивы прошлых обсуждений и 
вопросов. Указатели можно найти на сайте Elephant по адресу


   </p>

<p><a href="http://www.common-lisp.net/project/elephant">http://www.common-lisp.net/project/elephant</a>.

   </p>

<p>Инструкции по установке можно найти в разделе 
<a href="#Installation">Установка</a>. Об ошибках можно сообщать через систему 
Elephant Trac по адресу


   </p>

<p><a href="http://trac.common-lisp.net/elephant/">http://trac.common-lisp.net/elephant/</a>.

   </p>

<p>Это также служит хорошей отправной точкой для выяснения, какие новые 
функции или возможности вы можете внести в Elephant. Система Trac также 
содержит вики-страницу с обсуждениями дизайна и часто задаваемыми вопросами. 

<!-- *-texinfo-*- -->
</p>

<div class="node">

<p></p>

<hr>
<a name="Tutorial"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installation">Installation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name, next, previous, up -->
<h2 class="chapter">2 Учебник</h2>

<p><a name="index-Tutorial-3"></a>

</p>

<ul class="menu">
<li><a accesskey="1" href="#Overview">Обзор</a>:  Обзор возможностей elephant. 
</li><li><a accesskey="2" href="#Getting-Started"> Начало работы</a>:  открытие хранилища и доступ к нему. 
</li><li><a accesskey="3" href="#The-Store-Root">Корень хранилища</a>:  доступ к постоянным данным. 
</li><li><a accesskey="4" href="#Serialization">Сериализация</a>:  семантика хранения для значений lisp. 
</li><li><a accesskey="5" href="#Persistent-Classes">Постоянные классы</a>:  семантика постояннства  для объектов 
</li><li><a accesskey="6" href="#Rules-about-Persistent-Classes">Правила о постоянных классах</a>:  что вам нужно знать. 
</li><li><a accesskey="7" href="#Persistent-collections">Постоянные коллекции</a>:  отслеживайте коллекции значений. 
</li><li><a accesskey="8" href="#Indexing-Persistent-Classes">Индексирование постоянных классов</a>:  простой способ отслеживать постоянные экземпляры. 
</li><li><a accesskey="9" href="#Using-Transactions">Использование транзакций</a>:  предоставление свойств базы данных ACID. 
</li><li><a href="#Advanced-Topics">Дополнительные темы</a>:  дополнительная функциональность
 Elephant, описанная в Руководстве пользователя.  
</li></ul>

<div class="node">

<p></p>

<hr>
<a name="Overview"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Getting-Started">Getting Started</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">2.1  Обзор</h3>

<p>Elephant - это  метапротокол постоянства(Persistence Metaprotocol) и 
база данных для Common Lisp. Он предоставляет пользователям возможность определять 
постоянные объекты и взаимодействовать с ними, а также прозрачно хранить обычные 
значения lisp. Постоянные объекты - это экземпляры CLOS, которые перегружают обычную 
семантику доступа к слоту, так что каждая запись в слот проходит и записывается на диск.
Непостоянные объекты и значения lisp могут быть записаны в слоты и будут автоматически 
сохраняться. Кроме того, Elephant предоставляет постоянный индекс, который поддерживает
упорядоченную коллекцию значений lisp или ссылок на постоянные  объекты.

   </p>

<p>Использование постоянных объектов делает кодирование кратким, удобным и мощным, 
а также делает постоянство почти невидимым для программиста. Однако Elephant 
также позволяет использовать тот же базовый словарь данных для поиска ключ/значение, 
который предоставляет BerkeleyDB. 

   </p>

<p>Когда кто-то говорит "база данных", большинство людей думают о системах 
управления реляционными базами данных SQL (например, Oracle, Postgresql, MySql). 
Эти системы хранят данные в статически типизированных таблицах с уникальными 
общими значениями для соединения строк в отдельных таблицах. Объекты могут быть 
сопоставлены с этими таблицами в объектно-реляционном сопоставлении, которое 
назначает объекты строкам, а значения слотов - столбцам в таблице строк. 
Если слот ссылается на другой тип объекта, уникальный идентификатор может 
использоваться для ссылки на таблицу этого объекта. CL-SQL, например, предоставляет 
средства для такого рода объектно-реляционного сопоставления, и существует 
множество систем для других языков, которые делают то же самое (например, 
Hibernate для Java).

   </p>

<p>Хотя Elephant может использовать либо СУБД, либо Berkeley DB в качестве 
хранилища данных, он поддерживает модель объектов, хранящихся в постоянных индексах. 
В отличие от таких систем, как Hibernate для Java, пользователю не нужно создавать 
или беспокоиться о отображении пространства объектов в базу данных. Elephant 
полагается на LISP, а не на SQL в своем языке обработки данных. Elephant 
разработан как простой и удобный инструмент для программиста. 

   </p>

<p>Elephant состоит из небольшой вселенной основных понятий::

     </p>

<ul>
<li><strong>Контроллер хранилища:</strong> интерфейс между lisp и хранилищем данных. 
Большинство операций требуют или принимают для работы контроллер хранилища или 
контроллер хранилища по умолчанию, хранящийся в <code>*store-controller*</code>.
</li><li><strong>Постоянные наборы:</strong>  предоставляется простая постоянная коллекция,
которая позволяет создавать постоянные наборы.
</li><li><strong>BTrees:</strong> Elephant обеспечивает постоянную абстракцию «ключ-значение» 
на основе структуры данных BTree. Значения могут быть записаны в BTree или считаны из него 
и хранятся в отсортированном порядке.
</li><li><strong>Сохраненные значения:</strong> большинство значений lisp, включая стандартные
объекты, массивы и т. Д., Могут использоваться как ключ или значение в постоянном BTree.
</li><li><strong>Постоянные объекты:</strong> объект, в котором большинство значений слотов
хранятся в хранилище данных и записываются или извлекаются с диска при доступе к слотам. 
При хранении постоянного объекта сохраняется только ссылка, позволяющая идентифицировать объект.
</li><li><strong>Индексирование объектов:</strong> возможность поиска и сортировки объектов 
по значениям их слотов, а не путем явного включения в коллекцию.
</li><li><strong>Транзакции:</strong> динамический контекст для выполнения операций с 
объектами или коллекциями, в которых побочные эффекты проявляют свойства ACID 
(атомарность(atomicity), согласованность(consistency), изоляция(isolation) и 
долговечность(durability)) базы данных.  
</li></ul>

<p>Существует ряд более сложных концепций, о которых вы узнаете позже, 
но эти базовые концепции помогут вам познакомиться с Elephant.


   </p>

<p>Если у вас еще не установлен и не собран Elephant правильно, прочтите раздел 
<a href="#Installation">Установка</a>  этого руководства, а затем перейдите к разделу
<a href="#Getting-Started">Начало работы</a>.

</p>

<div class="node">

<p></p>

<hr>
<a name="Getting-Started"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-Store-Root">The Store Root</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Overview">Overview</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">2.2 Начало Работы</h3>

<p>Первый шаг в использовании elephant - открыть контроллер хранилища. 
Контроллер хранилища - это объект, который координирует доступ программы Lisp к 
выбранному хранилищу данных.

   </p>

<p>Чтобы получить контроллер хранилища, вы вызываете <code>open-store</code> со 
спецификацией хранилища. Спецификация хранилища - это список, содержащий спецификатор 
серверной части (<code>:BDB</code> or <code>:CLSQL</code>) и ссылку, специфичную 
для серверной части.


   </p>

<p>Для: BDB второй элемент - это строка или путь, который ссылается на локальный каталог 
для файлов базы данных. Этот каталог должен быть создан до вызова open-store. 

</p>

<pre class="lisp">     (open-store '(:BDB ``/users/me/db/my-db/''))
</pre>

<p>Для: CLSQL второй аргумент - это еще один список, состоящий из 
конкретной базы данных SQL и имени файла базы данных или записи подключения 
к серверу SQL. Примеры: 

</p>

<pre class="lisp">     (open-store '(:CLSQL (:SQLITE "/users/me/db/sqlite.db")))
     (open-store '(:CLSQL (:POSTGRESQL "localhost.localdomain"
                                       "mydb" "myuser" ""))))
</pre>

<p>Мы используем Berkeley DB в качестве нашего примера серверной части. 
Чтобы открыть контроллер хранилища BDB, мы можем сделать следующее: 

</p>

<pre class="lisp">     (asdf:operate 'asdf:load-op :elephant)
     (use-package :elephant)
     (setf *test-db-spec*
           '(:BDB "/home/me/db/testdb/"))
     (open-store *test-db-spec*)
</pre>

<p>Нам не нужно сохранять ссылку на хранилище прямо сейчас, так как она 
автоматически присваивается переменной <code>*store-controller*</code>. 
Более подробное обсуждение управления контроллером хранилища см. В 
<a href="#User-Guide">Руководстве пользователя</a>.

   </p>

<p>Когда вы закончите сеанс/сессия, освободите ресурсы контроллера хранилища, 
вызвав <code>close-store</code>.

   </p>

<p>Также есть удобный макрос <code>with-open-store</code>, который будет открывать 
и закрывать хранилище, но открытие хранилища - дорогостоящая операция, поэтому обычно 
лучше оставить хранилище открытым, пока оно не перестанет быть нужен вашему приложению. 

</p>

<div class="node">

<p></p>

<hr>
<a name="The-Store-Root"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Serialization">Serialization</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Getting-Started">Getting Started</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">2.3  Корень Хранилища</h3>

<p>То, что ценности живут между сеансами lisp, называется <em>liveness</em>(живучестью).
Живучесть в хранилище определяется тем, можно ли получить значение из корневого 
каталога хранилища. Корень-это специальное BTree(дерево), в котором могут храниться 
другие BTrees и значения lisp. Это BTree имеет специальный интерфейс через 
контроллер хранилища. (Существует второе корневое дерево BTree, называемое 
корнем класса, которое будет обсуждаться позже.)

   </p>

<p>Вы можете поместить что - то в корневой объект,

</p>

<pre class="lisp">     (add-to-root "my key" "my value")
     =&gt; "my value"
</pre>

<p>и получить вещи через 

</p>

<pre class="lisp">     (get-from-root "my key")
     =&gt; "my value"
     =&gt; T
</pre>

<p>Второе значение указывает, был ли найден ключ. Это важно, если ваша пара 
"ключ-значение" может иметь значение nil.

   </p>

<p>Вы также можете выполнять другие основные операции. 

</p>

<pre class="lisp">     (root-existsp "my key")
     =&gt; T
     (remove-from-root "my key")
     =&gt; T
     (get-from-root "my key")
     =&gt; NIL
     =&gt; NIL
</pre>

<p>Чтобы получить доступ ко всем объектам в корне, самый простой способ - 
просто вызвать <code>map-root</code> с функцией, применяемой к каждой 
паре ключ-значение. 

</p>

<pre class="lisp">     (map-root
       (lambda (k v)
          (format t "key: ~A value:~A~%" k v)))
</pre>

<p>Вы также можете напрямую получить доступ к корневому объекту. 

</p>

<pre class="lisp">     (controller-root *store-controller*)
     =&gt; #&lt;DB-BDB::BDB-BTREE  #x10e86042&gt;
</pre>

<p>Это экземпляр класса "btree"; см. <a href="#Persistent-BTrees">Постоянные BTrees</a>.

</p>

<div class="node">

<p></p>

<hr>
<a name="Serialization"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Persistent-Classes">Persistent Classes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Store-Root">The Store Root</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">2.4 Сериализация</h3>

<p>Что можно положить в хранилище, кроме строк? Могут быть сохранены почти 
все значения и объекты lisp: числа, символы, строки, nil, символьные знаки, 
пути, conses(конструкции из пар-в частности списки), хэш-таблицы, массивы, 
объекты и структуры CLOS.  Допускаются вложенные и замкнутые в кольцо списко 
подобные структуры. Вы можете хранить практически все, что угодно, кроме 
скомпилированных функций, замыканий, объектов классов, пакетов и потоков. 
Функции могут храниться как некомпилированные лямбда-выражения. 
(Скомпилированные функции и другие типы объектов также могут получить поддержку.)

   </p>

<p>Elephant необходимо использовать представление данных, которое 
не зависит от конкретного Lisp или хранилища данных. Поэтому все сохраняемые 
значения lisp должны быть <em>serialized</em>(сериализованы) в канонический формат. 
Поскольку Berkeley DB поддерживает двоичные буферы переменной длины, Elephant 
использует систему двоичной сериализации. Этот процесс имеет некоторые важные последствия, 
которые очень важно понимать: 

     </p>

<ol type="1" start="1">
<li><strong>Идентичность Lisp не может быть сохранена</strong>. Поскольку это хранилище, 
которое сохраняется при вызовах Lisp, вероятно, это даже не имеет смысла. Однако, 
если вы получите объект из индекса, сохраните его в переменной lisp, а затем 
получите снова - они не будут eq: 

     <pre class="lisp">          (setq foo (cons nil nil))
          =&gt; (NIL)
          (add-to-root "my key" foo)
          =&gt; (NIL)
          (add-to-root "my other key" foo)
          =&gt; (NIL)
          (eq (get-from-root "my key")
                (get-from-root "my other key"))
          =&gt; NIL
     </pre>
     </li><li><strong>Вложенные агрегаты хранятся в одном буфере</strong>. 
Если вы храните набор объектов в хеш-таблице, вы пытаетесь сохранить хеш-таблицу, 
все эти объекты будут храниться в одном большом двоичном буфере с хеш-ключами. 
Это верно для всех других агрегатов, которые могут хранить тип T 
(cons, массив, стандартный объект и т. Д.).

     </li><li><strong>Мутировавшая субструктура не сохраняется. </strong>.

     <pre class="lisp">          (setf (car foo) T)
          =&gt; T
          (get-from-root "my key")
          =&gt; (NIL)
     </pre>

<p>Это повлияет на все типы агрегатов: объекты, conses, хеш-таблицы и так далее. 
(Вы, конечно, можете вручную повторно сохранить cons.) В этом смысле elephant
не предоставляет постоянные коллекции автоматически. Если вы хотите сохранить 
каждый доступ, вы должны использовать BTrees (см.  <a href="#Persistent-BTrees">Постоянные BTrees</a>).

     </p>

</li><li><strong>Сериализация и десериализация могут быть дорогостоящими</strong>. 
Хотя сериализация происходит довольно быстро, но сохранять большие объекты 
оптом все равно дорого. Кроме того, поскольку идентичность объекта невозможно 
поддерживать, десериализация должна повторно согласовывать или перераспределять 
весь объект каждый раз, когда увеличивается количество сборщиков мусора, которые 
выполняет система. Это стремительное распределение противоречит тому, как большинство 
людей хотят использовать базу данных: одна из причин использования базы данных - 
это то, что ваши объекты не могут поместиться в основную память сразу.

     </li><li><strong>Конфликты слияния в сильно много-процессных/много-поточных ситуациях</strong>. 
Это общая проблема чтения-изменения-записи во всех базах данных. Подробнее об этом мы 
поговорим в разделе <a href="#Using-Transactions">Использование транзакций</a>.

        </li></ol>

<p>Это может показаться ужасно ограничивающим, но не отчаивайтесь, мы решим 
большинство этих проблем в следующем разделе ...

</p>

<div class="node">

<p></p>

<hr>
<a name="Persistent-Classes"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Rules-about-Persistent-Classes">Rules about Persistent Classes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Serialization">Serialization</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">2.5 Постоянные классы</h3>

<p>Объектная система Common Lisp и протокол метаобъектов предоставляют нам 
инструменты для решения этих проблем для объектов: 

</p>

<pre class="lisp">     (defclass my-persistent-class ()
       ((slot1 :accessor slot1)
        (slot2 :accessor slot2))
       (:metaclass persistent-metaclass))

     (setq foo (make-instance 'my-persistent-class))
     =&gt; #&lt;MY-PERSISTENT-CLASS {492F4F85}&gt;

     (add-to-root "foo" foo)
     =&gt; NIL
     (add-to-root "bar" foo)
     =&gt; NIL
     (eq (get-from-root "foo")
         (get-from-root "bar"))
     =&gt; T
</pre>

<p>Что тут происходит? Постоянным классам, то есть классам, которые используют метакласс
<code>persistent-metaclass</code>, даются уникальные идентификаторы (доступные через 
<code>ele::oid</code>). Они сериализованы просто по их OID и классу. Значения слотов 
хранятся отдельно (и невидимы для пользователя) с ключами OID и слотом. Загрузка 
(десериализация) постоянного класса 

</p>

<pre class="lisp">     (get-from-root "foo")
     =&gt; #&lt;MY-PERSISTENT-CLASS {492F4F85}&gt;
</pre>

<p>создает экземпляр объекта или находит его в кэше памяти, если он 
уже существует. (Кеш - это слабая хеш-таблица, поэтому она сбрасывается 
на сборщики мусора(GC), если в памяти не хранятся другие ссылки на постоянный 
объект). Значения слотов НЕ загружаются, пока вы их не запросите. Фактически, 
для постоянных слотов нет места, выделенного для них в экземплярах, потому 
что мы читаем из базы данных. 

</p>

<pre class="lisp">     (setf (slot1 foo) "one")
     =&gt; "one"
     (setf (slot2 foo) "two")
     =&gt; "two"
     (slot1 foo)
     =&gt; "one"
     (slot2 foo)
     =&gt; "two"
</pre>

<p>Внесенные в них изменения распространяются автоматически: 

</p>

<pre class="lisp">     (setf (slot1 foo) "three")
     =&gt; "three"
     (slot1 (get-from-root "bar"))
     =&gt; "three"
</pre>

<p>Вы также можете создавать постоянные классы, используя удобный макрос
<code>defpclass</code>.

</p>

<pre class="lisp">     (defpclass my-persistent-class ()
       ((slot1 :accessor slot1)
        (slot2 :accessor slot2)))
</pre>

<p>Хотя здесь трудно увидеть, сериализация/десериализация постоянных классов 
выполняется быстро, намного быстрее, чем обычные объекты CLOS. Наконец, 
они не страдают от конфликтов слияния при доступе в транзакции (см. Ниже).
Вкратце: постоянные классы решают проблемы, связанные с хранением обычных объектов 
CLOS. Позже мы увидим, что BTrees решают проблемы, связанные с хранением хеш-таблиц. 

</p>

<div class="node">

<p></p>

<hr>
<a name="Rules-about-Persistent-Classes"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Persistent-collections">Persistent collections</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Persistent-Classes">Persistent Classes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">2.6 Правила о постоянных классах</h3>

<p>Использование метакласса <code>persistent-metaclass</code> объявляет все слоты 
постоянными по умолчанию. Чтобы сделать непостоянный(non-persistent) слот, используйте 
флаг <code>:transient t</code>. Слоты классов <code>:allocation :class</code> никогда 
не сохраняются ни для постоянных, ни для обычных классов. (Когда-нибудь, если мы решим 
хранить объекты класса, эта политика может измениться).

   </p>

<p>Постоянные классы могут наследовать от других классов. Слоты, унаследованные 
от постоянных классов, остаются постоянными. Временные слоты и слоты, унаследованные 
от обычных классов, остаются временными. Обычные классы не могут наследовать от 
постоянных классов - в противном случае постоянные слоты не могли быть сохранены! 

</p>

<pre class="lisp">     (defclass stdclass1 ()
       ((slot1 :initarg :slot1 :accessor slot1)))

     (defclass stdclass2 (stdclass1)
       ((slot2 :initarg :slot2 :accessor slot2)))

     (defpclass pclass1 (stdclass2)
       ((slot1 :initarg :slot1 :accessor slot1)
        (slot3 :initarg :slot3 :accessor slot3)))

     (make-instance 'pclass1 :slot1 1 :slot2 2 :slot3 3)
     =&gt; #&lt;PCLASS1 {x10deb88a}&gt;

     (add-to-root 'pinst *)
     =&gt; #&lt;PCLASS1 {x10deb88a}&gt;

     (slot1 pinst)
     =&gt; 1

     (slot2 pinst)
     =&gt; 2

     (slot3 pinst)
     =&gt; 3
</pre>

<p>Теперь мы можем смоделировать новый сеанс lisp, очистив кеш экземпляра, 
перезагрузив наш объект и посмотрев, какие слоты остались. Здесь постоянный 
slot1 должен затенять стандартный slot1 и, таким образом, быть постоянным. 
Slot3 является постоянным по умолчанию, а slot2, поскольку он унаследован 
от стандартного класса, должен быть временным(transient). 

</p>

<pre class="lisp">     (elephant::flush-instance-cache *store-controller*)
     =&gt; #&lt;EQL hash-table with weak values, 0 entries {x11198a02}&gt;

     (setf pinst (get-from-root 'pinst))
     =&gt; #&lt;PCLASS1 {x1119b652}&gt;

     (slot1 pinst)
     =&gt; 1

     (slot-boundp pinst slot2 pinst)
     =&gt; nil

     (slot3 pinst)
     =&gt; 3
</pre>

<p>Использование постоянных объектов влияет на производительность вашей системы. 
Обратите внимание, что база данных читается каждый раз, когда вы обращаетесь к слоту. 
Это функциональность, а не ошибка, особенно в параллельно выполняющихся ситуациях: 
вам нужны самые последние коммиты других потоков, верно? Это можно использовать как 
слабую форму IPC. Но также обратите внимание, что, в частности, если значение вашего 
слота не является непосредственным значением или постоянным объектом, чтение приведет 
к отказу или новому выделению хранилища для значения.

   </p>

<p>Gets(Получение) - не дорогая операция; вы можете выполнять от тысяч до 
десятков тысяч операций чтения примитивов в секунду. Однако, если вас это беспокоит, 
кэшируйте большие значения в памяти и старайтесь не записывать их обратно на диск, 
насколько это возможно. 

</p>

<div class="node">

<p></p>

<hr>
<a name="Persistent-collections"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Indexing-Persistent-Classes">Indexing Persistent Classes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Rules-about-Persistent-Classes">Rules about Persistent Classes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">2.7 Постоянные коллекции</h3>

<p>Оставшаяся проблема, описанная в разделе <a href="#Serialization">Сериализация</a>, 
заключается в том, что операции, изменяющие типы коллекций, не имеют постоянных(сохраняемых) 
побочных эффектов. Мы решили эту проблему для объектов, но не для коллекций, 
таких как массивы, хэши или списки. Elephant предлагает два решения этой проблемы: 
классы <code>pset</code> и <code>btree</code>. Каждый обеспечивает постоянное добавление, 
удаление и изменение элементов, но pset - это простая структура данных, которая может 
быть более эффективной в памяти и времени, чем более общее btree. 

</p>

<h4 class="subsection">2.7.1 Использование PSets</h4>

<p>Постоянный набор(set) поддерживает постоянную неупорядоченную коллекцию 
объектов. Они наследуют все важные свойства постоянных объектов: идентичность 
и быструю сериализацию. Они также решают проблему измененной подструктуры и 
вложенных агрегатов для коллекций. Каждая изменяющаяся запись в <code>pset</code>
 - это независимая и постоянная(сохраняющая) операция, и вы можете сериализовать 
или десериализовать <code>pset</code> без сериализации какой-либо из его 
пар ключ-значение.

   </p>

<p><code>pset</code> также представляет собой очень удобную структуру данных, 
позволяющую постоянному слоту содержать коллекцию, которая может обновляться 
без десериализации и/или повторной сериализации списка, массива или хеш-таблицы 
при каждом доступе.

   </p>

<p>Давайте исследуем эту структуру данных на (очень) простом примере 
социальной сети. 

</p>

<pre class="lisp">     (defpclass person ()
       ((name :accessor person-name :initarg :name))
       ((friends :accessor person-friends :initarg :friends)))
</pre>

<p>Наша цель здесь - сохранить список друзей, которые есть у каждого человека, 
эта простая структура граф позволяет анализировать, например, кто являются 
друзьями моих друзей, или я знаю кого-то, кто знает X, или какой человек имеет 
минимальную степень отделения от всех еще?

   </p>

<p>Без pset нам пришлось бы сделать что-то вроде этого: 

</p>

<pre class="lisp">     (defmethod add-friend ((me person) (them person))
       (let ((friends (person-friends me)))
         (pushnew them friends)
         (setf (person-friends me) friends)))

     (defmethod remove-friend ((me person) (them person))
       (let ((remaining-friends (delete them (person-friends me))))
         (setf (person-friends me) remaining-friends)))

     (defmethod map-friends (fn (me person))
       (mapc fn (person-friends me)))
</pre>

<p>Ой! Это приводит к большому расходу на конструирование списка(consing). 
Мы должны десериализовать и генерировать только что созданный список каждый раз, 
когда мы вызываем <code>person-friends</code>, а затем повторно сериализовать и 
отбрасывать его при каждом вызове <code>(setf person-friends)</code>.

   </p>

<p>Вместо этого мы можем просто использовать <code>pset</code> в качестве значения 
friends(друзей) и реализовать операции добавления и удаления друзей следующим образом: 

</p>

<pre class="lisp">     (defpclass person ()
       ((name :accessor person-name :initarg :name))
       ((friends :accessor person-friends :initarg :friends
                 :initform (make-pset))))

     (defmethod add-friend ((me person) (them person))
       (insert-item them (person-friends me)))

     (defmethod remove-friend ((me person) (them person))
       (remove-item them (person-friends me)))

     (defmethod map-friends (fn (me person))
       (map-pset fn (person-friends me)))
</pre>

<p>Если вы хотите, чтобы список возвращался, когда пользователь сам вызывает 
person-friends, вы можете просто перенастроить такие вещи, как это: 

</p>

<pre class="lisp">     (defpclass person ()
       ((name :accessor person-name :initarg :name))
       ((friends :accessor person-friends-set :initarg :friends
                 :initform (make-pset))))

     (defmethod person-friends ((me person))
       (pset-list (person-friends-set me)))
</pre>

<p>IЕсли вы просто измените вызовы person-friends в наших предыдущих функциях, 
новый набор функций удалит <code>(setf person-friends)</code>, что не имеет смысла 
для слота collection, позволяет пользователям получить список друзей для 
удобного манипулирования списком и избегает всех недостатков нового конструирования
списка(consing), которые преследовали нашу более раннюю версию.

   </p>

<p>Вы можете использовать <code>pset</code> как хотите, как постоянный объект. 
Единственное отличие - это api, используемый для управления им. Вместо 
акцессоров(accessors) слотов(функций доступа к слоту) мы используем 
insert, remove, map и find.

   </p>

<p>У постоянных наборов есть один недостаток - они не собираются сборщиком мусора. 
Со временем потерянные наборы будут занимать много места на диске. Поэтому вам 
необходимо явно освободить место или прибегнуть к более частому использованию 
процедуры миграции для сжатия базы данных. Pset поддерживает <code>drop-pset</code>

   </p>

<p>Однако, учитывая, что постоянные объекты имеют одно и то же явное свойство 
хранения, использование pset для создания слотов коллекции является хорошим 
совпадением.

</p>

<h4 class="subsection">2.7.2 Использование BTrees</h4>

<p>BTrees - это коллекции пар ключ-значение, упорядоченных по ключу, 
с log(N) временем произвольного доступа и богатым механизмом итераций. 
Как и постоянные наборы, они решают все проблемы коллекций, описанные 
в предыдущих разделах. Каждая пара ключ-значение хранится в Elephant 
независимо, как и слоты для постоянных объектов.

   </p>

<p>Первичный интерфейс к объектам <code>btree</code> - это <code>get-value</code>. 
Вы используете <code>setf</code> <code>get-value</code> для хранения пар 
ключ-значение. Этот интерфейс очень похож на <code>gethash</code>.

   </p>

<p>В следующем примере создается btree с именем <code>*friends-birthdays*</code> 
и добавляется в корень, чтобы мы могли получить его во время последующих сеансов. 
Затем мы добавим две пары ключ-значение, состоящие из имени друга и всемирного времени, 
кодирующего его день рождения. 

</p>

<pre class="lisp">     (defvar *friends-birthdays* (make-btree))
     =&gt; *FRIENDS-BIRTHDAYS*

     (add-to-root 'friends-birthdays *friends-birthdays*)
     =&gt; #&lt;BTREE {4951CF6D}&gt;

     (setf (get-value "Ben" *friends-birthdays*)
           (encode-universal-time 0 0 0 14 4 1973))
     =&gt; 2312600400

     (setf (get-value "Andrew" *friends-birthdays*)
           (encode-universal-time 0 0 0 22 12 1976))
     =&gt; 2429071200

     (get-value "Andrew" *friends-birthdays*)
     =&gt; 2429071200
     =&gt; T

     (decode-universal-time *)
     =&gt; 0
        0
        0
        22
        12
        1976
        2
        NIL
        6
</pre>

<p>В дополнение к интерфейсу, подобному хэш-таблице, <code>btree</code> хранит пары,
отсортированные по лисповскому значению ключа, от наименьшего к наибольшему. 
Это хорошо работает для чисел, строк, символов и постоянных объектов, но из-за 
семантики сериализации может быть странным для других значений, таких как 
массивы, списки, стандартные объекты и т. Д.

   </p>

<p>Поскольку элементы отсортированы по значению, мы можем перебирать 
все элементы BTree по порядку. Обратите внимание, что мы ввели данные 
в обратном алфавитном порядке, но будем читать их в алфавитном порядке. 

</p>

<pre class="lisp">     (map-btree (lambda (k v)
                  (format t "name: ~A utime: ~A~%" k
                    (subseq (multiple-value-list
                              (decode-universal-time v)) 3 6)))
                *friends-birthdays*)
     "Andrew"
     "Ben"
     =&gt; NIL
</pre>

<p>Но что, если мы хотим зачитывать своих друзей от старшего к младшему? Один из способов - использовать другое btree, которое сопоставляет дни рождения с именами, но для этого требуется несколько вызовов get-value для каждого обновления, что увеличивает нагрузку на программиста. Elephant предлагает несколько более эффективных способов сделать это.

   </p>

<p>В следующем разделе <a href="#Indexing-Persistent-Classes">Индексирование постоянных классов</a>
показано, как упорядочивать и извлекать постоянные классы по одному или нескольким 
значениям слотов. 

</p>

<div class="node">

<p></p>

<hr>
<a name="Indexing-Persistent-Classes"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-Transactions">Using Transactions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Persistent-collections">Persistent collections</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">2.8  Индексирование постоянных классов</h3>

<p>Индексирование классов упрощает хранение и поиск постоянных объектов. 
Индексированный класс хранит каждый экземпляр созданного класса, обеспечивая 
автоматическое сохранение каждого объекта между сеансами. 

</p>

<pre class="lisp">     (defpclass friend ()
       ((name :accessor name :initarg :name)
        (birthday :initarg :birthday))
       (:index t))
     =&gt; #&lt;PERSISTENT-METACLASS FRIEND&gt;

     (defmethod print-object ((f friend) stream)
       (format stream "#&lt;~A&gt;" (name f)))

     (defun encode-date (dmy)
       (apply #'encode-universal-time
         (append '(0 0 0) dmy)))

     (defmethod (setf birthday) (dmy (f friend))
       (setf (slot-value f 'birthday)
             (encode-date dmy))
       dmy)

     (defun decode-date (utime)
       (subseq (multiple-value-list (decode-universal-time utime)) 3 6))

     (defmethod birthday ((f friend))
       (decode-date (slot-value f 'birthday)))
</pre>

<p>Обратите внимание на аргумент класса “:index t”. Это говорит Elephant 
хранить ссылку на этот класс. Под покровами есть набор b-деревьев, которые 
отслеживают классы, но нам не нужно об этом беспокоиться, поскольку все 
функции были хорошо упакованы для вас.

   </p>

<p>Мы также создали собственный accessor(функцию доступа к данным) дня рождения 
для удобства, поэтому он принимает и возвращает дни рождения в виде списка, 
состоящего из месяца, дня и года, например <code>(27 3 1972)</code>. Однако 
индексным ключом будет закодированное всемирное время.

   </p>

<p>Теперь мы можем легко манипулировать всеми экземплярами класса. 

</p>

<pre class="lisp">     (defun print-friend (friend)
       (format t " name: ~A birthdate: ~A~%"
               (name friend) (birthday friend)))

     (make-instance 'friend :name "Carlos"
                            :birthday (encode-date '(1 1 1972)))
     (make-instance 'friend :name "Adriana"
                            :birthday (encode-date '(24 4 1980)))
     (make-instance 'friend :name "Zaid"
                            :birthday (encode-date '(14 8 1976)))

     (get-instances-by-class 'friend)
     =&gt; (#&lt;Carlos&gt; #&lt;Adriana&gt; #&lt;Zaid&gt;)

     (mapcar #'print-friend *)
      name: Carlos birthdate: (1 1 1972)
      name: Adriana birthdate: (24 4 1980)
      name: Zaid birthdate: (14 8 1976)
     =&gt; (#&lt;Carlos&gt; #&lt;Adriana&gt; #&lt;Zaid&gt;)
</pre>

<p>Но что, если у нас тысячи друзей? Помимо того, что мы никогда не 
выполняем работу, наше получение экземпляров по классам(get-instances-by-class) 
будет делать много лишних усилий, съедая много памяти и тратя наше время. 
К счастью, есть более эффективный способ работы со всеми экземплярами класса. 

</p>

<pre class="lisp">     (map-class #'print-friend 'friend)
      name: Carlos birthdate: (1 1 1972)
      name: Adriana birthdate: (24 4 1980)
      name: Zaid birthdate: (14 8 1976)
     =&gt; NIL
</pre>

<p><code>map-class</code> имеет то преимущество, что он не сохраняет ссылки 
на объекты после их обработки. Может появиться сборщик мусора, который очистит 
ссылки из кэша слабых экземпляров, так что ваш рабочий набор будет конечным. 
Версия списка выше сохраняет все объекты в памяти, прежде чем вы сможете 
что-либо с ними сделать. Затраты на десериализацию в обоих случаях очень низкие.

   </p>

<p>Обратите внимание, что порядок, в котором печатаются записи, не сортируется 
ни по имени, ни по дате рождения. Elephant не дает никаких гарантий относительно 
порядка элементов класса, поэтому вы не можете зависеть от порядка вставки, 
показанного здесь.


   </p>

<p>Так что, если нам нужны упорядоченные элементы? Как получить доступ 
к друзьям по имени и дате рождения? Здесь в игру вступают индексные слоты.

</p>

<pre class="lisp">     (defpclass friend ()
       ((name :accessor name :initarg :name :index t)
        (birthday :initarg :birthday :index t)))
</pre>

<p>Обратите внимание на аргумент :index для слотов и на то, что мы удалили 
аргумент для класса :index. Указание того, что слот индексируется, автоматически 
регистрирует класс как проиндексированный. Хотя индексы слотов увеличивают 
стоимость записи и дискового хранилища, каждая запись лишь немного превышает 
размер значения слота. Числа, маленькие строки и символы являются хорошими 
типами кандидатов для индексированных слотов, но можно использовать любое значение, 
даже разные типы. После того, как слот проиндексирован, мы можем использовать 
индекс для извлечения объектов по значениям слота.

   </p>

<p><code>get-instances-by-value</code> будет извлекать все экземпляры, 
которые равны аргументу value, с отношением равенства, определенным 
серверной частью базы данных. 

</p>

<pre class="lisp">     (get-instances-by-value 'friend 'name "Carlos")
     =&gt; (#&lt;Carlos&gt;)
</pre>

<p>Но что более интересно, мы можем извлекать объекты для диапазона значений. 

</p>

<pre class="lisp">     (get-instances-by-range 'friend 'name "Adam" "Devin")
     =&gt; (#&lt;Adriana&gt; #&lt;Carlos&gt;)

     (get-instances-by-range 'friend 'birthday
                             (encode-date '(1 1 1974))
                             (encode-date '(31 12 1984)))
     =&gt; (#&lt;Zaid&gt; #&lt;Adriana&gt;)

     (mapc #'print-friend *)
      name: Zaid birthdate: (14 8 1976)
      name: Adriana birthdate: (24 4 1980)
     =&gt; (#&lt;Zaid&gt; #&lt;Adriana&gt;)
</pre>

<p>Чтобы получить все экземпляры класса в порядке индекса вместо произвольного порядка,
возвращаемого get-instance-by-class, вы можете использовать nil вместо начального 
и конечного значений, чтобы указать первый или последний элемент. (Примечание: 
чтобы получить значения экземпляра NULL, используйте команду 
<code>get-instances-by-value</code> с nil в качестве аргумента). 

</p>

<pre class="lisp">     (get-instances-by-range 'friend 'name nil "Sandra")
     =&gt; (#&lt;Adriana&gt; #&lt;Carlos&gt;)

     (get-instances-by-range 'friend 'name nil nil)
     =&gt; (#&lt;Adriana&gt; #&lt;Carlos&gt; #&lt;Zaid&gt;)
</pre>

<p>Существуют также функции для сопоставления экземпляров индекса слота. 
Чтобы сопоставить повторяющиеся значения, используйте аргумент ключевое слово
:value. Для сопоставления по диапазону используйте аргументы :start и :end. 

</p>

<pre class="lisp">     (map-class-index #'print-friend 'friend 'name :value "Carlos")
      name: Carlos birthdate: (1 1 1972)
     =&gt; NIL

     (map-class-index #'print-friend 'friend 'name
                      :start "Adam" :end "Devin")
      name: Adriana birthdate: (24 4 1980)
      name: Carlos birthdate: (1 1 1972)
     =&gt; NIL

     (map-class-index #'print-friend 'friend 'birthday
                      :start (encode-date '(1 1 1974))
                      :end (encode-date '(31 12 1984)))
      name: Zaid birthdate: (14 8 1976)
      name: Adriana birthdate: (24 4 1980)
     =&gt; NIL

     (map-class-index #'print-friend 'friend 'birthday
                      :start nil
                      :end (encode-date '(10 10 1978)))
      name: Carlos birthdate: (1 1 1972)
      name: Zaid birthdate: (14 8 1976)
     =&gt; NIL

     (map-class-index #'print-friend 'friend 'birthday
                      :start (encode-date '(10 10 1975))
                      :end nil)
      name: Zaid birthdate: (14 8 1976)
      name: Adriana birthdate: (24 4 1980)
     =&gt; NIL
</pre>

<p><a href="#User-Guide">Руководство пользователя</a> содержит описания расширенных 
функций <a href="#Class-Indices">индексов классов</a>, таких как 
«производные индексы», которые позволяют упорядочивать классы в соответствии с 
произвольной функцией, динамический API для добавления и удаления слотов и то, 
как установить политику для разрешения конфликтов между образом кода и базой данных, 
где спецификация индексации отличается.

   </p>

<p>Это же средство доступно и для вашего личного пользования. Для получения дополнительной информации см. <a href="#BTree-Indexing">Индексирование BTree</a>.

</p>

<div class="node">

<p></p>

<hr>
<a name="Using-Transactions"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Advanced-Topics">Advanced Topics</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Indexing-Persistent-Classes">Indexing Persistent Classes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">2.9 Использование транзакций</h3>

<p>Одной из наиболее важных особенностей базы данных является то, 
что операции обеспечивают выполнение свойств ACID: Atomic(атомарный), 
Consistent(согласованный), Isolated(изолированный) и
Durable(надежный). Говоря простым языком, это означает, что набор 
изменений вносится сразу, что база данных никогда не обновляется частично, 
что каждый набор изменений происходит последовательно и что однажды 
внесенное изменение не теряется.

   </p>

<p>Elephant обеспечивает эту защиту для всех примитивных операций. 
Например, когда вы записываете значение в индексированный слот, обновление 
записи постоянного слота, а также индекса слота защищается транзакцией, 
которая выполняет все обновления атомарно и, таким образом, обеспечивает 
согласованность. 

</p>

<h4 class="subsection">2.9.1  Зачем нам нужны транзакции?</h4>

<p>Большинству реальных приложений потребуется использовать явные транзакции, 
а не полагаться только на примитивы, потому что вам нужно, чтобы несколько 
операций чтения-изменения-обновления действовали как атомарная единица. 
Хорошим примером этого является банковская система. Если поток собирается 
изменить баланс, мы не хотим, чтобы другой поток изменял его в середине операции, 
иначе одна из модификаций может быть потеряна. 

</p>

<pre class="lisp">     (defvar *accounts* (make-btree))

     (defun add-account (account)
       (setf (get-value account *account*)

     (defun balance (account)
       (get-value account *accounts*))

     (defun (setf balance) (amount account)
       (setf (get-value account *accounts*) amount))

     (defun deposit (account amount)
       "This shows a read and a write function call to
        get then set the balance"
       (let ((balance (balance account)))
         (setf (balance account)
               (+ balance amount))))

     (defun withdraw (account amount)
       "A nice concise lisp version for withdraw"
       (decf (balance account) amount))

     (add-account 'me)
     =&gt; 0
     (deposit 'me 100)
     =&gt; 100
     (balance 'me)
     =&gt; 100
     (withdraw 'me 25)
     =&gt; 75
     (balance 'me)
     =&gt; 75
</pre>

<p>Этот простой пример банка имеет серьезную уязвимость. Если два потока 
читают один и тот же баланс, и один записывает новый баланс, а затем другой, 
второй баланс был записан без доступа к балансу, предоставленному первым, 
и поэтому первая транзакция теряется.


   </p>

<p>Способ избежать этого - сгруппировать набор операций вместе, таких как чтение и 
запись в <code>deposit</code>(пополнение) и <code>withdraw</code>(снятие). Мы 
достигаем этого, устанавливая динамический контекст, называемый транзакцией. 

   </p>

<p>Во время транзакции все изменения кэшируются до тех пор, пока транзакция 
не будет зафиксирована(committed). Все изменения, внесенные зафиксированной транзакцией, 
происходят сразу. Транзакции также могут быть прерваны из-за ошибок, возникающих 
во время их активности, или из-за конфликта. Конфликт - это когда другой поток 
записывает в переменную, которую читает текущая транзакция. Как и в приведенном 
выше примере банка, если одна транзакция записывает баланс после того, как текущая 
считала его, то текущая должна начинаться заново, чтобы иметь точный баланс 
для работы. Транзакция, прерванная из-за конфликта, обычно перезапускается до тех пор, 
пока она не будет терпеть неудачу слишком много раз.

   </p>

<p>Самый простой и лучший способ использовать транзакции в Elephant - 
просто заключить все операции в макрос <code>with-transaction</code>. 
Любые операторы в теле макроса выполняются в рамках одной транзакции. 
Таким образом, мы бы изменили наш пример, приведенный выше, 
следующим образом: 

</p>

<pre class="lisp">     (defun deposit (account amount)
       (with-transaction ()
         (let ((balance (balance account)))
           (setf (balance account)
                 (+ balance amount)))))

     (defun withdraw (account amount)
       (with-transaction ()
         (decf (balance account) amount)))
</pre>

<p>И вуаля, у нас есть ACID-совместимая, потокобезопасная, 
устойчивая(сохраняемая) банковская система!

</p>

<h4 class="subsection">2.9.2 Использование <code>with-transaction</code></h4>

<p>Что на самом деле делает для нас <code>with-transaction</code>? Сначала он 
запускает новую транзакцию, пытается выполнить тело и в случае успеха фиксирует(commits) 
транзакцию. Если в любой момент во время динамического экстента этого процесса 
возникает конфликт с транзакцией другого потока, ошибка или другая нелокальная 
передача управления, транзакция прерывается. Если он был прерван из-за конфликта 
или тупика(deadlock), он пытается повторить транзакцию фиксированное количество раз, 
повторно выполняя все тело.

   </p>

<p>И это подводит нас к двум важным ограничениям на тела транзакций: отсутствие 
динамического вложения и идемпотентные побочные эффекты. 

</p>

<h4 class="subsection">2.9.3 Вложенные транзакции</h4>

<p>В общем, вы хотите избежать вложенного использования операторов 
<code>with-transaction</code> над несколькими функциями. Вложенные 
транзакции действительны для некоторых хранилищ данных (а именно Berkeley DB), 
но обычно одновременно может быть активна только одна транзакция. 
Цель вложенной транзакции в поддерживающих их хранилищах данных - 
разбить длинную транзакцию на подмножества. Таким образом, если 
существует конкуренция по данному подмножеству переменных, 
перезапускается только внутренняя транзакция, в то время как более 
крупная транзакция может продолжаться. Когда внутренняя транзакция 
фиксирует свои результаты, эти результаты становятся частью внешней 
транзакции, но не записываются на диск до фиксации внешней транзакции.

   </p>

<p>Если у вас есть примитивные операции, защищенные транзакциями 
(такие как <code>deposit</code>(депозит) и <code>withdraw</code>(снятие)), 
и вы хотите выполнить группу таких транзакций, например, перевод между 
счетами(account), вы можете использовать макрос <code>ensure-transaction</code>
 вместо  <code>with-transaction</code>.

</p>

<pre class="lisp">     (defun deposit (account amount)
       "Wrap the balance read and the setf with the new balance"
       (ensure-transaction ()
         (let ((balance (balance account)))
           (setf (balance account)
                 (+ balance amount)))))

     (defun deposit (account amount)
       "A more concise version with decf doing both read and write"
       (ensure-transaction ()
         (decf (balance account) amount)))

     (defun withdraw (account amount)
       (ensure-transaction ()
         (decf (balance account) amount)))

     (defun transfer (src dst amount)
       "There are four primitive read/write operations
        grouped together in this transaction"
       (with-transaction ()
         (withdraw src amount)
         (deposit dst amount)))
</pre>

<p><code>ensure-transaction</code> точно такой же, как <code>with-transaction</code>, 
за исключением того, что он повторно использует существующую транзакцию, если она 
есть, или создает новую. На самом деле нет ничего плохого в том, чтобы использовать 
этот макрос постоянно.


   </p>

<p>Обратите внимание на использование <code>decf</code> и <code>incf</code> выше. 
Основная причина использования Lisp заключается в том, что он хорошо скрывает 
сложность с помощью подобных сокращенных конструкций. Это также означает, что он 
также будет хорошо скрывать зависимости данных, которые должны быть захвачены 
в транзакции! 

</p>

<h4 class="subsection">2.9.4  Идемпотентные побочные эффекты</h4>

<p>В теле with-transaction любые операции, не связанные с базой данных, 
должны быть <em>idempotent</em>(идемпотентными). То есть побочные эффекты 
тела должны быть одинаковыми, независимо от того, сколько раз тело выполняется. 
Это делается автоматически для побочных эффектов в базе данных, но не для побочных 
эффектов, таких как добавление значения в список lisp или создание нового 
стандартного объекта. 

</p>

<pre class="lisp">     (defparameter *transient-objects* nil)

     (defun load-transients (n)
        "This is the wrong way!"
        (with-transaction ()
           (loop for i from 0 upto n do
              (push (get-from-root i) *transient-objects*))))
</pre>

<p>В этом надуманном примере мы извлекаем набор стандартных объектов 
из базы данных с помощью целочисленного ключа и помещаем их в список 
для дальнейшего использования. Однако, если возникает конфликт, когда 
какой-то другой процесс записывает пару «ключ-значение» в соответствующий ключ, 
вся транзакция будет прервана, и цикл будет запущен снова. В сильно 
конкурирующей системе вы можете увидеть следующие результаты. 

</p>

<pre class="lisp">     (defun test-list ()
        (setf *transient-objects* nil)
        (load-transients)
        (length *transient-objects*))

     (test-list 3)
     =&gt; 3

     (test-list 3)
     =&gt; 5

     (test-list 3)
     =&gt; 4
</pre>

<p>Итак, решение состоит в том, чтобы убедиться, что операция над параметрами 
lisp является атомарной, если транзакция завершается. 

</p>

<pre class="lisp">     (defun load-transients (n)
       "This is a better way"
       (setq *transient-objects*
             (with-transaction ()
                 (loop for i from 0 upto n collect
                       (get-from-root i)))))
</pre>

<p>(Конечно, нам нужно было бы использовать <code>nreverse</code>, если бы мы 
заботились о порядке экземпляров в  <code>*transient-objects*</code>)

   </p>

<p>Лучшее практическое правило - гарантировать, что тела транзакций полностью
функциональны, как указано выше, за исключением побочных эффектов для постоянных 
объектов и btree.

   </p>

<p>Если вам действительно нужно выполнять побочные эффекты в памяти lisp, 
такие как запись во временные слоты, убедитесь, что они идемпотентны и что 
другие процессы не могут прочитать записанные значения до завершения 
транзакции. 

</p>

<h4 class="subsection">2.9.5 Транзакции и производительность</h4>

<p>К настоящему времени транзакции выглядят как больше работы, чем они 
того стоят! К счастью, явное использование транзакций дает также преимущества 
в производительности. Транзакции собирают вместе все записи, которые должны 
быть сделаны в базу данных, и хранят их в памяти до тех пор, пока транзакция 
не зафиксируется(commits), и только затем записывают их на диск.

   </p>

<p>Самый трудоемкий компонент транзакции - это ожидание при сбросе вновь 
записанных данных на диск. Использование поведения автоматической фиксации(auto-committing) 
по умолчанию требует очистки диска для каждой примитивной операции записи. 
Это очень и очень дорого! Поскольку все считанные или записанные значения 
кэшируются в памяти до завершения транзакции, количество сбросов(flushes) может быть 
значительно уменьшено.

   </p>

<p>Но не верьте мне на слово, выполните следующие инструкции и убедитесь сами, 
какое внутреннее влияние транзакции могут оказать на производительность системы. 

</p>

<pre class="lisp">     (defpclass test ()
       ((slot1 :accessor slot1 :initarg :slot1)))

     (time (loop for i from 0 upto 100 do
              (make-instance 'test :slot1 i)))
</pre>

<p>Это может занять много времени, более минуты в хранилище данных CLSQL. 
Здесь каждый новый созданный объект должен независимо записывать свое значение 
на диск и принимать стоимость сброса(flush) на диск. 

</p>

<pre class="lisp">     (time (with-transaction ()
              (loop for i from 0 upto 100 do
                 (make-instance 'test :slot1 i))))
</pre>

<p>Заключение этой операции в транзакцию резко увеличивает время с 10 секунд 
до секунды или меньше.(? что хотел сказать автор? может уменьшает?)

</p>

<pre class="lisp">     (time (with-transaction ()
              (loop for i from 0 upto 1000 do
                 (make-instance 'test :slot1 i))))
</pre>

<p>Когда мы увеличиваем количество объектов в транзакции, временные затраты 
не растут линейно. Это связано с тем, что общее время записи сотни простых 
объектов по-прежнему зависит от записи на диск.

   </p>

<p>Это огромные различия в производительности! Однако мы не можем иметь 
транзакции бесконечно большого размера из-за конечного размера кеш-памяти 
хранилища данных. Большие операции (например, загрузка данных в базу данных) 
необходимо разбить на последовательный набор более мелких транзакций. 
При работе с постоянными объектами хорошее эмпирическое правило состоит в том, 
чтобы количество объектов, затрагиваемых в транзакции, не превышало 1000. 

</p>

<h4 class="subsection">2.9.6  Транзакции и приложения(применения)</h4>

<p>Проектирование и настройка транзакционной архитектуры может оказаться 
довольно сложной. Более того, ошибки в вашей системе может быть очень сложно найти, 
поскольку они проявляются только тогда, когда транзакции чередуются в более 
крупном многопоточном приложении.

   </p>

<p>Во многих случаях вы можете просто игнорировать транзакции. Например, 
если у вас нет других параллельных процессов. В этом случае все операции 
выполняются последовательно и конфликт исключен. Вы можете использовать 
транзакции только для повышения производительности повторяющихся наборов 
операций. 

   </p>

<p>Вы также можете игнорировать транзакции, если ваше приложение может 
гарантировать, что параллелизм не вызовет никаких конфликтов. Например, 
веб-приложение, которое гарантирует, что только один поток будет писать 
в объекты в конкретном сеансе, может полностью избежать транзакций. 
Тем не менее, делать эти предположения полезно с осторожностью. 
В приведенном выше примере функция отчетности, которая выполняет итерацию 
по сеансам, пользователи или другие объекты могут по-прежнему видеть 
частичные обновления (т.е. перед запросом был записан идентификатор пользователя, 
но не имя). Однако, если вас не волнуют эти редкие сбои, этот случай все 
равно останется в силе.


   </p>

<p>Если эти случаи неприменимы к вашему приложению или вы не уверены, лучше 
всего будет программировать с защитой. Разбейте свою систему на наименьшие 
логические наборы примитивных операций (например, <code>withdraw</code>(снятие)
 и <code>deposit</code>(внесение) депозита) с помощью <code>ensure-transaction</code> 
а затем заключите вызовы самого высокого уровня, сделанные в вашу систему, в 
with-transaction, когда операции абсолютно необходимо зафиксировать вместе или 
вам нужна дополнительная производительность . Старайтесь не иметь более двух 
уровней транзакционного доступа: верхний с помощью with-transaction, а нижний - 
с помощью ensure-transaction. 

   </p>

<p>См. <a href="#Transaction-Details">Подробности транзакции</a> для получения 
более подробной информации и <a href="#Design-Patterns">шаблоны проектирования</a>
 для примеров того, как системы могут быть спроектированы и настроены 
с использованием транзакций. 

</p>

<div class="node">

<p></p>

<hr>
<a name="Advanced-Topics"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-Transactions">Using Transactions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">2.10  Расширенные темы</h3>

<p>Учебник охватывает основные темы и концепции использования Elephant. 
Многие люди обнаружат, что именно эти функции наиболее часто используются 
и используются в обычных приложениях.

   </p>

<p>MДля более сложного использования Elephant могут потребоваться дополнительные функции, 
описанные в руководстве пользователя. Ниже приводится список основных функций 
руководства пользователя, которые не были рассмотрены в этом руководстве. 

     </p>

<ul>
<li><strong>Использование нескольких потоков и процессов</strong>
   Какие ограничения необходимо учитывать для использования хранилищ данных Elephant 
в нескольких потоках? Какие есть возможности для совместного использования хранилищ 
данных между несколькими процессами или машинами? 
</li><li><strong>Иерархия классов и запросы</strong>
   При запросе постоянных классов необходимо учитывать некоторые тонкие моменты. 
Например, как вы запрашиваете базовый класс типа people(люди), чтобы получить 
экземпляры подкласса, такие как employee(сотрудник), manager(менеджер), 
consultant(консультант) и т. Д.? 
</li><li><strong>Индексы производных классов</strong>
   Вы можете создавать свои собственные индексы для классов, которые 
являются произвольными lisp-функциями постоянного объекта. 
</li><li><strong>Динамическое управление индексами классов</strong>
  Можно добавлять и удалять индексы из классов во время выполнения. 
</li><li><strong> Определение класса/Разрешение конфликтов базы данных</strong>
  При запуске lisp возникают потенциальные конфликты между определением класса 
и записями индексации в базе данных. Есть некоторые ограничения, которые 
необходимо учитывать, и некоторые возможности для управления тем, как слоты, 
индексы классов и
</li><li><strong>Индексированные BTree</strong>
  Индексированные BTrees похожи на BTrees, за исключением того, что можно 
добавлять индексы, которые являются BTrees, значения которых являются первичными 
ключами в родительском <code>indexed-btree</code>. Это позволяет упорядочивать и 
группировать значения BTree. 
</li><li><strong>BTree Курсоры</strong>
   Если вам нужно сделать больше, чем перебирать коллекцию, или вам нужно 
удалять элементы коллекции, когда вы повторяете курсоры, это важная структура данных. 
Они реализуют множество операторов для перемещения вперед и назад по btree, 
включая операции с диапазоном значений и повторение дублирующих или 
уникальных значений. 
</li><li><strong>Использование операторов сопоставления(Map)</strong>
   Операторы сопоставления могут быть очень эффективными при правильном использовании. 
</li><li><strong>Использование нескольких хранилищ</strong>
Одновременно можно открывать несколько контроллеров хранилищ. Однако это делает 
код более сложным, и вам нужно быть осторожным при их использовании, чтобы избежать 
сбоев и других неприятных побочных эффектов.
</li><li><strong>Настраиваемая архитектура транзакций</strong>
 Вы можете реализовать свою собственную версию <code>with-transaction</code>, 
используя методы базового контроллера для запуска, прерывания и фиксации транзакций. 
Однако вам лучше знать, что вы делаете!
</li><li><strong>Обработка ошибок и условий</strong>
   В Elephant может возникать множество ошибок, которые необходимо обрабатывать приложениям. 
</li><li><strong>Обнаружение взаимоблокировок в Berkeley DB</strong>
   Berkeley DB требует внешнего процесса для обнаружения состояний взаимоблокировок 
между транзакциями. Аргумент ключевое слово :deadlock-detect для open-store спецификаций 
Berkeley DB запускает этот процесс на большинстве лиспов. 
</li></ul>

<p>Кроме того, см. <a href="#Design-Patterns">Шаблоны проектирования</a> для получения 
информации о шаблонах проектирования Elephant, решениях общих проблем и других 
сценариях с множеством возможных решений. 

<!-- *-texinfo-*- -->
</p>

<div class="node">

<p></p>

<hr>
<a name="Installation"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#User-Guide">User Guide</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tutorial">Tutorial</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name, next, previous, up -->
<h2 class="chapter">3  Установка</h2>

<p><a name="index-Installation-4"></a>

</p>

<ul class="menu">
<li><a accesskey="1" href="#Requirements">Требования</a>:  Поддерживаемые лиспы и необходимые библиотеки. 
</li><li><a accesskey="2" href="#Configuring-Elephant">Настройка(конфигурирование) Elephant</a>:  Настройка Elephant и файла конфигурации. 
</li><li><a accesskey="3" href="#Loading-Elephant">Загрузка Elephant</a>:  Загрузка Elephant и протокол загрузки хранилища данных. 
</li><li><a accesskey="4" href="#Berkeley-DB">Berkeley DB</a>:  установка поддержки хранилища данных Berkeley DB. 
</li><li><a accesskey="5" href="#Berkeley-DB-Example">Пример Berkeley DB</a>:  пример установки и запуска хранилища данных Berkeley DB. 
</li><li><a accesskey="6" href="#Upgrading-Berkeley-DB-Databases">Обновление баз данных Berkeley DB</a>:  как перейти на новую версию Berkeley DB. 
</li><li><a accesskey="7" href="#CL_002dSQL">CL-SQL</a>:  установки и подключение к хранилищу данных CL-SQL. 
</li><li><a accesskey="8" href="#CL_002dSQL-Example">Пример CL-SQL</a>:  пример использования хранилища данных. 
</li><li><a accesskey="9" href="#Elephant-on-Windows">Elephant в Windows</a>:  Подробности о запуске Elephant в Windows
</li><li><a href="#Test-Suites">Наборы(сюиты) тестов</a>:  как запустить и интерпретировать выходные данные набора регрессивных тестов
</li><li><a href="#Documentation">Документация</a>:  Создание документации из исходников texinfo. 
</li></ul>

<div class="node">

<p></p>

<hr>
<a name="Requirements"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Configuring-Elephant">Configuring Elephant</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation">Installation</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">3.1 Требования</h3>

<p>Elephant - это мультиплатформенная, мульти-lisp-повская и мульти-бэкэндная система.  
Таким образом, тестирование представляет собой большую сложность. Система попыталась
свести к минимуму внешние зависимости, насколько это возможно, чтобы упростить установку,
но всетаки требуется некоторое терпение и осторожность, чтобы установить Elephant на любую
заданную платформу.  В этом разделе делается попытка максимально упростить это для новых
пользователей. Мы с радостью примем исправления и предложения.

</p>

<h4 class="subsection">3.1.1  Поддерживаемые комбинации Lisp, платформ и хранилищ данных</h4>

<p>Elephant поддерживает SBCL, Allegro, Lispworks, OpenMCL и CMUCL.  Каждый
lisp поддерживается на каждой из платформ, на которых он работает: Mac OS X, 
Linux и Windows.  Начиная с версии 0.6.1, должны поддерживаться как 32-bit, так
и 64-bit системы.

   </p>

<p>Из-за небольшого количества разработчиков и большого количества конфигураций обеспечить
полное тестовое покрытие проблематично.  Есть:

     </p>

<ol type="1" start="1">
<li>Пять Лисп сред(окружений)
</li><li>Три платформы операционных систем
</li><li>32-bit или 64-bit OS/конфигурация компиляции
</li><li>Три конфигурации хранилища данных: Berkeley DB, SQLite3 и Postgresql
        </li></ol>

<p>это означает, что общее количество проверяемых комбинаций может достигать:

   </p>

<p>lisps * os * radix * dstore = 5 * 3 * 2 * 3 = 90 configurations

   </p>

<p>не все эти комбинации допустимы, но подразумевается, что не каждая комбинация
будет протестирована в любом конкретном выпуске. Разработчики и пользователи
регулярно используют следующие платформы

     </p>

<ul>
<li>32/64-bit SBCL на Linux и Mac OS X
</li><li>32-bit Lispworks на Windows и Mac OS X
</li><li>32-bit Allegro на Mac OS X
</li></ul>

<p>На момент написания бэкэнд CLSQL преимущественно использовался под SBCL на 
Linux и Mac OS X.  Разработчики сделают все возможное, чтобы разместить пользователей,
которые хотят протестировать другие комбинации, но вышеуказанные конфигурации будут
наиболее стабильными и надежными.

   </p>

<p>Elephant сейчас в целом довольно стабилен, поэтому не бойтесь пробовать
любую комбинацию - скорее всего, потребуется немного больше работы, чтобы 
поднять её.  В частности, Elephant, вероятно, сможет работать с MySQL
или Oracle с небольшим трудом,  но этого еще никто не просил.

</p>

<h4 class="subsection">3.1.2  Зависимости от библиотек</h4>

<p>Базовая система Elephant требует:

     </p>

<ol type="1" start="1">
<li>asdf  <a href="http://www.cliki.net/asdf">http://www.cliki.net/asdf</a>
</li><li>uffi  requires version 1.5.18 или выше, <a href="http://uffi.b9.com/">http://uffi.b9.com/</a> or <a href="http://www.cliki.net/UFFI">http://www.cliki.net/UFFI</a>
</li><li>cl-base64  <a href="http://www.cliki.net/cl-base64">http://www.cliki.net/cl-base64</a>
</li><li>gcc  Вашей системе требуется GCC (или Cygwin) для построения Elephant 
библиоткеи сериализатора основанной на C.  (Precompiled DLL's are available for 
Windows platforms on the <a href="http://www.common-lisp.net/project/elephant/downloads.html">download page</a>. 
</li><li>rt   для запуска набора тестов требуется система регрессионного тесирования RT: <a href="http://www.cliki.net/RT">http://www.cliki.net/RT</a>
        </li></ol>

<p>Следуйте инструкциям по этим URL-адресам, чтобы загрузить и настроить библиотеки.
(примечание: uffi и cl-base64 можно установить
<a href="http://www.cliki.net/ASDF-Install">asdf-installable</a> в формате asdf-install,
для тех из вас кто установил asdf в вашей системе).  Однако сегодня, Elephant, нельзя
установить в формате asdf.

   </p>

<p>В дополнение к этим библиотекам каждое хранилище данных имеет свои собственные зависимости,
как описано в <a href="#Berkeley-DB">Berkeley DB</a> и
<a href="#CL_002dSQL">CL-SQL</a>.

</p>

<div class="node">

<p></p>

<hr>
<a name="Configuring-Elephant"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Loading-Elephant">Loading Elephant</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Requirements">Requirements</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation">Installation</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">3.2  Настройка Elephant</h3>

<p>Прежде чем вы сможете загружать пакеты(packages) elephant в ваш работающий
lisp, вам необходимо настроить файл конфигурации. Скопируйте справочный файл
config.sexp из корневого каталога в my-config.sexp в корневой каталог. 
 my-config.sexp содержит список пар ключ - значение в формате воспринимаемом
lisp читателем, которые сообщают elephant, где найти различные библиотеки и
как их создать.

   </p>

<p>Например:

</p>

<pre class="lisp">     #+(and (or sbcl allegro) macosx)
     ((:berkeley-db-include-dir . "/opt/local/include/db45/")
      (:berkeley-db-lib-dir . "/opt/local/lib/db45/")
      (:berkeley-db-lib . "/opt/local/lib/db45/libdb-4.5.dylib")
      (:berkeley-db-deadlock . "/opt/local/bin/db45_deadlock")
      (:compiler . :gcc))
</pre>

<p>Ниже приводится руководство по различным параметрам. Для простоты мы включили сюда все
параметры, хотя мы рассмотрим более подробно каждый в последующих разделах описывающих хранилища
данных.

     </p>

<ul>
<li><strong>:compiler</strong> - Сообщает Elephant, какой компилятор использовать для
создания любых Си библиотек.  В настоящее время единственными вариантами являются :gcc на 
Unix платформах и :cygwin для Windows платформ. 
</li><li><strong>:berkeley-db-include-dir</strong> - Путь(pathname) для включаемых(include) файлов для Berkeley DB (db.h)
</li><li><strong>:berkeley-db-lib-dir</strong> - Путь ко всем файлам библиотеки Berkeley DB
</li><li><strong>:berkeley-db-lib</strong> - полный путь к конкретной библиотеке Berkeley DB  (libdb45.so)
</li><li><strong>:berkeley-db-deadlock</strong> - Полный путь к служебной функции утилите BDB db_deadlock
</li><li><strong>:pthread-lib</strong> - Не требуется для SBCL 9.17+
</li><li><strong>:clsql-lib</strong> - В настоящее время не исползуется, добавляет пути к функции поиска библиотеки CL-SQL
</li></ul>

<p>Файл config.sexp содержит набор примеров конфигураций для начала, но вам, скорее всего, потребуется изменить его, для вашей системы.

   </p>

<p>У Elephant есть одна небольшая библиотека C, которую он использует для двоичной сериализации.
Это означает, что вам нужно иметь gcc в ваших путях
(см. <a href="#Elephant-on-Windows">Elephant на Windows</a> для исключений на платформе Window).

</p>

<div class="node">

<p></p>

<hr>
<a name="Loading-Elephant"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Berkeley-DB">Berkeley DB</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Configuring-Elephant">Configuring Elephant</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation">Installation</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">3.3 Загрузка Elephant</h3>

<h4 class="subsection">3.3.1 Загрузка Elephant через ASDF</h4>

<p>Теперь, когда вы загрузили все зависимости и создали файл конфигурации, вы
можете загрузить пакеты и определения Elephant:

</p>

<pre class="lisp">     (asdf:operate 'asdf:load-op :elephant)
</pre>

<p>Эта команда загрузит библиотеки cl-base64 и uffi.  Она также автоматически
скомпилирует и загрузит библиотеку Си.  Процесс сборки больше не зависит от Makefile 
и был проверен на большинстве платформ, но если у вас будет проблема, сообщите о ней
и всём ее выводе, который вы сможете записать, разработчикам, по адресу
<a href="mailto:elephant-devel@common-lisp.net">elephant-devel@common-lisp.net</a>. 
Мы обновим FAQ на <a href="http://trac.common-lisp.net/elephant">http://trac.common-lisp.net/elephant</a>
указав типичные проблемы, с которыми сталкиваются пользователи.

</p>

<h4 class="subsection">3.3.2 Процесс двухфазной загрузки</h4>

<p>Elephant исползует двух-фазный процесс загрузки.  Основной код загружается,
и код для данного хранилища данных загружается по запросу, когда вы вызываете
<code>open-store</code> со спецификацией, ссылающейся на это хранилище данных.
Второй этап процесса загрузки требует, чтобы в вашей системе был установлен ASDF.

   </p>

<p>(Примечание: для этого процесса есть несколько веских и не очень веских
причин.  Одна из причин, вы не можете загрузить ele-bdb.asd напрямую, так
как он зависит от кода лисп, определенного в elephant.asd.  Мы решили не 
исправлять это в версии 0.9, хотя более поздние версии могут улучшить это).

</p>

<h4 class="subsection">3.3.3 Пакеты</h4>

<p>Теперь, когда Elephant загружен, вы можете вызвать <code>use-package</code> в
пакете cl-user,

</p>

<pre class="lisp">     CL-USER&gt; (use-package :elephant)
     =&gt; T
</pre>

<p>использовать предопределенный пользовательский пакет,

</p>

<pre class="lisp">     CL-USER&gt; (in-package :elephant-user)
     =&gt; T

     ELE-USER&gt;
</pre>

<p>или импортируйте символы в свой собственный пакет проекта из :elephant.

</p>

<pre class="lisp">     (defpackage :my-project
       (:use :common-lisp :elephant))
</pre>

<p>Импортированные символы - это все, что необходимо для управления базами данных 
Elephant и они подробно задокументированы в <a href="#User-API-Reference">Справочник по
пользовательскому API</a>

</p>

<h4 class="subsection">3.3.4 Открытие Хранилища</h4>

<p>Как уже говорилось в учебнике, вам нужно открыть хранилище, чтобы начать использовать
Elephant:

</p>

<pre class="lisp">     (open-store '(:BDB "/Users/owner/db/my-bdb/"))
     ...
     ASDF loading messages
     ...
     =&gt; #&lt;BDB-STORE-CONTROLLER&gt;

     (open-store '(:CLSQL (:POSTGRESQL "localhost.localdomain"
                                       "mydb" "myuser" ""))))
     ...
     ASDF loading messages
     ...
     =&gt; #&lt;SQL-STORE-CONTROLLER&gt;
</pre>

<p>При первой загрузке определенного хранилища данных, Elephant вызовет ASDF
для загрузки всех зависимостей указанного хранилища данных, подключения к базе данных
и возврата экземпляра подкласса  <code>store-controller</code> для этого хранилища данных.

</p>

<div class="node">

<p></p>

<hr>
<a name="Berkeley-DB"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Berkeley-DB-Example">Berkeley DB Example</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Loading-Elephant">Loading Elephant</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation">Installation</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">3.4 Berkeley DB</h3>

<p>Хранилище данных Berkeley DB начиналось как очень простой словарь данных
в операционной системе Berkeley Unix.  Существует множество систем "Xdb",
использующих один и тот же или аналогичный  API. Бесплатная версия Berkeley DB 
для некоммерческого использования предоставляется корпорацией Oracle с
доступными коммерческими лицензиями.  Пожалуйста, следуйте процедурам загрузки и
установки, описанными здесь:

   </p>

<p>http://www.oracle.com/technology/products/berkeley-db/db/index.html

   </p>

<p>Elephant работает только с версией 4.5  BerkeleyDB.

</p>

<div class="node">

<p></p>

<hr>
<a name="Berkeley-DB-Example"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Upgrading-Berkeley-DB-Databases">Upgrading Berkeley DB Databases</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Berkeley-DB">Berkeley DB</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation">Installation</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">3.5  Настройка Berkeley DB</h3>

<p>Мы рекомендуем вам скачать и собрать дистрибутив от Oracle. 
Сообщалось о некоторых проблемах со связыванием с Debian, Cygwin или
другими пакетами.  Это особенно актуально для пользователей Windows.

   </p>

<p>Помимо обеспечения того, что файл "my-config.sexp" указывает на ваши
катлоги и файлы установки BDB, ничего другого не требуется для настройки примера,
который использует каталог "testdb" в качестве базы данных (в разделе "tests") 
на верхнем уровне директории Elephant.

   </p>

<p>В одной системе на базе Fedora, файл "my-config.sexp" выглядел так:

</p>

<pre class="lisp">     ((:berkeley-db-include-dir . "/usr/local/BerkeleyDB.4.5/include")
      (:berkeley-db-lib-dir . "/usr/local/BerkeleyDB.4.5/lib")
      (:berkeley-db-lib . "/usr/local/BerkeleyDB.4.5/lib/libdb.so")
      (:berkeley-db-deadlock . "/usr/local/BerkeleyDB.4.5/bin/db_deadlock")
      (:pthread-lib . nil)
      (:clsql-lib . "/usr/local/share/common-lisp/")
      (:compiler . :gcc))
</pre>

<p> <a href="#Test-Suites">Наборы Тестов(Test Suites)</a> дают хороший пример использования
BDB путем запуска теста с использованием спецификации:
</p>

<pre class="lisp">     '(:BDB "&lt;elephant-root&gt;/tests/testdb/")
</pre>

<p>Как только вы начнете работать над приложением, вы захотите изменить путь к каталогу,
который подходит для вашего приложения, и использовать его в качестве спецификации,
передаваемой в  <code> open-store </code> при запуске приложения.

</p>

<div class="node">

<p></p>

<hr>
<a name="Upgrading-Berkeley-DB-Databases"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#CL_002dSQL">CL-SQL</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Berkeley-DB-Example">Berkeley DB Example</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation">Installation</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">3.6  Обновление баз данных Berkeley DB</h3>

<p>Когда выйдет новая версия Elephant, она будет зависеть от новой
версии Berkeley DB.  Если это так, вы доолжны обновить свои базы данных BDB,
чтобы использовать новую версию Elephant.  Это принудительное обновление
является следствием того, что Elephant на анализирует файлы заголовков BDB, 
которые имеют тенденцию изменять различные важные константы с каждым выпуском.
Эти патчи обычно незначительны. Обновление также происходит из-за того, что
Elephant пытается использовать новые функции Berkeley DB.

   </p>

<p>В оставшейся части этого раздела рассказывается о том. как обновить
существующие базы данных Berkeley DB, открыть их в новой версии Elephant
и перенести их во вновь созданную базу данных Elephant.

</p>

<h4 class="subsection">3.6.1 Обновление до 0.9</h4>

<p>This section outlines how to upgrade from Elephant version 0.6.0 and
Berkeley DB 4.3.

     </p>

<ol type="1" start="1">
<li>Install BDB 4.5 (keep 4.3 around for now)
</li><li>Setup my-config.sexp to point to the appropriate BDB 4.5 directories
</li><li>Upgrade your existing database directory to 4.5
          <ul>
 <li>Run db43_recover in your 0.6 database
 </li><li>Optional: run db43_archive -d to remove all logs not part of a checkpoint
    This will make catastrophic recovery impossible, but reduces the amount of data you
    have to backup. 
 </li><li>Backup your db files and remaining logs
 </li><li>Run db45_checkpoint -1 in the database directory
 </li></ul>
     </li><li>Upgrade 0.6 data to a fresh 0.9 database
          <ul>
 <li>Open your old database: <code>(setf sc (open-store '(:BDB "/Users/me/db/ele060/")))</code>
 </li><li>Run upgrade: <code>(upgrade sc '(:BDB "/Users/me/db/ele090/"))</code>
 </li></ul>
     </li><li>Test your new application and report any bugs that arise to <a href="mailto:elephant-devel@common-lisp.net">elephant-devel@common-lisp.net</a>
        </li></ol>

<p><em>(NOTE: close-store may fail when closing the old 0.6 database, this is OK.)</em>

   </p>

<p><em>(NOTE: 64-bit lisps will not successfully upgrade 32-bit 0.6 databases.  Use a 32-bit
        version of your lisp to update to 0.9 and then open that database in your 64-bit
        lisp.  There should be no compatibility problems.  Best to test your application on
        a 32-bit lisp if you can, just to be sure.)</em>

</p>

<h4 class="subsection">3.6.2 Обновление из Elephant 0.5</h4>

<p>Follow the upgrade procedures outlined in the Elephant 0.6.0 INSTALL
file to upgrade your database from 0.5 to 0.6.0.  Then follow the above
procedures for upgrading to 0.9.

   </p>

<p><em>(NOTE: It may not take much work to make 0.9 upgrade directly from 0.5
However there are so few (none?) 0.5 users that it wasn't deemed worth
the work given that there's an upgrade path available.)</em>

</p>

<div class="node">

<p></p>

<hr>
<a name="CL-SQL"></a>
<a name="CL_002dSQL"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#CL_002dSQL-Example">Пример CL-SQL</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Upgrading-Berkeley-DB-Databases">Upgrading Berkeley DB Databases</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation">Инсталяция</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">3.7 CL-SQL</h3>

<p>Первоначально разработанная как интерфейс к системе BerkeleyDB, исходная система 
Elephant была расширена для поддержки использования систем управления реляционными 
базами данных в качестве реализации постоянного хранилища. Эта функциональность зависит 
от интерфейса  CL-SQL Кевина Розенберга, который обеспечивает доступ к большому количеству
реляционных систем.

   </p>

<p>Основная мотивация этого расширения заключается в том, что можно предпочесть 
лицензирование другой системы. Например, на момент написания этой статьи мы считали, 
что нельзя использовать систему BerkeleyDB за общедоступным веб-сайтом 
http://www.sleepycat.com/download/licensinginfo.shtml#redistribute, если только не 
будет выпущено все веб-приложение как Открытый исходный код. 

   </p>

<p>Ни СУБД PostGres, ни SQLite 3, ни сам Elephant не налагают подобных ограничений.

   </p>

<p>Другие причины для использования системы реляционных баз данных могут включать: 
знакомство с этими системами, тот факт, что некоторая часть вашего приложения должна 
использовать действительно реляционные аспекты этих систем, предпочтение инструментов, 
связанных с этими системами, и т. Д.

   </p>

<p>Elephant предоставляет функции для беспрепятственного переноса данных между 
хранилищами данных. Можно довольно легко переместить данные из репозитория 
BerkeleyDB в репозиторий PostGres и наоборот. Это дает, по крайней мере, 
возможность разработки с использованием одного хранилища данных, например BerkeleyDB, 
а затем перейти на Postgres. Можно даже работать одновременно из нескольких репозиториев, 
если для этого есть веская причина. 

   </p>

<p>Реализация SQL использует сериализатор совместно с хранилищем данных BDB, но base64 
кодирует результирующий двоичный поток. Эти данные помещаются в единую таблицу в 
хранилище данных SQL.

   </p>

<p>Все функции, кроме поддержки вложенных транзакций и установки курсора,
 поддерживаемые хранилищем данных BerkeleyDB, поддерживаются хранилищем данных CL-SQL. 
Целостность транзакции CL-SQL при параллельной работе не подвергалась всесторонним 
стресс-тестам.

   </p>

<p>Кроме того, это НЕ тот случай, когда система Elephant в настоящее время 
обеспечивает поддержку транзакций в нескольких репозиториях; она обеспечивает 
поддержку транзакций для каждого репозитория.


   </p>

<p>Бэкэнд PostGres в настоящее время примерно в 5 раз медленнее, чем бэкэнд BerkeleyDB. 
На момент написания этой статьи только PostGres и SqlLite 3 были протестированы как 
серверные части CL-SQL. 

</p>

<div class="node">

<p></p>

<hr>
<a name="CL-SQL-Example"></a>
<a name="CL_002dSQL-Example"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Elephant-on-Windows">Elephant on Windows</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#CL_002dSQL">CL-SQL</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation">Installation</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">3.8 Пример CL-SQL</h3>

<p>Чтобы настроить серверную часть на основе PostGres, вам необходимо

     </p>

<ol type="1" start="1">
<li>Установите postgres и убедитесь, что postmaster запущен. Postgres может быть 
установлен в вашей системе; вы можете использовать менеджер пакетов для его установки 
или установить его напрямую с сайта PostgresSQL (http://www.postgresql.org/).

     </li><li>Создайте базу данных под названием «test» и установите для нее 
разрешения, которые будут доступны для любой спецификации соединения, которую 
вы собираетесь использовать. В тестах используются: 

     <pre class="lisp">          (defvar *testpg-path*
          '(:postgreql "localhost.localdomain" "test" "postgres" ""))
     </pre>

<p>Это означает, что должны быть разрешены соединения с тестовой базой данных, 
пользователь «postgres», без пароля, подключенный с той же машины «localhost.localdomain». 
(В реальном приложении это могло бы быть изменено на что-то более безопасное.) Обычно 
вы редактируете файл: pg_hba.conf, чтобы разрешить различные виды соединений в postgres.

     </p>

</li><li>Обязательно включите сокетное соединение с postgres, когда вы вызываете postmaster.

     </li><li>Убедитесь, что вы можете подключиться к базе данных с этими учетными данными,
запустив: <code> psql -h 127.0.0.1 -U postgres test</code>, прежде чем пытаться подключиться 
к Elephant.

        </li></ol>

<p>Кроме того, вы должны предоставить пользователю postgres практически все права 
на создание/чтение/запись в этой схеме, чтобы он мог создавать необходимые таблицы.

   </p>

<p>При первом открытии контроллера хранилища на основе CL-SQL таблицы, индексы, 
последовательности и т. Д., Необходимые для системы Elephant, будут созданы в 
схеме с именем «test» автоматически. 

</p>

<div class="node">

<p></p>

<hr>
<a name="Elephant-on-Windows"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Test-Suites">Test Suites</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#CL_002dSQL-Example">CL-SQL Example</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation">Installation</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">3.9 Elephant на Windows(кому надо тот переводит)</h3>

<p>The build process on Windows currently only works with GCC under
Cygwin.  The process can be a bit tricky, so if it doesn't work out of
the box or you don't want to install cygwin, we recommend that you
download the DLLs from the Elephant website download page
(<a href="http://www.common-lisp.net/project/elephant/downloads.html'">http://www.common-lisp.net/project/elephant/downloads.html'</a>).

   </p>

<p>Unpack the .zip file into the elephant root directory.  Ensure that
your <code>my-config.sexp</code> file configuration for Windows has
<code>:prebuilt-binaries</code> set to t so it will know to look in
the elephant root during the asdf loading process.

   </p>

<p>For Berkeley DB users we recommend downloading the Windows binary
distribution of Berkeley DB 4.5 to minimize any potential linking
issues.

</p>

<div class="node">

<p></p>

<hr>
<a name="Test-Suites"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Documentation">Documentation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Elephant-on-Windows">Elephant on Windows</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation">Installation</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">3.10 Наборы(сюиты) тестов</h3>

<p>Elephant немного повзрослел за последние год или два. 
Надеюсь, он будет работать "из коробки" для вас


   </p>

<p>Однако, если вы используете реализацию LISP, отличную от той, на которой он 
разработан и поддерживается (см. <a href="#Requirements">Требования</a>), или если у вас 
есть проблема, которая, по вашему мнению, может быть ошибкой, вы можете захотеть запустить 
наборы тестов. Если вы сообщите об ошибке, мы попросим вас запустить эти тесты и сообщить о
результатах. Их запуск при первой установке системы может дать вам чувство уверенности и 
понимания, что стоит потраченных усилий.

   </p>

<p>Есть три файла, в которых выполняются тесты. Вы должны выбрать один из них 
в качестве отправной точки в зависимости от того, какой бэкэнд(ы) вы используете.
Если вы используете BerekeleyDB, используйте 
</p>

<pre class="lisp">     BerkeleyDB-tests.lisp
</pre>

<p>Если вы используете оба, используйте оба из вышеперечисленных, а также используйте: 
</p>

<pre class="lisp">     MigrationTests.lisp
</pre>

<p>Текст этого файла включен сюда, чтобы дать обычному читателю представление о том, 
как в целом можно запустить тесты для elepant: 
</p>

<pre class="lisp">     ;; If you are only using one back-end, you may prefer:
     ;; SQLDB-test.lisp or BerkeleyDB-tests.lisp
     (asdf:operate 'asdf:load-op :elephant)
     (asdf:operate 'asdf:load-op :ele-clsql)
     (asdf:operate 'asdf:load-op :ele-bdb)
     (asdf:operate 'asdf:load-op :ele-sqlite3)

     (asdf:operate 'asdf:load-op :elephant-tests)

     (in-package "ELEPHANT-TESTS")

     ;; Test Postgres backend
     (setq *default-spec* *testpg-spec*)
     (do-backend-tests)

     ;; Test BDB backend
     (setq *default-spec* *testbdb-spec*)
     (do-backend-tests)

     ;; Test SQLite 3
     (setq *default-spec* *testsqlite3-spec*)
     (do-backend-tests)

     ;; Test a Migration of data from BDB to postgres
     (do-migration-tests *testbdb-spec* *testpg-spec*)

     ;; An example usage.
     (open-store *testpg-spec*)
     (add-to-root "x1" "y1")
     (get-from-root "x1")

     (add-to-root "x2" '(a 4 "spud"))
     (get-from-root "x2")
</pre>

<p>Соответствующий тест должен пройти за вас без ошибок. Если вы получаете ошибки, 
вы можете сообщить об этом в списке рассылки <code> elephant-devel at common-lisp.net</code>.


   </p>

<p>Настроить SQLite3 стало еще проще. Установите SQLite3 (мне пришлось использовать 
исходный код, а не бинарную установку, чтобы создать динамические библиотеки).


   </p>

<p>Пример использования SQLLite3: 

</p>

<pre class="lisp">     (asdf:operate 'asdf:load-op :elephant)
     (asdf:operate 'asdf:load-op :ele-clsql)
     (asdf:operate 'asdf:load-op :ele-sqlite3)
     (in-package "ELEPHANT-TESTS")
     (setq *test-path-primary* '(:sqlite3 "testdb"))
     (do-all-tests-spec *test-path-primary*)
</pre>

<p>Файл RUNTESTS.lisp, хотя, возможно, и не совсем то, что вам нужно, 
содержит полезный пример кода.


   </p>

<p>Конечно, вы можете переходить между тремя поддерживаемыми в настоящее 
время стратегиями репозитория в любой комбинации: BDB, Postgresql и SQLite3.

   </p>

<p>По всей вероятности, другие реляционные базы данных было бы очень легко поддерживать, 
но они еще не протестированы. Базовый шаблон спецификаторов «path/пути» следующий 
(cons clsqal-database-type-symbol (normal-clsql-connection-specifier)).

</p>

<div class="node">

<p></p>

<hr>
<a name="Documentation"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Test-Suites">Test Suites</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation">Installation</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">3.11 Документация </h3>

<p>Если вы получаете документацию в виде выпущенного tar-файла, вы, вероятно, 
найдете документацию в форме .html или .pdf в выпуске или можете найти ее на 
веб-сайте Elephant.


   </p>

<p>Если вы хотите скомпилировать документацию самостоятельно, например, 
если вы можете придумать способ улучшить это руководство, вы сделаете 
что-то подобное в оболочке или в приглашении командной строки: 

</p>

<pre class="lisp">     cd doc
     make
     make pdf
</pre>

<p>Этот процесс заполнит каталог «./includes» ссылками, автоматически извлеченными 
из кода списка. В настоящее время этот процесс извлечения строки документации основан 
на SBCL, но с небольшими изменениями скрипты должны работать с другими средами Lisp.


   </p>

<p>Makefile затем скомпилирует исходный текст документации texinfo в файл HTML 
и файл PDF, который останется в каталоге «doc/». HTML-дерево info стиля также 
создается в каталоге «doc/elephant». Это дерево содержит по одному узлу на 
каждый HTML-файл.

   </p>

<p>Не редактируйте ничего в каталогах «doc/elephant» или «doc/includes», 
так как все в этих каталогах создается. Вместо этого отредактируйте файлы 
«.texinfo» в каталоге doc. 

<!-- *-texinfo-*- -->
</p>

<div class="node">

<p></p>

<hr>
<a name="User-Guide"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#User-API-Reference">User API Reference</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installation">Installation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name, next, previous, up -->
<h2 class="chapter">4 Руководство пользователя</h2>

<p><a name="index-User-Guide-5"></a>

</p>

<ul class="menu">
<li><a accesskey="1" href="#The-Store-Controller"> Контроллер хранилища</a>:  за занавесом. 
</li><li><a accesskey="2" href="#Serialization-details">Детали сериализации</a>:   дьявол прячется в деталях.. 
</li><li><a accesskey="3" href="#Persistent-Classes-and-Objects">Постоянные классы и объекты: </a>:  вся грязь на постоянных объектах. 
</li><li><a accesskey="4" href="#Class-Indices">Класс Индексы(Indices)</a>:  подробное обсуждение индексирования объектов. 
</li><li><a accesskey="5" href="#Persistent-Sets">Постоянные наборы(Sets)</a>:   использование коллекции постоянных наборов. 
</li><li><a accesskey="6" href="#Persistent-BTrees">Постоянные BTrees</a>:   использование собственной(нативной) коллекции btree. 
</li><li><a accesskey="7" href="#BTree-Cursors">Курсоры(Cursors) BTree</a>:   низкоуровневый доступ к BTrees. 
</li><li><a accesskey="8" href="#BTree-Indexing">Индексирование BTree</a>:   альтернативные способы ссылаться на объекты в btrees. 
</li><li><a accesskey="9" href="#Index-Cursors">Курсоры индекса</a>:   низкоуровневый доступ к индексам BTree.
</li><li><a href="#Multi_002dthreaded-Applications">Многопоточные приложения</a>:   какие соображения необходимы для безопасной многопоточной работы
</li><li><a href="#Transaction-Details">Детали транзакции</a>:   более глубокое понимание транзакций и избежание ловушек. 
</li><li><a href="#Multi_002drepository-Operation">Работа с несколькими репозиториями</a>:   указание репозиториев. 
</li><li><a href="#Multiple-Processes-and-Distributed-Applications">Множественные процессы и распределенные приложения</a>:   может ли Elephant работать на нескольких процессорах и на нескольких машинах? 
</li><li><a href="#Repository-Migration-and-Upgrade">Миграция и обновление репозитория</a>:   как перемещать объекты из одного репозитория в другой. 
</li><li><a href="#Performance-Tuning">Настройка производительности</a>:   как получить максимальную отдачу от Elephant. 
</li><li><a href="#Garbage-Collection">Сборка мусора</a>:   как восстановить хранилище и OID в долгоживущих репозиториях.  
</li><li><a href="#Berkeley-DB-Data-Store">Хранилище данных Berkeley DB</a>:   команды и проблемы, относящиеся к: хранилищу данных BDB
</li><li><a href="#CLSQL-Data-Store">Хранилище данных CLSQL:</a>:   команды и проблемы, относящиеся к хранилищу данных CLSQL
</li><li><a href="#Postmodern-Data-Store">Постмодернистское хранилище данных</a>
</li><li><a href="#Native-Lisp-Data-Store">Собственное хранилище данных Lisp </a>
</li></ul>

<div class="node">

<p></p>

<hr>
<a name="The-Store-Controller"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Serialization-details">Serialization details</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.1 Контроллер Хранилища</h3>

<p>Экземпляр класса <code>store-controller</code>(контроллера хранилища) обеспечивает
взаимодействие между Lisp и хранилищем данных. Все операции слона выполняются в контексте
контроллера хранилища. Чтобы быть более конкретным, хранилище данных предоставляет подкласс
<code>store-controller</code>(контроллера хранилища), специализированный для этого хранилища
данных. Обычно этот объект содержит указатели на файлы диска, области внешней памяти и 
любую другую необходимую бухгалтерскую информацию для поддержки операций Elephant, таких как 
запись в слоты и операции btree. Хранилище также содержит корневые объекты и другую 
бухгалтерию, общую для всех хранилищ данных.

   </p>

<p>Чтобы получить объект <code>store-controller</code>, вызовите функцию 
<code>open-store</code> со спецификацией контроллера хранилища. Текущие 
форматы спецификации хранилища данных: 

     </p>

<ul>
<li>Berkeley DB: '(:BDB "/path/to/datastore/directory/")
</li><li>CLSQL: '(:CLSQL (&lt;sql-db-name&gt; &lt;sql-connect-command&gt;))
</li></ul>

<p>Допустимые теги базы данных CLSQL для <code>&lt;sql-db-name&gt;</code> <code>
:SQLITE</code> и <code>:POSTGRESQL</code>. <code>&lt;sql-connect-command&gt;</code> - это то, 
что вы должны передать команде <code>connect</code>(подключения) CLSQL.

   </p>

<p>Функция открытия хранилища использует первый символ в спецификации (например 
:BDB или :CLSQL) для отправки создания экземпляра в указанное хранилище данных, 
которое возвращает специализированный экземпляр <code>store-controller</code>(контроллера
 хранилища). Затем <code>open-store</code> инициализирует хранилище, используя внутренний 
вызов  <code>open-controller</code>.

   </p>

<p>Последний шаг <code>open-store</code> - установить глобальную переменную 
<code>*store-controller*</code>. Эта специальная переменная используется в качестве 
значения по умолчанию в необязательных аргументах или аргументах ключевого слова 
для ряда операций, таких как:

     </p>

<ul>
<li><code>make-instance</code>  для постоянных объектов
</li><li><code>get-from-root</code> и <code>add-to-root</code> для доступа к корню хранилища
</li><li><code>make-btree</code> для создания постоянных экземпляров индекса 
</li></ul>

<p>Каждая из этих функций также принимает явный аргумент контроллер хранилища 
для использования в средах с несколькими хранилищами. Обычные приложения должны 
знать только об использовании этого глобального параметра. Для дальнейшего обсуждения 
<code>*store-controller*</code> см. <a href="#Multi_002drepository-Operation">Работа 
с несколькими репозиториями</a>.

   </p>

<p>Кроме того, <code>open-store</code>(открытие хранилища) принимает аргументы 
ключевого слова, определенные хранилищем данных. Например, вы можете принудительно 
запустить восстановление в хранилищах данных Berkeley DB: 

</p>

<pre class="lisp">     (open-store *my-spec* :recover t)
</pre>

<p>В разделах руководства пользователя, посвященных хранилищам данных (
<a href="#Berkeley-DB-Data-Store">Berkeley DB Data Store</a> и 
<a href="#CLSQL-Data-Store">CLSQL Data Store</a>), перечислены все специфические параметры
хранилища данных для различных функций elephant.


   </p>

<p>Когда вы закончите свое приложение, <code>close-store</code> закроет контроллер хранилища.
Несоблюдение этого правила может привести к необходимости запустить восстановление хранилища 
данных во время следующего сеанса. Опять же, см. Соответствующие разделы хранилища данных 
для более подробной информации. 

</p>

<div class="node">

<p></p>

<hr>
<a name="Serialization-details"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Persistent-Classes-and-Objects">Persistent Classes and Objects</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Store-Controller">The Store Controller</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.2  Детали сериализации</h3>

<p>Есть последствия попытки переместить значения из памяти lisp на диск, 
чтобы сохранить их. Первое следствие заключается в том, что нельзя гарантировать 
действительность указателей, и поэтому ссылки на объекты lisp не могут поддерживаться. 
Это очень похоже на проблемы с передачей ссылок в интерфейсах внешних функций. 
Второе и более неприятное ограничение заключается в том, что операции lisp, 
которые фиксируют побочные эффекты для агрегированных объектов, таких как объекты, 
массивы и т. Д., Не могут быть захвачены и реплицированы на дисковое представление. 
Это приводит к очень важному следствию: все объекты lisp хранятся по <em>значению</em>. 
Эта политика имеет ряд последствий, которые подробно описаны ниже. 

</p>

<h4 class="subsection">4.2.1  Ограничения Store-by-Value(сохранения по значению)</h4>

     <ol type="1" start="1">
<li><strong>Идентичность Lisp не может быть сохранена</strong>. 
      Поскольку это хранилище, которое сохраняется при вызовах Lisp, вероятно, 
это даже не имеет смысла. Однако, если вы получите объект из индекса, сохраните его 
в переменной lisp, а затем получите снова - они не будут eq: 

     <pre class="lisp">          (setq foo (cons nil nil))
          =&gt; (NIL)
          (add-to-root "my key" foo)
          =&gt; (NIL)
          (add-to-root "my other key" foo)
          =&gt; (NIL)
          (eq (get-from-root "my key")
                (get-from-root "my other key"))
          =&gt; NIL
     </pre>
     </li><li><strong>Вложенные агрегаты рекурсивно сериализуются в один буфер</strong>. 
Если вы храните набор объектов в хеш-таблице, вы пытаетесь сохранить хеш-таблицу, 
все эти объекты будут храниться в одном большом двоичном буфере с хеш-ключами. 
Это верно для всех агрегатов, которые могут хранить тип T (cons, массив, 
стандартный объект и т. Д.).

     </li><li><strong>Циркулярные(замыкающие список в кольцо) ссылки</strong>. 
Одно из преимуществ сериализатора заключается в том, что процесс рекурсивной сериализации 
не приводит к бесконечным циклам при обнаружении циклических ссылок между агрегатными типами. 
Это достигается путем присвоения идентификатора любому неатомарному объекту и сохранения
сопоставления между ранее сериализованными объектами и этими идентификаторами. Это же 
отображение используется для восстановления ссылок в памяти lisp при десериализации, 
так что исходная структура воспроизводится должным образом. 

     </li><li><strong>Ограничения по хранению</strong>. 
Сериализатор последовательно записывает в непрерывный внешний массив байтов перед 
передачей этого массива в API данного хранилища данных. Существуют практические ограничения 
на размер внешнего буфера, который может выделить Lisp (обычно где-то порядка 10–100 МБ 
из-за фрагментации адресного пространства). Более того, у большинства хранилищ данных 
будет практический предел размера транзакции или размера ключа или значения, которое они 
будут хранить. Любое из этих соображений должно побудить вас спланировать ограничение 
размера объектов, сериализуемых на диск. Хорошее практическое правило - не превышать 
нескольких мегабайт. В прошлом мы успешно сериализовали массивы размером более 100 МБ, 
но не проверяли устойчивость этих больших значений с течением времени. 

     </li><li><strong>Мутировавшая субструктура не сохраняется. </strong>.

     <pre class="lisp">          (setf (car foo) T)
          =&gt; T
          (get-from-root "my key")
          =&gt; (NIL)
     </pre>

<p>Это повлияет на все типы агрегатов: объекты, conses, хеш-таблицы и так далее. 
(Вы, конечно, можете вручную повторно сохранить списки(conses).) В этом смысле elephant не
предоставляет постоянные коллекции автоматически. Если вы хотите сохранить каждый доступ, 
вы должны использовать постоянные наборы (см. <a href="#Persistent-Sets">Постоянные 
Sets(наборы)</a>) или BTrees (см. <a href="#Persistent-BTrees">Постоянные BTrees</a>).

     </p>

</li><li><strong>Сериализация и десериализация могут быть дорогостоящими</strong>. 
Хотя сериализация происходит довольно быстро, но хранить большие объекты оптом все равно 
дорого. Кроме того, поскольку идентичность объекта невозможно поддерживать, десериализация 
должна повторно согласовывать или перераспределять весь объект каждый раз, когда 
увеличивается количество сборщиков мусора, которые выполняет система. Это стремительное
распределение противоречит тому, как большинство людей хотят использовать базу данных: 
одна из причин использования базы данных - это то, что ваши объекты не могут поместиться 
в основную память сразу. 

     </li><li><strong>Конфликты слияния в сильно многопроцессорных/многопоточных ситуациях</strong>. 
Это общая проблема чтения-изменения-записи во всех базах данных. Подробнее об этом мы 
поговорим в разделе <a href="#Transaction-Details">Детали транзакции</a>.

     </li><li><strong>Порядок байтов</strong>. 
      Примитивные элементы, такие как целые числа, записываются на диск в собственном 
порядке байтов машины, на которой выполняется lisp. Это означает, что машины с прямым 
порядком(little endian) байтов не могут читать значения, записанные машинами с 
обратным порядком(big endian) байтов, и наоборот.

     </li><li><strong>Коды Юникода и сериализованные строки</strong>. 
      Символьные знаки и строки, хранящиеся на диске, могут хранить и восстанавливать 
коды символьных знаков lisp, которые реализуют unicode, но карты символьных знаков - 
это карты символьных знаков lisp (созданные с помощью <code>char-code</code>), а 
не строгие коды unicode, поэтому lisp может быть не в состоянии взаимодействовать с 
символьными знаками, если только они не имеют идентичные карты кодов символьных знаков
для наборов символьных знаков, которые вы читаете и пишете. Все стандартные строки ASCII 
должны быть переносимыми. Вот что мы знаем о конкретных лиспах, но это не следует 
воспринимать как евангелие.
          <ul>
<li>SBCL: в версиях с функцией :sb-unicode (после 0.8.17) <code>char-code</code> создает
правильные коды Unicode
</li><li>Allegro: в интернациональной версии <code>char-code</code> создает правильные коды
Unicode для кодов  &lt; 2^16
</li><li>OpenMCL: OpenMCL 1. поддерживает юникод, мы не уверены в более ранних версиях
</li><li>Lispworks: Насколько нам известно, Lispworks 5 не производит правильных символьных
знаков Unicode.  
(<em>Это может быть исправлено по запросу, если пользователи просят об этом и готовы платить з
а снижение производительности</em>)
</li></ul>

     </li></ol>

<h4 class="subsection">4.2.2 Атомарные типы</h4>

<p>Атомарные типы не имеют рекурсивной подструктуры. То есть они не могут 
содержать произвольные объекты и имеют ограниченный размер. (Bignums являются 
исключением, но они имеют предсказуемую структуру и не могут ссылаться или иным 
образом инкапсулировать другие объекты). Ниже приводится список атомов и обсуждение 
того, как они сериализуются. 

     </p>

<ul>
<li><code>nil</code>:
     nil имеет собственный специальный тег в сериализаторе, поэтому его легко 
идентифицировать. <code>nil</code> - неудобное значение, так как оно также является логическим.
Логическое значение <code>t</code> сохраняется как символ 'T. 
</li><li><strong>fixnums</strong>:
      сериализатор будет хранить как 32-битные, так и 64-битные фиксированные числа. Оба 
типа фиксированных номеров читаются 32-битным или 64-битным лиспом, но 64-битные фиксированные
числа записываются только в том случае, если базовый лисп поддерживает fixnums между 
32 и 64 битами.
</li><li><strong>bignums</strong>:
      Bignum разбиваются на последовательность chunks(кусков) фиксированного размера и 
собираются путем маскировки слов на bignum. Это ужасно дорого, но всегда правильно и 
полностью портируемо. 
</li><li><strong>small-float</strong>:
      поддерживается только в Lispworks 5, где тип <code>small-float</code> не эквивалентен 
типу <code>single-float</code>, как на всех других поддерживаемых платформах. Записывается 
на диск и десериализуется в виде одного числа с плавающей запятой, поэтому любая экономия 
памяти при использовании <code>small-float</code> теряется. 
</li><li><strong>single-float</strong>:
      32-битные числа с плавающей запятой
</li><li><strong>double-float</strong>:
      64-битные числа с плавающей запятой
</li><li><strong>rational</strong>:
      рациональное - это просто отношение двух целых чисел, хранящихся как fixnums 
или bignums. 
</li><li><strong>complex</strong>:
      комплексное число - это пара значений с плавающей запятой, рациональных или целых чисел.
</li><li><strong>char</strong>:
      Автономные символьные числа представлены своим char-кодом и хранятся в 32-битном 
формате, чтобы гарантировать, что все лиспы сохраняют правильно. 
</li><li><strong>strings</strong>:
      строки могут быть представлены как 8-, 16- или 32-битные последовательности в 
зависимости от размеров символьных знаков, используемых в базовом lisp. Поскольку строки 
могут занимать такой большой процент дискового пространства, Elephant использует особый метод
кодирования строк. Строки преобразуются из их представления в памяти с помощью использования
<code>char-code</code>. Размер первого символьного знака определяет ширину слова, используемую 
для кодирования. Если символьный знак нарушает ширину слова, кодировка строки прерывается и выбирается следующая большая ширина. Обоснованием здесь является то, что многие строки состоят
из латинских символов с кодами меньше 256. Строки, хранящиеся в других наборах знаков, 
обычно имеют коды &gt; 256. Поэтому вполне вероятно, что первый символьный знак правильно
определит размер слова в строке. (<em>По запросу мы можем легко сделать опцию конфигурации, 
чтобы исправить ширину слова для кодирования</em>)
</li><li><strong>pathname</strong>:
      имя пути - это просто <code>namestring</code>(строка имени) объекта пути, хранящегося в
виде строки. Объект пути восстанавливается из строки имен(namestring) с помощью 
<code>parse-namestring</code> во время десериализации. 
</li><li><strong>symbol</strong>:
      символы хранятся в виде двух строк, имени пакета и имени символа в этом пакете. 
При десериализации ищется целевой пакет, и символ интернируется в этом пакете. 
</li></ul>

<h4 class="subsection">4.2.3 Агрегатные типы</h4>

<p>Следующий список это  <em>агрегатные/aggregate</em> типы. Это означает, что элементы
этого типа могут содержать ссылки на элементы типа <code>T</code>.  Теоретически это
означает, что при сохранении агрегированного типа, который ссылается на другие объекты, 
на диск, можно скопировать любой достижимый объект!  Это прямое и ужасное следствие
ограничения "хранения по значению/store-by-value". 
(см. <a href="#Persistent-Classes-and-Objects">Постоянные Классы и Объекты</a>, чтобы узнать,
как спроектировать ограничение на хранение по значению).

   </p>

<p>Этот список описывает, как агрегаты обрабатываются сериализатором.

     </p>

<ul>
<li><strong>cons</strong>:
      Cons просто хранится как cons запись, содержащая два вложенных элемента.
Линейные списки не обрабатываются сериализатором, как то специально (т.е. без cdr-кодирования). 
</li><li><strong>array</strong>:
      Массивы хранятся как последовательности вложенных сериализованных элементов.
Параметры массива также сохраняются, так что массивы с указателями заполнения, 
регулируемые массивы могут быть сохранены и восстановлены.  Единственные массивы,
которые не могут быть воспроизведены, - это смещенные(displaced) массивы, которые
копируются по значению и восстанавливаются как стандартные массивы во время десериалзации. 
</li><li><strong>hash-table</strong>:
      Хеш-таблицы хранятся как последовательность пар ключ-значение, где ключ и значение 
могут быть любым сериализуемым значением. При десериализации восстановленные значения ключа
и значения постепенно записываются в хеш-таблицу. Хеш-таблица запоминает тест, размер повторного
хеширования(rehash size) и порог, а также общее количество.  Окончательный размер новой 
хеш-таблицы устанавливается в <code>(* (/ size reshash-threshold) rehash-size)</code>. 
</li><li><strong>struct</strong>:
      Объект структуры сериализуется с использованием метапротокола. Каждый слот, к которому
привязано значение, сериализуется путем последовательной сериализации имени слота и значения.
Базовый лисп должен поддерживать метод <code>struct-constructor</code>, чтобы можно было
создать новый пустой экземпляр структуры и затем заполнить его сохраненными ключами и
значениями. 
</li><li><strong>object</strong>:
      Экземпляры подклассов стандартного объекта хранятся почти так же, как и структуры.
Тип объекта сохраняется, а слоты объектов со связанными значениями сериализуются как пары
имя-значение. Чтобы прочитать объект этого типа, в образе лисп должен быть определен
класс, и в нем должны быть по крайней мере слоты, которые хранятся на диске. Не существует
хорошего метода эволюции схемы(переопределения объектов, чтобы у них было меньше слотов)
обычных классов. 
</li></ul>

<p>Последнее стратегическое соображение заключается в том, планируете ли вы
совместное использование двоичной базы данных между машинами или между
разными платформами на одной машине. Сегодня это практически возможно, но
есть некоторые ограничения. В разделе <a href="#Repository-Migration-and-Upgrade">Миграция
и обновления репозитория</a>
мы обсудим возможные способы миграции существующей базы данных между платформами и
лиспами.

</p>

<div class="node">

<p></p>

<hr>
<a name="Persistent-Classes-and-Objects"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Class-Indices">Class Indices</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Serialization-details">Serialization details</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.3 Постоянные классы и объекты</h3>

<p>Постоянные классы - это экземпляры метакласса <code>persistent-metaclass</code>.  
Все постоянные классы отслеживают, что представляют из себя слоты: <code>:persistent</code>,
<code>:transient</code> и/или <code>:indexed</code> и используются в качестве специализааций
в протоколах обеспечания постоянства мета-объектов(инициализация слотов, доступ к слотам(slot-access) и т.д.).

   </p>

<p>Все постоянные классы создают объекты, которые наследуются от
класса <code>persistent</code>(постоянного).  Класс <code>persistent</code>
предоставляет два слота, которые содержат уникальный идентификатор объекта - (oid) 
и ссылку на специфицированный  <code>store-controller</code>(контроллер хранилища),
с которой они связаны. 
Постоянные слоты не занимают места в памяти, вместо этого протокол доступа к слотам
<code>persistent-metaclass</code>(постоянного метакласса) перенаправляет доступ к слотам
в вызовы/обращения к контроллеру хранилища.  Обычно базовое хранилище данных затем
выполняет необходимую сериализацию, десериализацию для чтения и записи данных на диск.

   </p>

<p>Когда ссылка на сам экземпляр <code>persistent</code> записывается в базу данных,
например как ключи или значение в <code>btree</code>, сохраняется только
уникальный идентификатор(ID) и класс экземпляра. При чтении экземпляр постоянного
объекта создается заново (см. ниже).  Это означает, что сериализация постоянных объектов
чрезвычайно дешева по сравнению со стандартными объектами. В подразделе о
создании экземпляра ниже более подробно обсуждается жизненный цикл постоянного объекта.

</p>

<h4 class="subsection">4.3.1 Определение постоянного класса</h4>

<p>Чтобы создать постоянные классы, пользователю необходимо указать постоянный 
метакласс - <code>persistent-metaclass</code> для класса initarg <code>:metaclass</code>.

</p>

<pre class="lisp">     (defclass my-pclass ()
        ((slot1 :accessor slot1 :initarg :slot1 :initform 1))
        (:metaclass persistent-metaclass))
</pre>

<p>Единственное различие между синтаксисом определений классов стандартных и 
постоянных  - это возможность указать политику хранения слотов и политику индекса. 
Политики хранения значений слота задаются логическим аргументом для initargs слота: 
<code>:persistent</code>, <code>:transient</code> и <code>:indexed</code>. 
Слоты:  по умолчанию <code>:persistent</code> и не <code>:indexed</code>.

   </p>

<p>Макрос <code>defpclass</code> предоставляется для удобства, чтобы скрыть 
параметр слота <code>:metaclass</code>. 

</p>

<pre class="lisp">     (defpclass my-pclass ()
        ((pslot1 :accessor pslot1 :initarg :pslot1 :initform 'one)
         (pslot2 :accessor pslot2 :initarg :pslot2 :initform 'two
                 :persistent t)
         (tslot1 :accessor tslot1 :initarg :tslot1 :initform 'three
                 :transient t)))
</pre>

<p>В приведенном выше определении класс <code>my-pclass</code> является 
экземпляром метакласса <code>persistent-metaclass</code>. Согласно этому 
определению <code>pslot1</code> и <code>pslot2</code> являются постоянными, 
а <code>tslot1</code> - временными(transient) и хранятся в памяти.

   </p>

<p>Значение класса памяти слота очевидное. Постоянные записи в слоты 
надежно сохраняются на диск и чтения выполняются с диска и могут быть 
частью транзакции, соответствующей ACID. Временные слоты инициализируются при 
создании экземпляра в соответствии с initforms или initargs. Значения 
временных слотов никогда не сохраняются и не загружаются из базы данных, 
и доступ к ним не может быть защищен транзакциями. (Вместо этого потребуется 
обычная многопроцессная синхронизация).

   </p>

<p>Параметр <code>:index</code> сообщает Elephant, следует ли поддерживать 
инвертированный индекс, который сопоставляет значения слотов их 
родительским объектам. Поведение индексированных классов и слотов классов 
подробно обсуждается в разделе <a href="#Class-Indices">Индексные Классы</a>.

   </p>

<p>Протоколы метаобъектов персистентных классов изменены с помощью специализаций 
на <code>persistent-metaclass</code>. Эти специализации включают создание 
специальных метаобъектов слотов: <code>transient-slot-definition</code>, 
<code>persistent-slot-definition</code>, а также прямые и эффективные версии 
каждого из них. Для поклонников MOP основные моменты новых протоколов инициализации 
классов заключаются в следующем:

     </p>

<ul>
<li><code>shared-initialize :around</code>  гарантирует, что этот класс наследуется 
      от <code>persistent-object</code> и <code>persistent</code>, если он еще не 
      наследуется, и что опция класса <code>:index</code> приводит к индексации 
      индексов класса;.
</li><li><code>direct-slot-initialization-class</code> возвращает соответствующий 
      метаобъект слота на основе значений ключевых слов <code>:transient</code> и
      <code>:persistent</code> определения слота. Он также выполняет простую проверку 
      ошибок на недопустимые комбинации, например, indexed transient(проиндексированные
      не постоянные слоты. 
</li><li><code>effective-slot-definition-class</code> выполняет ту же роль, что и выше 
      для эффективных слотов.
</li><li><code>slot-definition-allocation</code> возвращает <code>:database</code>  выделенную
      для постоянных определений слотов, поэтому базовый lisp не будет выделять хранилище
      экземпляров или классов при некоторых lisp.
</li><li><code>compute-effective-slot-definition-initargs</code> выполняет некоторую проверку
      ошибок, чтобы гарантировать, что подкласс не пытается сделать унаследованный постоянный
      временный слот переходным(не постоянным). 
</li><li><code>finalize-inheritance</code>  вызывается перед созданием первого экземпляра, 
      чтобы завершить список постоянных слотов для учета любых классов с прямой ссылкой в ​​
      списке наследования. Аналогичным образом вычисляется список проиндексированных слото в. 
      Эта функция также вызывается кодом индексации класса, если выполняются какие-либо вызовы,
      зависящие от знания того, какие слоты индексируются. 
</li></ul>

<p>Повторная инициализация обсуждается в разделе о переопределении класса. 

</p>

<h4 class="subsection">4.3.2 Instance Creation</h4>

<p>Persistent objects are created just like standard objects, with a call
to <code>make-instance</code>.  Initforms and slot initargs behave as the
user expects.  The call to <code>make-instance</code> of a persistent class
will fail unless there is a default <code>store-controller</code> instance
in the variable <code>*store-controller*</code> or the <code>:sc</code> keyword
argument is provided a valid store controller object.  The store
controller is required to provide a unique object id, initialize the
specification pointer of the instance and to store the values of any
initialized slots.  The initialization process is as follows:

     </p>

<ul>
<li><code>initialize-instance :before</code> is called to initialize the
      <code>oid</code> slot and the data store specification slot <code>dbcn-spc-pst</code>. 
      The oid is set by the argument <code>:from-oid</code> or by calling the store
      controller for a new oid. 
</li><li><code>shared-initialize :around</code> is called to ensure that the underlying
      lisp does not bypass the metaobject protocol during slot
      initialization by manually initializing the persistent slots
      and passing the transient slots to the underlying lisp. 
      Finally it adds the instance to the class index so that any inverted indicies
      are updated appropriately. 
</li></ul>

<p>Persistent slots are initialized only under the following conditions:

     </p>

<ul>
<li>An initarg is provided to <code>make-instance</code>
</li><li>The database slot value is unbound, an initform exists and from-oid was not specified
</li></ul>

<p>After initialization the persistent instance is added to its host
store controller's object cache.  This cache is a weak hash table that
maps oids to object instances.  So after initialization the following
state has been created:

     </p>

<ul>
<li><strong>Placeholder Instance:</strong> An instance of the class is in memory, containing storage for
      the oid, the specification reference, lisp instance data and any
  transient slot values.  We call this the placeholder instance which
  mediates access to persistent values, but does not itself persist. 
</li><li><strong>Cached Reference:</strong> A weak reference to the instance is in the store controller object cache
</li><li><strong>Memory References:</strong> A normal reference to the instance is (maybe) retained by the caller of
      <code>make-instance</code>. 
</li><li><strong>Database Slot Values:</strong> The data store contains the persistent slot values that were initialized,
      indexed by the object id and slot name. 
</li><li><strong>Database References:</strong> If the resulting placeholder instance was written to a persistent slot,
      added to a btree or the class is indexed, a <strong>reference</strong>
to the instance was written into the data store.  Today this reference
consists of an oid and a class name.  If this reference is reachable,
then the persistent object can be reconstructed using the
<code>:from-oid</code> argument. 
</li></ul>

<p>If you mnanually create an object using an OID which already exists in
the database, <code>initargs</code> to <code>make-instance</code> take precedence
over existing values in the database, which in turn take precedence
over any <code>initforms</code> defined in the class.

</p>

<h4 class="subsection">4.3.3 Persistent Instance Lifecycle</h4>

<p>The distributed nature of persistent instance storage results in some
interesting behaviors, especially with respect to transient slots. 
The prior section detailed the state of the system after the original
initialization of an object.  The object can then be in a number of
different states:

     </p>

<ul>
<li><strong>Resident:</strong> The canonical state of an in-use persistent
      object as described in the initialization section above. 
</li><li><strong>Unreferenced, Unreclaimed:</strong> All memory references to the
      object have been dropped but the placeholder instance has not yet
      been garbage collected.  The weak pointer still exists in the cache. 
      If a database reference is fetched from the data store, the cached
      value will be used. 
</li><li><strong>Non-resident:</strong> The object only exists as reachable database
      references and slot values.  This is the state after garbage collection
      of the placeholder instance. 
</li><li><strong>Recreated:</strong> An intermediary state where a non resident object
      is fetched from the data store and its placeholder object must be
      recreated prior to the object enter the resident state. 
</li></ul>

<p>The garbage collection of the placeholder instance is an important
feature.  This means that we can have more objects in our system than
are currently resident in memory.  If this were not the case, what
would be the point of an object database?

   </p>

<p>The recreated state deserves to be discussed in more detail.  We
learned earlier that the database reference contains the oid and class
of the object, and of course we know the store-controller the
reference is stored into<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>, so this information is
sufficient to reconstruct the placeholder instance.

   </p>

<p>When the reference is deserialized, its oid is used to look up the
object in the store controller's object cache.  If this fails, then
the instance is created with a call much like this:

</p>

<pre class="lisp">     (make-instance 'pclass :from-oid 2000 :sc *store-controller*)
</pre>

<p>The <code>:from-oid</code> argument to <code>make-instance</code> overrides some
of the normal make-instance behavior by inhibiting all initform
initialization as the object's slots are assumed to be properly
initialized from the original call to <code>make-instance</code>.

</p>

<h4 class="subsection">4.3.4 Using Transient Slots</h4>

<p>What about transient slots?  Transients slots are tied to the
placeholder object where their storage is allocated.  While the
persistent slots are permanently stored in the data store, transient
slots can be garbage collected when all memory references have been
dropped, even if database references exist.

   </p>

<p>After collection, if you retrieve an object from the store, its
transient slots will be reset to the slot initforms from the class
definition.  You can only reliably use <code>:initargs</code> to initialize
transient or persistent slots during the initial call to
<code>make-instance</code> or when manually creating the instance from an oid.

   </p>

<p>Here is an example illustrating the ephemeral nature of transient
slots:

</p>

<pre class="lisp">     (setf pobj1 (make-instance 'my-pclass :pslot1 1 :tslot3 3))
     =&gt; #&lt;MY-PCLASS&gt;

     (pslot1 pobj1) =&gt; 1
     (pslot2 pobj1) =&gt; 'two
     (tslot1 pobj1) =&gt; 3

     (add-to-root 'pobj1 pobj1)

     (setf pobj2 (get-from-root 'pobj1))
     =&gt; #&lt;MY-PCLASS&gt;

     (pslot1 pobj2) =&gt; 1
     (pslot2 pobj2) =&gt; 'two
     (tslot1 pobj2) =&gt; 3

     (setf pobj1 nil)
     (setf pobj2 nil)
     (gc)

     (setf pobj3 (get-from-root 'pobj1))
     (pslot1 pobj2) =&gt; 1
     (pslot2 pobj2) =&gt; 'two
     (tslot1 pobj2) =&gt; 'three
</pre>

<p>The implications of this behavior is that you need to think carefully
about how to use employ transient values.  Essentially you cannot make
assumptions about the state of transient values in objects loaded from
the store unless you know that they were loaded at some point in time
and cannot be GC'ed (i.e. they are stored in a list or hash table).

   </p>

<p>A good policy is to initialize transient values using an <code>:after</code>
method on <code>initialize-instance</code>.  This allows you to initialize
transient values using either system defaults or persistent slot
values.  That way you can ensure that the transient slots are always
in a consistent state when accessed by the application, regardless of
when the placeholder object was recreated.

   </p>

<p>In general, transient slots are a good place for intermediate values
in a computation or to cache frequently read items to avoid
deserialization overhead.  <code>indexed-btree</code> is an example of this
approach, an in-memory hash is cached in the transient slot for reads
and writes are mirrored to a serialized hash in a persistent slot. 
The <code>:after</code> method just copies the persistent hash value to the
transient slot.

</p>

<h4 class="subsection">4.3.5 Using Persistent Slots</h4>

<p>Persistent slot use is straightforward.  You can read from them, write
to them or make them unbound.  Remember that every access goes to the
data store.  This makes reads relatively expensive as they may result
in a disk seek.  Writes can be doubly expensive, especially outside a
transaction, as the write will result in a synchronous disk synch
operation.

   </p>

<p>Reads and writes require the home store controller to be valid and
open.  The placeholder object's specification pointer is used to
retrieve the <code>store-controller</code> object.  If this object is closed
or mising, the system will give you a restart option to reopen the
controller and continue.

   </p>

<p>Persistent slot behavior is implemented by overloading the relevant
MOP functions controlling slot access:

     </p>

<ul>
<li><code>slot-value-using-class</code>
</li><li><code>(setf slot-value-using-class)</code>
</li><li><code>slot-boundp-using-class</code>
</li><li><code>slot-makunbound-using-class</code>
</li></ul>

<p>Each of these functions retrieves the home store-controller for the
instance and then calls a method specialized on the class of that
store controller.  This method is responsible for mapping the oid and
slotname of the slot access to the appropriate value in the data
store.

</p>

<h4 class="subsection">4.3.6 Class Redefinition</h4>

<p>Class redefinition is problematic in the current (0.9) version of
Elephant.  The usual CLOS mechanisms are properly implemented, but
updating instances will only work for those instances that are in
memory at the time.  Instances that are non-resident will not be
updated.  This is usually not as big a problem as it seems, because
the slot values are stored independently.  An outline of the update
procedure follows:

   </p>

<p>The function <code>update-instance-for-redefined-class</code> is called by
CLOS whenever <code>defclass</code> is re-evaluated and results in a change
in the list of slots.

   </p>

<p>For transient slots the behavior is the same as it is in CLOS for
all in-memory slots.

     </p>

<ul>
<li>Added slots: are added to the object and their initforms
      called just as if they were created without initargs
</li><li>Discarded slots: are dropped and their values lost
</li></ul>

<p>Persistent slots have a slightly different behavior, as only resident
(those with valid placeholder objects) objects are updated.

     </p>

<ul>
<li>Added slots (resident): are added to the object and the initforms
      are called only on in-memory objects, as in an empty call to
      <code>make-instance</code>
</li><li>Added slots (non-resident): the added slots will have unbound values
</li><li>Discarded slots (resident): slots are dropped from the class and become
      inaccessible, but their values are not deleted from the database.  This
      is a precautionary measure as losing persistent data because of an
      accidental re-evaluation while editing a defclass could be painful.  If
      you add the slot back, the original value will be accessible regardless of
      the initform. 
</li><li>Discarded slots (non-resident): This has the same behavior as resident objects,
      as no side effects are made on the objects or their slots
</li></ul>

<p>There are additional considerations for matching class indexing
options in the class object to the actual indices in the database. 
The following section will discuss synchronizing these if they
diverge.

   </p>

<p><em>(Note: release 0.9.1 should fix this by providing an oid-&gt;class map that allows
the system to cheaply iterate over all objects and update them appropriately.  This
hasn't been done yet due to performance implications.  See Trac system for the appropriate
tickets)</em>

</p>

<h4 class="subsection">4.3.7 Support for <code>change-class</code></h4>

<p>Elephant also supports the <code>change-class</code> by overloading
<code>update-instance-for-different-class</code>.  The handling of slots in
this case is identical to the class redefinition above.  Persistent
and transient slot values are retained if their name matches a
slotname in the new class and initforms are called on newly added
slots.  Valid initargs for any slot will override this default behavior
and set the slot value to the initarg value.

   </p>

<p>Because the instance is guaranteed to be resident, the operation has none of the
resident/non-resident conflicts above.

   </p>

<p>Change class cannot convert between persistent and non-persistent classes and will
flag an error if you try to do so.  <em>(Note: this could be implemented in the
future if users request it)</em>

</p>

<div class="node">

<p></p>

<hr>
<a name="Class-Indices"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Persistent-Sets">Persistent Sets</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Persistent-Classes-and-Objects">Persistent Classes and Objects</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.4 Class Indices</h3>

<p>You can enable/disable class indexing for an entire class.  When you disable
indexing all references to instances of that class are lost.  If you re-enable
class indexing only newly created classes will be stored in the class index. 
You can manually restore them by using <code>find-class-index</code> to get the
clas index BTree if you have an alternate in-memory index.

   </p>

<p>You can add/remove a secondary index for a slot.  So long as the class index
remains, this can be done multiple times without losing any data.

   </p>

<p>There is also a facility for defining 'derived slots'.  These can be non-slot
parameters which are a function of the class's persistent slot values.  For
example you can use an index to keep an alternate representation available
for fast indexing.  If an object has an x,y coordinate, you could define a
derived index for r,theta which stored references in polar coordinates. 
These would be ordered so you could iterate over a class-index to get objects
in order of increasing radius from the origin or over a range of theta.

   </p>

<p>Beware, however, that derived indices have to compute their result every
time you update any persistent instance's slot.  This is because there is
no way to know which persistent slots the derived index value(s) depends
on.  Thus there is a fairly significant computational cost to objects
with frequent updates having derived indices.  The storage cost, however,
may be less as all that is added is the index value and an OID reference
into the class index.  To add a slot value you add a serialized
OID+class-ref+slotname to index value which can be much larger if you
use long slotnames and package names and unicode.

   </p>

<p>Thus, the question of if and how a given class should be indexed is
very flexible and dynamic, and does not need to be determined at the
beginning of your development.  This represents the ability to late bind
the decision of what to index.

   </p>

<p>In general, there is always a tradeoff: an indexed slot increases storage
associated with that slot and slows down write operations.  Reads however remain
as fast as for unindexed persistent slots.  The Elephant system
makes it simple to choose where and when one wants to utilize this tradeoff.

   </p>

<p>Finally, that file <samp><span class="file">src/elephant/classindex-utils.lisp</span></samp> documents
tools for handling class redefinitions and the policy that should be
used for synchronizing the classes with the database.  This process is
somewhat user customizable; documentation for this exists in the source
file referenced above.

</p>

<h4 class="subsection">4.4.1 Synchronizing Classes and Data Stores</h4>

<p>Sometimes you may change a defclass form and then connect to a
database with instances that do not match the current defclass
definition.  Because of the defclass behavior above, there is no need
to detect this case as the behavior will be as if all instances were
non-resident at redefinition time.  However, this is an issue for
indexed classes as the cost of indexing is high.  There is a
synchronization policy which updates either the class or the online
class indexing mechanism at the time you try to perform an index
operation (i.e. when <code>find-class-index</code> is called).

   </p>

<p>A policy is selected by setting the value of
<code>*default-indexed-class-synch-policy*</code> with the appropriate
policy:

     </p>

<ul>
<li>:class - The class is the master, and indices are deleted for any slots
               that are no longer indexed
</li><li>:db - The database is the master and the class indexing annotations are
            updated so that the slots that satisfy <code>class-indexedp-by-name</code>
            are isomorphic to the existing indices in the db. 
</li><li>:union - This does what you would expect, updates the class to match any
               existing indices and creates new indices. 
</li></ul>

<p>Derived slots can be problematic as they may depend on slot values
that no longer exist in the changed defclass.  This will result in an
error, so for now you will have to manage any mismatches such as this
yourself.

   </p>

<p><em>Note: release 0.9.1 should fix both mismatches and performance issues related
to derived indices by allowing the user to provide hints as to which slot values the
index depends.  This will allow the system to only update when the appropriate slots
change and to delete or inhibit derived indicies when slots are deleted.  We will also
improve error handling for this case, so you can delete the derived index and continue
performing the write to a persistent object that flagged the error.</em>

</p>

<div class="node">

<p></p>

<hr>
<a name="Persistent-Sets"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Persistent-BTrees">Persistent BTrees</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Class-Indices">Class Indices</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.5 Persistent Sets</h3>

<p>Persistent sets are fairly straightforward and are well-introduced by
the tutorial, please review the tutorial or read the reference section
for persistent sets.

</p>

<div class="node">

<p></p>

<hr>
<a name="Persistent-BTrees"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#BTree-Cursors">BTree Cursors</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Persistent-Sets">Persistent Sets</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.6 Persistent BTrees</h3>

<p>A BTree is a data structure designed for on-disk databases.  It's
design goal is to minimize the number of disk seeks while traversing
the tree structure.  In contrast to a binary tree, the BTree exploits
the properties of memory/disk data heirarchies.  Disk seeks are
expensive while loading large blocks of data is relatively inexpensive
and in-memory scanning of a block of memory is much cheaper than a
disk seek.  This means a few, large nodes containing many keys is
a more balanced data structure than

   </p>

<p>The BTree, or derivatives, are the basis of most record-oriented
database including SQL servers, Berkeley DB and many others.  Elephant
directly exposes the BTree structure to the user so the user can
decide how best to manage and traverse it.  Many of Elephant's other
facilities, such as the class indexing discussed above, are
implemented on top of the BTree.

   </p>

<p>The basic interface to the BTree is via the <code>get-value</code> method. 
Both the key and the value are serialized and then the BTree is
traversed according to the sorted order of the key and the value
inserted in its sorted order.  Insertion, access and deletion (via
<code>remove-kv</code>) are all O(log N) complexity operations.

   </p>

<p>Sorting in BTrees requires some discussion.  The sorting constraints
on btrees are dictated by the original implementation on Berkeley DB. 
The Berkeley DB data store sorts keys based on their serialized
representation.  The CLSQL implementation has to sort based on the
deserialized lisp value, so sorted traversals require reading all the
objects into memory.  This places some limitations on systems that
exploit the CLSQL implementation (see <a href="#CLSQL-Data-Store">CLSQL Data Store</a> for more
information).

   </p>

<p>Sorting is done first by primitive type (string, standard-class,
array, etc) and then by value within that type.  The type order and
internal sorting constraint is:

     </p>

<ol type="1" start="1">
<li>Numbers.  All numbers are sorted as a class by their numeric value.  Effectively
all numbers are coerced into a double float and sorted relative to each other. 
</li><li>Strings.  Because the serializer stores strings in variable 
width structures.  Each width type is sorted separately, then sorted 
lexically.  (NOTE: This should get fixed for 1.0.  Strings should be 
sorted together)
</li><li>Pathnames.  Sorted by their string radix then lexically. 
</li><li>Symbols.  Sorted by string radix, then lexically. 
</li><li>Aggregates.  Sorted by type in the following order, then 
arbitrarily internally.  Persistent instance references, cons, 
hash-table, standard objects, arrays, structs and then nil.
        </li></ol>

<p>String comparisons are case insensitive today, so <code>"Adam" =
"adam" &gt; "Steve" </code>.  When unicode support is finalized, comparisons
will be case sensitive.

   </p>

<p>Like persistent sets, BTrees are not garbage collected so to recover
the storage of a BTree, just run the function <code>drop-btree</code> to
delete all the key-value pairs and return their storage to the
database for reuse.  The oid used by the btree, however, will not be
recovered.

</p>

<div class="node">

<p></p>

<hr>
<a name="BTree-Cursors"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#BTree-Indexing">BTree Indexing</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Persistent-BTrees">Persistent BTrees</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.7 BTree Cursors</h3>

<p>Aside from getting, setting and dropping key-value pairs from the
database, you can also traverse the BTree structure one key-value pair
at a time.

   </p>

<p>Cursors must be created in the context of an active transaction
(i.e. a <code>with/ensure-transaction</code> body).  A cursor is made
through a call to the <code>make-cursor</code> method of the BTree you wish
to traverse. You must ensure that the cursor gets closed when
the stack is unwound; it's best to use the convenience macro
<code>with-btree-cursor</code> instead of <code>make-cursor</code>.

   </p>

<p>An existing cursors can also be duplicated within the same transaction
by calling <code>cursor-duplicate</code> which avoids the overhead of
setting a second cursor to the same location.

   </p>

<p>Cursors can be in two states: initialized and uninitialized. 
<a href="#BTree-Cursor-API">BTree Cursor API</a> for details.

   </p>

<p>To initialize a cursor, you have to use one of the initializing
functions to select a key-value pair in the btree.

     </p>

<ul>
<li><code>cursor-first</code> and <code>cursor-last</code>: initialize the
cursor to the first and last element of the btree, respectively. 
</li><li><code>cursor-set</code> and <code>cursor-set-range</code>: Sets the cursor
to the first key-pair values according to the specified key.  If the
set fails, the cursor will remain uninitialized.  The ranged set will
set it to the first key-value pair where the key is equal to or
greater than the key argument. 
</li></ul>

<p>A valid cursor will return multiple values: <code>(exists? key
value)</code>.  The first argument tells whether or not the cursor is
initialized and pointing at a proper value.  The second two arguments
are self-explanatory.

   </p>

<p><code>cursor-current</code> returns the current state of the cursor, nil if
it is uninitialized.

   </p>

<p>Once a cursor is properly initialized, it can be incremented or
decremented, a simple constant-time operation on BTrees.

   </p>

<p><code>cursor-next</code> and <code>cursor-prev</code> move the cursor a single step
forward or back across the sorted key-value pairs.  <code>cursor-next</code>
moves in ascending order, <code>cursor-prev</code> in descending order.

   </p>

<p>Finally cursors can be used for side effects on the current key-value
pair.  The function <code>cursor-put</code> replaces the value (but does not
increment the current value) and <code>cursor-delete</code> deletes the
key-value pair and become uninitialized.  It is a valid operation to
use the <code>(setf get-value)</code> method while the cursor is active to
change the value at the current cursor.

   </p>

<p>If cursors take place within a transaction, what happens when
traversing a very large BTree?  This depends on the data store policy
regarding whether a cursor read locks its entire btree (or the subset
that is being iterated over) or allows changes to any pairs its
transaction has not changed.  See your data store documentation for
details.

</p>

<div class="node">

<p></p>

<hr>
<a name="BTree-Indexing"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Index-Cursors">Index Cursors</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#BTree-Cursors">BTree Cursors</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.8 BTree Indexing</h3>

<p>One powerful feature of Elephant is the ability to add indexes to
BTrees.  An indexed btree is a subclass of the standard <code>btree</code>
called <code>indexed-btree</code>.  The indexed btree maintain a set of
indices (instances of <code>btree-index</code>) which provide alternative
ways of indexing into the values of the main btree.

   </p>

<p>Each index is itself a btree, but with the property that its values
are matched to the keys of the main btree.  That is if you have a btree
with key-value pairs:

</p>

<pre class="lisp">     ("henry" . #&lt;name: Henry, age: 45&gt;)
     ("larry" . #&lt;name: Larry, age: 29&gt;)
</pre>

<p>You can define an index that is populated by the age of the person object:

</p>

<pre class="lisp">     (29 . "Larry")
     (45 . "Henry")
</pre>

<p>Now when you call <code>(get-value 29 index)</code> you get back
<code>#&lt;name: Larry, age: 29&gt;</code>!  Note also that these new pairs are
ordered by age, the opposite of the alphabetic ordering of the names
in the first two pairs.  If you read through the tutorial, you may
have guessed by now that this is the mechanism used to implement the
class indexing capabilities previously described.

   </p>

<p>An index is created by using the <code>add-index</code> function.  This
function takes the <code>indexed-btree</code> you wish to index, an symbolic
name for the index and a key-form which dictates how the index
populates it's keys as a function of the main btree's keys and values. 
(It is a function of three arguments: the index itself, the key and
the value).

   </p>

<p>A simple, contrived example is shown in the figure below:

</p>

<div align="center"><img src="ElephantUserManual_files/IndexedBtrees1.png" alt="[BTree Index Diagram]"></div>

<p>Here we have a primary, indexed btree with a set of keys and values
represented by symbols.  We'll declare the function <code>val</code> to take
a value symbol and extract it's number.  The key-form in the
<code>mod5 * 2</code> index is:

</p>

<pre class="lisp">     (lambda (k v)
       (if (= 0 (mod (val v) 5))
           (values t (* 2 (val v)))
           (values nil nil)))
</pre>

<p>When a key-value pair is written to the primary btree, the index is
automatically updated through a call to the key-form.  If the key-form
above is called with <code>key1</code> and <code>value1</code>, <code>val</code> will
return 1 which fails the if test.  The second values statement,
<code>(values nil nil)</code> indicates that this pair is not to be indexed. 
If I pass <code>key5</code> and <code>value5</code> to this same key form, I get
back 10 as the <code>(val 'value5)</code> is 5 and <code>(= 0 (mod 5 5))</code> so
the form returns <code>(values t 10)</code> meaning the index should add an
index entry of 10 (<code>(* 2 5)</code>) associated with the key value
<code>key5</code>.

   </p>

<p>So, of course, making the call <code>(get-value 10 index-mod5)</code> will
return <code>value5</code>.

   </p>

<p>The second index in our little example calculates the number of bits
in all odd numbered values.  This illustrates an important property of
the <code>btree-index</code>: it allows duplicate keys.  Standard
<code>btree</code> and <code>indexed-btree</code> classes are not allowed to have
duplicate elements.  The odd index allows us to ask simple questions
like: what are all the odd values with ids that fit into 4 bits?.

   </p>

<p>To extract this set, we have to use cursor functions specifically
designed for the index that iterate over duplicate values.

</p>

<div class="node">

<p></p>

<hr>
<a name="Index-Cursors"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Multi_002dthreaded-Applications">Multi-threaded Applications</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#BTree-Indexing">BTree Indexing</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.9 Index Cursors</h3>

<p>Index cursors are just like BTree cursors except you can get the main
BTree value instead of the index value.  There are also a parallel set
of operations such as <code>cursor-pnext</code> instead of
<code>cursor-next</code> which returns <code>exists</code>, <code>key</code>,
<code>primary-btree-value</code> and <code>index-value = primary-btree-key</code>.

   </p>

<p>Operations that have the same behavior, but return primary btree
values and keys are:

   </p>

<p><table summary=""><tbody><tr align="left"><th width="30%" valign="top">BTree Cursor Function </th><th width="10%" valign="top"></th><th width="35%" valign="top">Index Cursor Function

<p><br></p>

</th></tr>
<tr align="left"><td width="30%" valign="top"><code>cursor-first</code>
</td><td width="10%" valign="top">=&gt;
</td><td width="35%" valign="top"><code>cursor-pfirst</code>

<p><br></p>

</td></tr>
<tr align="left"><td width="30%" valign="top"><code>cursor-last </code>
</td><td width="10%" valign="top">=&gt;
</td><td width="35%" valign="top"><code>cursor-plast</code>

<p><br></p>

</td></tr>
<tr align="left"><td width="30%" valign="top"><code>cursor-current </code>
</td><td width="10%" valign="top">=&gt;
</td><td width="35%" valign="top"><code>cursor-pcurrent</code>

<p><br></p>

</td></tr>
<tr align="left"><td width="30%" valign="top"><code>cursor-next </code>
</td><td width="10%" valign="top">=&gt;
</td><td width="35%" valign="top"><code>cursor-pnext</code>

<p><br></p>

</td></tr>
<tr align="left"><td width="30%" valign="top"><code>cursor-prev</code>
</td><td width="10%" valign="top">=&gt;
</td><td width="35%" valign="top"><code>cursor-pprev</code>

<p><br></p>

</td></tr>
<tr align="left"><td width="30%" valign="top"><code>cursor-set</code>
</td><td width="10%" valign="top">=&gt;
</td><td width="35%" valign="top"><code>cursor-pset</code>

<p><br></p>

</td></tr>
<tr align="left"><td width="30%" valign="top"><code>cursor-set-range</code>
</td><td width="10%" valign="top">=&gt;
</td><td width="35%" valign="top"><code>cursor-set-prange</code>
   <br></td></tr>
</tbody></table>

   </p>

<p>The big difference between btree cursors and index cursors is that
indices can have duplicate key values.  This means we have to choose
between incrementing over elements, unique key-values or only within
a duplicate segment.  There are cursor operations for each:

     </p>

<ul>
<li>Simple move. Standard btree operations work plus <code>cursor-pnext</code> and <code>cursor-pprev</code>
</li><li>Move to a different key value. <code>cursor-pnext-nodup</code> and <code>cursor-pprev-nodup</code>
</li><li>Move to next duplicate key value. <code>cursor-pnext-dup</code> and <code>cursor-pprev-dup</code>
</li></ul>

<p>After incrementing through a set of duplicate items using a
<code>xxx-dup</code> function, the last next operation returns nil
indicating there are no more duplicates.  The consequence of this is
that the cursor is now uninitialized (<code>cursor-initialized-p</code>) and
needs to be reset by a set or set both call.

   </p>

<p>See <a href="#Index-Cursor-API">Index Cursor API</a> for further details.

</p>

<div class="node">

<p></p>

<hr>
<a name="Multi-threaded-Applications"></a>
<a name="Multi_002dthreaded-Applications"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Transaction-Details">Transaction Details</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Index-Cursors">Index Cursors</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.10 Multi-threaded Applications</h3>

<p>Elephant is thread-safe by design.  Users should not have to think
about threading except to follow a couple of simple rules.

     </p>

<ol type="1" start="1">
<li>Do not perform transactions across multiple threads
</li><li>Do not perform add/remove index operations on indexed-btrees
in more than one thread.
        </li></ol>

<p>This and common coding sense should be sufficient!  Elephant's
internal design for thread safety employs a number of policies
to try to minimize using lisp locks and simplify analysis of
multi threaded interactions:

     </p>

<ol type="1" start="1">
<li><strong>Rely on the thread safety of the data store databases</strong>
</li><li><strong>Ensure transaction isolation</strong>
</li><li><strong>Minimize dependency on thread-local special variables</strong>
</li><li><strong>Protect shared resources for a given store controller</strong>. 
</li><li><strong>A use policy for shared objects (above)</strong>
        </li></ol>

<h4 class="subsection">4.10.1 Shared Resources</h4>

<p>Elephant has a few shared resources which are protected by standard locks. 
These are:

     </p>

<ul>
<li>The store controller connection table
</li><li>The instance cache
</li><li>The circularity buffer pool for the serializer
</li><li>The buffer-stream pool in memutils
</li></ul>

<p>In some cases, and on some lisp platforms, we try to use a fast lock
strategy for frequently accessed items (the resource pools and
instance cache especially).

</p>

<h4 class="subsection">4.10.2 Data Store Thread Safety and Transactions</h4>

<p>Both CLSQL and Berkelely DB backends are thread safe.  In CLSQL this
is by ensuring that every thread has it's own handle into the SQL
libraries or sockets.  Berkeley DB is reentrant and handles locking
internally.

   </p>

<p>Elephant depends on these guarantees especially for the isolation
properties of transactions.  All operations in the context of a
given transaction should be isolated and atomic.  It is important
that a transaction not be shared across threads, however.

</p>

<h4 class="subsection">4.10.3 Minimize Dependency on Thread-Local Specials</h4>

<p>Elephant uses several global variables as default arguments.  Most
of these were removed leaving only a couple to handle:

     </p>

<ul>
<li><code>*store-controller*</code>.  Store controller objects can
be shared between threads and if a user resets this variable in a local
thread to another controller, there is no problem with that either. 
Users of multiple concurrent stores can specify the store controller to
all elephant API commands that don't get it from a persistent object
implicitely. 
<code>*current-transaction*</code>.  This is always set to the proper null
value globally and should not be reset in local threads.  Instead,
transactions take place in a dynamic context that rebinds this variable
as a special with the current transaction.  This allows for a dynamic
transaction stack for data stores that can nest transactions or when
two datastores are both doing transactions concurrently. 
</li></ul>

<div class="node">

<p></p>

<hr>
<a name="Transaction-Details"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Multi_002drepository-Operation">Multi-repository Operation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Multi_002dthreaded-Applications">Multi-threaded Applications</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.11 Transaction Details</h3>

<p>Transactions are dynamic contexts in which all side effects to
persistent slots and other persistent objects such as BTrees are
guaranteed to have the ACID properties: atomicity, consistency,
isolation and durability.  On a normal exit from context, the
side effects are committed as a group.  On a non-local exit,
the transaction is aborted.

   </p>

<p>For most users, the tutorial section <a href="#Using-Transactions">Using Transactions</a> is the
best introduction to transactions.  This section adds to that by
exposing some of the details of how it is implemented.

   </p>

<p>To reiterate, there are a few important restrictions to adhere to:

     </p>

<ul>
<li><code>*current-transaction*</code> is reserved for use by the transaction system.  Users should not override, manipulate or close over this variable. 
</li><li>The body of a transaction cannot throw, signal or jump without 
aborting the transaction.  Any non-local exit is considered an aborting 
event.  Catch signals inside the transaction and return a value instead.

</li><li>The dynamic extent of a transaction body must stay within the same thread
</li></ul>

<h4 class="subsection">4.11.1 <code>with-transaction</code> internals</h4>

<p>The <code>with-transaction</code> macro wraps the body expression with an
anonymous lambda expression.  This closure is passed to a call to the
<code>execute-transaction</code> generic function which is specialized to
the current data store.

   </p>

<p>The only bookkeeping done by the macro is ensuring that the
<code>:parent</code> argument is checked for the current dynamic transaction
context.  If it is not owned by the default or provided store
controller, then it is not passed to <code>execute-transaction</code>.  This
maintains a continuous dynamic stack transactions through the
with/ensure transaction macros, but allows for a single leaf
transaction to another store controller.

   </p>

<p>Be very careful about mixing transactions between store controller. 
This facility was only added to ensure that migrate worked correctly.

   </p>

<p>The macro processes keywords arguments <code>:store-controller</code>
(defaults to <code>*store-controller*</code>), <code>:parent</code> (defaults to
<code>*current-transaction*</code>) and <code>:retries</code> and passes the
remaining keywords to the call to <code>execute-transaction</code> allowing
the user to pass data store specific transaction keywords to their
preferred data store.  The consumed keywords are analyzed and then
passed on to <code>execute-transaction</code>.

   </p>

<p>Any non-standard keywords for a given data store will be ignored by
other data store implementation of <code>execute-transaction</code> so
portable programs should not use keywords that change the semantics of
the transaction.

   </p>

<p><code>ensure-transaction</code> only calls <code>execute-transaction</code> if
it needs to create a fresh transaction.  If the transaction in
<code>*current-transaction*</code> exists and belongs to the store controller
passed to <code>ensure-transaction</code> then it merely calls the transaction
closure, relying on the environment that created the transaction to
handle any exit procedures and determining whether to abort or commit.

   </p>

<p><code>*current-transaction*</code> contains transaction records during the
dynamic execution of a transaction.  These records capture any data
store specific bookkeeping as well as the store-controller that the
transaction is associated with.

</p>

<h4 class="subsection">4.11.2 <code>execute-transaction</code> internals</h4>

<p>See the <a href="#Elephant-Architecture">Elephant Architecture</a> section for details on how
execute-transaction works.  It will provide some deeper insight
into the transaction system.

</p>

<h4 class="subsection">4.11.3 Building your own transactional framework</h4>

<p>Data stores are required to implement three primitive transaction
methods: <code>controller-start-transaction</code>,
<code>controller-abort-transaction</code> and
<code>controller-commit-transaction</code>.  These are wrappers for the data
store's primitive transaction mechanism.  If you use these, it is up
to you to make sure that you properly manage nested transactions,
maintain the state of <code>*current-transaction*</code> handle any
automated retries you might want, and handle detecting

   </p>

<p>If you use these, you are on your own - it is easy to make mistakes with
transactions and create very complex bugs that are hard to track down. 
Most users are much better off sticking with the two transaction macros
and the underlying <code>execute-transaction</code> method.

</p>

<h4 class="subsection">4.11.4 Analyzing Dynamic Transaction Behavior</h4>

<p>You can trace <code>elephant::execute-transaction</code> to see the sequence
of calls that occur dynamically and detect where and how many
transactions are and are not happening.

<!-- IT WOULD BE GOOD TO EXPAND ON THIS REGARDING HOW TO SOLVE COMMON PROBLEMS -->
</p>

<div class="node">

<p></p>

<hr>
<a name="Multi-repository-Operation"></a>
<a name="Multi_002drepository-Operation"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Multiple-Processes-and-Distributed-Applications">Multiple Processes and Distributed Applications</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Transaction-Details">Transaction Details</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.12 Multi-repository Operation</h3>

<p>Elephant maintains a small hashtable that maps database
specifications into actual <code>store-controller</code> objects.

   </p>

<p>The basic strategy is that the database specification object is
stored in every persistent object and collection so that the
repository can be found.  In this way, objects that reside in
different repositories can coexist within the LISP object space,
allowing data migration or multiple user stores.

   </p>

<p>All persistent instances store their oid and a store-controller
reference in internal slots.  Slot access and other protocols use
this to provide access.  This executes an auto-transaction or joins
a surrounding transaction if the <code>transaction-record</code> in
<code>*current-transaction*</code> matches the store.

   </p>

<p>When operating with multiple stores and nested transactions there are
some subtle issues to work around: how to avoid writing one store with
a transaction created in the context of another.  A nested or ensured
transaction is only indicated in the call to
<code>execute-transaction</code> if the store controllers match, otherwise a
new transaction for that store is created.

<!-- A PICTURE OF THE DYNAMIC CONTEXT WOULD BE USEFUL HERE -->
</p>

<div class="node">

<p></p>

<hr>
<a name="Multiple-Processes-and-Distributed-Applications"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Repository-Migration-and-Upgrade">Repository Migration and Upgrade</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Multi_002drepository-Operation">Multi-repository Operation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.13 Multiple Processes and Distributed Applications</h3>

<p>Just start up two lisp images and connect to the same database. 
Transactions will ensure there is no interaction between processes. 
This has not been extensively tested, but should work without any
problem.  Any field experience will get reflected in this section of the manual

   </p>

<p>Distributed applications may be supported if the underlying SQL server
or an appropriate Berkeley DB database is used.  We provide no
documentation nor have we heard of this use-case.  This remains
fertile ground for future investigation.

</p>

<div class="node">

<p></p>

<hr>
<a name="Repository-Migration-and-Upgrade"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Performance-Tuning">Performance Tuning</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Multiple-Processes-and-Distributed-Applications">Multiple Processes and Distributed Applications</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.14 Repository Migration and Upgrade</h3>

<p>This version of Elephant supports migration between store controllers of
any backend type.

   </p>

<p>The tests <code>migrate1</code> - <code>migrate5</code> are demonstrations of this
capability.

   </p>

<p>There is a single generic function <code>migrate</code> that is used to copy
different object types to a target repository.  It is assumed that typically
migrate will be called on two repositories and all live objects (those
reachable in the root or class-root) will be copied to the target repository
via recursive calls to migrate for specific objects.

   </p>

<p>When persistent instances are copied, their internal pointer will be updated
to point to the new repository so after migration the lisp image should be
merely updated to refer to the target repository in the *store-controller*
variable or whatever variable the application is using to store the primary
controller instance.

   </p>

<p>There are some limitations to the current migration implementation:
     </p>

<ol type="1" start="1">
<li>Migrate currently will not handle circular list objects

     <!-- @item Migrate does not support arrays with nested persistent objects -->
</li><li>Indexed classes only have their class index copied if you use the
   top level migration.  Objects will be copied without slot data if you
   try to migrate an object outside of a store-to-store migration due to
   the class object belonging to one store or another

     </li><li>Migrate assumes that after migration, indexed classes belong to the
   target store.

     </li><li>In general, migration is a one-time activity and afterwards (or after
   a validation test) the source store should be closed.  Any failures
   in migration should then be easy to catch.

     </li><li>Each call to migration will be good about keeping track of already
   copied objects to avoid duplication.  Duplication shouldn't screw
   up the semantics, just add storage overhead but is to be avoided. 
   However this information is not saved between calls and there's no
   other way to do comparisons between objects across stores (different
   oid namespaces) so user beware of the pitfalls of partial migrations...

     </li><li>Migrate keeps a memory-resident hash of all objects; this means
   you cannot currently migrate a store that has more data than your
   main memory.  (This could be fixed by keeping the oid table in
   the target store and deleting it on completion)

     </li><li>Migration does not maintain OID equivalence so any datastructures which
   index into those will have to have a way to reconstruct themselves (better
   to keep the object references themselves rather than oids in general)
   but they can overload the migrate method to accomplish this cleanly
        </li></ol>

<p>Users can customize migration if they create unusual datastructures that
are not automatically supported by the existing <code>migrate</code> methods. 
For example, a datastructure that stores only object OIDs instead of
serialized object references will need to overload migrate to ensure
that all referenced objects are in fact copied (otherwise the OIDs will
just be treated as fixnums potentially leaving dangling references.

   </p>

<p>To customize migration overload a version of migrate to specialize on
your specific persistent class type.

</p>

<pre class="lisp">     (defmethod migrate ((dst store-controller) (src my-class)))
</pre>

<p>In the body of this method you can call <code>(call-next-method)</code>
to get a destination repository object with all the slots copied over
to the target repository which you can then overwrite.  To avoid the
default persistent slot copying, bind the dynamic variable
<code>*inhibit-slot-writes*</code> in your user method using
<code>with-inhibited-slot-copy</code> a convenience macro.

</p>

<div class="node">

<p></p>

<hr>
<a name="Performance-Tuning"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Garbage-Collection">Garbage Collection</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Repository-Migration-and-Upgrade">Repository Migration and Upgrade</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.15 Performance Tuning</h3>

<p>Performance is usually measured in transactions per second.  Database
reads are cheap.  To get more transactions throughput, consider
setting

</p>

<pre class="lisp">     (db-env-set-flags (controller-environment *store-controller*)
                       1 :txn-nosync t)
</pre>

<p>or look at other flags in the Berkeley DB docs.  This will greatly
increase your throughput at the cost of some durability; I get around
a 100x improvement.  Durability can be recovered with judicious use of
checkpointing and replication, though this is currently not supported
directly by Elephant  see the sleepycat docs.

   </p>

<p>The serializer is definitely fast on fixnums, strings, and persistent
things.  It is fast but consing with floats and doubles.  YMMV with
other values, though I've tried to make them fast.

   </p>

<p>Use <code>with-transactions</code> to avoid many automatic transactions, for
example you'll find that this construct

</p>

<pre class="lisp">     (dotimes (i 1000) (add-to-root "key" "value"))
</pre>

<p>is much slower than

</p>

<pre class="lisp">     (with-transaction ()
      (dotimes (i 1000) (add-to-root "key" "value"))))
</pre>

<p>since there's only 1 transaction in the latter.  However storing
transaction state requires allocated main memory of which there is
a finite amount so do not make your transactions too large.

   </p>

<p>Use the persistent classes and collections; if you're using
transactions correctly they should be much faster.

   </p>

<p>If you don't need transactions you can turn them off.  Opening the DB
in less concurrent / transactional modes will be supported very soon
(it's just an argument change, I think.)  However you will need to
ensure that multiple threads do not interleave access so single user
mode is not suitable for use in web servers or other typically
multi-threaded applications.

</p>

<div class="node">

<p></p>

<hr>
<a name="Garbage-Collection"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Berkeley-DB-Data-Store">Berkeley DB Data Store</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Performance-Tuning">Performance Tuning</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.16 Garbage Collection</h3>

<p>Garbage collection is not implemented as part of the persistent object
protocol.  However, the migration (see <a href="#Repository-Migration-and-Upgrade">Repository Migration and Upgrade</a>) mechanism will consolidate storage and recover OIDs which is
an effective offline GC.  No online solution is currently anticipated.

</p>

<div class="node">

<p></p>

<hr>
<a name="Berkeley-DB-Data-Store"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#CLSQL-Data-Store">CLSQL Data Store</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Garbage-Collection">Garbage Collection</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.17 Berkeley DB Data Store</h3>

<p>This section briefly describes special facilities of the Berkeley DB
data store and explains how persistent objects map onto it.  Elephant
was originally written targeting only Berkeley DB.  As such, the
design of Elephant was heavily influenced by the Berkeley DB architecture.

   </p>

<p>Berkeley DB is a C library that very efficiently implements a database
by allowing the application to directly manipulate the memory pools
and disk storage without requiring communication through a server as
in many relational database applications.  The library supports
multi-threaded and multi-process transactions through a shared memory
region that provides for shared buffer pools, shared locks, etc.  Each
process in a multi-process application is independently linked to the
library, but shares the memory pool and disk storage.

   </p>

<p>The following subsections discuss places where Berkeley DB provides
additional facilities to the Elephant interfaces described above.

</p>

<h4 class="subsection">4.17.1 Architecture Overview</h4>

<p>The Berkeley DB data store (indicated by a <code>:BDB</code> in the data
store specification) supports the Elephant protocols using Berkeley DB
as a backend.  The primary features of the BDB library that are used
are BTree databases, the transactional subsystem, a shared buffer pool
and unique ID sequences.

   </p>

<p>All data written to the data store ends up in a BTree slot using a
transaction.  There are two databases, one for persistent slot values
and one for btrees.  The mapping of Elephant objects is quite simple.

   </p>

<p>Persistent slots are written to a btree using a unique key and the
serialized value being written.  The key is the oid of the persistent
object concatenated to the serialized name of the slot being written. 
This ordering groups slots together on the disk

</p>

<h4 class="subsection">4.17.2 Opening a Store</h4>

<p>When opening a store there are several special options you can invoke:

     </p>

<ul>
<li><code>:recover</code> tells Berkeley DB to run recovery on the
      underlying database.  This is reasonably cheap if you do not need
      to run recovery, but can take a very long time if you let your log
      files get too long.  This option must be run in a single-threaded
      mode before other threads or processes are accessing the same database. 
</li><li><code>:recover-fatal</code> runs Berkeley DB catastrophic recovery (see BDB documentation). 
</li><li><code>:thread</code> set this to nil if you want to run single threaded,
      it avoids locking overhead on the environment.  The default is
      to run <em>free-threaded</em>. 
</li><li>The <code>:deadlock-detect</code> launches a background process via
      the run-shell commands of lisp.  This background process connects to a Berkeley
      DB database and runs a regular check for deadlock, freeing locks as appropriate
      when it finds them.  This can avoid a set of annoying crashes in Berkeley DB,
      the very crashes that, in part, motivated Franz to abandon AllegroStore and write
      the pure-Lisp AllegroCache. 
</li></ul>

<h4 class="subsection">4.17.3 Starting a Transaction</h4>

<p>Berkeley DB transactions have a number of additional keyword
parameters that can help you tune performance or change the semantics
in Berkeley DB applications.  They are summaried briefly here, see the
BDB docs for detailed information:

     </p>

<ul>
<li><code>:degree-2</code> This option provides for cursor stability, that is whatever
      object the cursor is currently at will not change, however prior
values read may change.  This can significantly enhance performance if
you frequently map over a btree as it doesn't lock the entire btree,
just the current element.  All transactions running concurrently over
the btree can commit without restarting.  The global parameter
<code>*map-using-degree2*</code> determines the default behavior of this
option.  It is set to true by default so that map has similar
semantics to lists.  This violates both <em>Atomicity and
Consistency</em> depending on how it is used. 
</li><li><code>:read-uncommitted</code> Allows reading data that has been written by other
transactions, this avoids the current thread blocking on a read access
(for example you are merely dumping a btree for inspection) so long as
you don't care whether the data you read changes or not.  This
violates <em>Atomicity and Consistency</em> depending on how it is used
</li><li><code>:txn-nosync</code> Do not flush the log when this transaction completes.  This means
that you lose the <em>Durability</em> of a transaction, but gain performance by avoiding the expensive
sync operation. 
</li><li><code>:txn-nowait</code> If a lock is unavailable, have the underlying database return a
deadlock message immediately, rather than blocking, so that the transaction restarts. 
</li><li><code>:txn-sync</code> This is the default behavior and specifies that the transaction log
of the current transaction is flushed to disk before the transaction commit routine returns.  This
provides full ACID compliance. 
</li><li><code>:transaction</code> This argument is for advanced use.  It tells
      the Berkeley DB transaction subsystem the transaction it should use rather
than to create a new one.  The <code>:parent</code> argument provides a parent transaction
that can result in a true nested transaction. 
</li></ul>

<h4 class="subsection">4.17.4 Special Commands</h4>

<p>The berkeley DB data store exports some special facilities that are not
currently supported by other data stores.

     </p>

<ul>
<li><code>optimize-layout</code>.  This function provides an interface
     to tell Berkeley DB to try to reclaim freed storage from the file
system.  This is of limited utility as it can only shrink database by
the number of empty pages at the end of the file.  Depending on what
storage you have deleted, this can end up being only a handful or even
zero pages.  This will work well if you recently ran an experiment
where you created a bunch of new data, then deleted it all and want to
reclaim the space (i.e. you had runaway loop that was creating endless
objects). 
</li><li><code>db-bdb:checkpoint</code>. This internal function forces
the transaction log to be flushed and all active data to be written to
the database so that the logs and database are in synch.  This is good
to run when you want to delete old log files and backup your database
files as a coherent, recoverable set.  Run checkpoing, close the
database and then manually run db_archive -d on the database to
remove old logs.  Finally, copy the resulting data to stable storage. 
Read the Berkeley DB docs for more details of backing up and
checkpointing. 
</li></ul>

<h4 class="subsection">4.17.5 Performance Tuning</h4>

<p>Performance tuning for Berkeley DB is a complex topic and we will not
cover it here.  You need to understand the Berkeley DB data store
architecture, the transaction architecture, the serializer and other
such parameters.  The primary performance related parameters are
described in config.sexp.  They are:

     </p>

<ul>
<li><code>:berkeley-db-map-degree2</code> - Improve the efficiency of cursor traversals
  in the various mapping functions.  Defaults to true, meaning a value
you just read while mapping may change before the traversal is done. 
So if you operate only on the current cursor location, you are
guaranteed that it's value is stable. 
</li><li><code>:berkeley-db-cachesize</code> - Change the size of the buffer cache
for Berkeley DB to match your working set.  Default is 10MB, or about
twenty thousand indexed class objects, or 50k standard persistent
objects.  You can save memory by reducing this value. 
</li></ul>

<div class="node">

<p></p>

<hr>
<a name="CLSQL-Data-Store"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Postmodern-Data-Store">Postmodern Data Store</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Berkeley-DB-Data-Store">Berkeley DB Data Store</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.18 CLSQL Data Store</h3>

<p>Elephant uses Kevin Rosenberg's excellent <a href="http://clsql.b9.com/">CLSQL</a>
 CLSQL lisp binding to relational databases
(it does not use the ORM functionality offered by that package.) 
CLSQL interfaces to many databases (Postgres, MySQL, Oracle,
ODBC, SQLite3, Microsoft SQL Server (via ODBC)).  Right now, Elephant has
been tested with Postgress and SQLite3.  Probably getting it to work with
one of the others will take a small amount of debugging; in principle there
is no reason it won't work out of the box.  We invite users to try
other database, and will quickly incorporate patches needed to make them
work.

   </p>

<p>Because CLSQL is very generic, the CLSQL interface does not offer any
special feature as discussed in the previous section <a href="#Berkeley-DB-Data-Store">Berkeley DB Data Store</a>.

</p>

<h4 class="subsection">4.18.1 Basic CLSQL Implementation</h4>

<p>The CLSQL uses base64 encoding to store binary data as text directly.  This
has the advantage that it works with all databases, which tend to differ
widely in their treatment of Binary Large Objects (BLOBs.)  It imposes some
obvious overhead.

   </p>

<p>The CLSQL implementation is structurally exactly the same as the BDB implementation. 
A single table is created to hold all (key,value) pairs.  An index on the key column
provides efficient key lookup.  No additional indexing offered by the underlying
databases is used.  This has the advantage that the API is exactly the same as the
BDB api, and all of the functional indexes, cursors, and secondary indexes work exactly
the same way.  It does not exploit the performance that a database-specific solution
would offer (see <a href="#Postmodern-Data-Store">Postmodern Data Store</a> for an example of such a system.

   </p>

<p>Our basic strategy is to leave the CLSQL interface as simple as possible, in order to
work with as many databases as possible.  When there is enough motivation to support
a backend that is specific to one database (and therefore probably faster), such an
interface can be placed into the contrib directory and migrated into the main
code base as time allows the complete integration with the test suite.

</p>

<div class="node">

<p></p>

<hr>
<a name="Postmodern-Data-Store"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Native-Lisp-Data-Store">Native Lisp Data Store</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#CLSQL-Data-Store">CLSQL Data Store</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.19 Postmodern Data Store</h3>

<p>The postmodern data store is not yet integrated.  It should be
documented for the forthcoming release 0.9.1 or 0.9.2.

   </p>

<p>This backend will presumably be much faster, when used against PostGres, than the
generic CLSQL store.

</p>

<div class="node">

<p></p>

<hr>
<a name="Native-Lisp-Data-Store"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Postmodern-Data-Store">Postmodern Data Store</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Guide">User Guide</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">4.20 Native Lisp Data Store</h3>

<p>The native lisp data store is unimplemented.  It is tentatively
planned for a 1.1 release sometime in the distant future.  Yes,
this is a deliberatively vague declaration.

<!-- @node Querying persistent instances -->
<!-- @comment node-name, next, previous, up -->
<!-- @section Querying persistent instances -->
<!-- A SQL select-like interface is in the works, but for now queries are -->
<!-- limited to manual mapping over class instances or doing small queries -->
<!-- with @code{get-instances-*} functions.  One advantage of this is that -->
<!-- it is easy to estimate the performance costs of your queries and to -->
<!-- choose standard and derived indices that give you the ordering and -->
<!-- performance you want. -->
<!-- There is, however, a quick and dirty query API example that is not -->
<!-- officially supported in the release but is intended to invite comment. -->
<!-- This is an example of a full query system that would automatically -->
<!-- perform joins, use the appropriate indices and perhaps even adaptively -->
<!-- suggest or add indices to facilitate better performance on common -->
<!-- queries. -->
<!-- There are two functions @ref{Function elephant:get-query-instances} -->
<!-- and @ref{Function elephant:map-class-query} which accept a set of -->
<!-- constraints instead of the familiar value or range arguments. -->
<!-- We'll use the classes @code{person} and @code{department} to -->
<!-- illustrate how to perform queries over a set of objects that may be -->
<!-- constrainted by their relationships to other objects. -->
<!-- @lisp -->
<!-- (defpclass person () -->
<!-- ((name :initarg :name :index t) -->
<!-- (salary :initarg :salary :index t) -->
<!-- (department :initarg :dept))) -->
<!-- (defmethod print-object ((p person) stream) -->
<!-- (format stream "#<PERS: ~A>" (slot-value p 'name))) -->
<!-- (defun print-name (inst) -->
<!-- (format t "Name: ~A~%" (slot-value inst 'name))) -->
<!-- (defpclass department () -->
<!-- ((name :initarg :name) -->
<!-- (manager :initarg :manager))) -->
<!-- (defmethod print-object ((d department) stream) -->
<!-- (format stream "#<DEPT ~A, mgr = ~A>" -->
<!-- (slot-value d 'name) -->
<!-- (when (slot-boundp d 'manager) -->
<!-- (slot-value (slot-value d 'manager) 'name)))) -->
<!-- @end lisp -->
<!-- Here we have a simple employee database with managers (also of type -->
<!-- person) and departments.  This simple system will provide fodder for -->
<!-- some reasonably complex constraints.  Let's create a few departments. -->
<!-- @lisp -->
<!-- (setf marketing (make-instance 'department :name "Marketing")) -->
<!-- (setf engineering (make-instance 'department :name "Engineering")) -->
<!-- (setf sales (make-instance 'department :name "Sales")) -->
<!-- @end lisp -->
<!-- And manager @code{people} for the departments. -->
<!-- @lisp -->
<!-- (make-instance 'person :name "George" :salary 140000 :department marketing) -->
<!-- (setf (slot-value marketing 'manager) *) -->
<!-- (make-instance 'person :name "Sally" :salary 140000 :department engineering) -->
<!-- (setf (slot-value engineering 'manager) *) -->
<!-- (make-instance 'person :name "Freddy" :salary 180000 :department sales) -->
<!-- (setf (slot-value sales 'manager) *) -->
<!-- @end lisp -->
<!-- And of course we need some folks to manage -->
<!-- @lisp -->
<!-- (defparameter *names* -->
<!-- '("Jacob" "Emily" "Michael" "Joshua" "Andrew" "Olivia" "Hannah" "Christopher")) -->
<!-- (defun random-element (list) -->
<!-- "Choose a random element from the list and return it" -->
<!-- (nth (random (length list)) list)) -->
<!-- (with-transaction () -->
<!-- (loop for i from 0 upto 40 do -->
<!-- (make-instance 'person -->
<!-- :name (format nil "~A~A" (random-elephant *names*) i) -->
<!-- :salary (floor (+ (* (random 1000) 100) 30000)) -->
<!-- :department (case (random 3) -->
<!-- (0 marketing) -->
<!-- (1 engineering) -->
<!-- (2 sales))))) -->
<!-- @end lisp -->
<!-- Now we can look at a few queries. -->
<!-- @lisp -->
<!-- (defun get-managers () -->
<!-- (get-query-instances `((person -->
<!-- For those familiar with SQL, if an instance of @code{person} has a -->
<!-- pointer to an instance of @code{department} then that relation can be -->
<!-- used to perform a join.  Of course joins in the object world won't -->
<!-- return a table, instead they will return conjunctions of objects that -->
<!-- satisfy a mutual set of constraints. -->
<!-- *-texinfo-*- -->
</p>

<div class="node">

<p></p>

<hr>
<a name="User-API-Reference"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Design-Patterns">Design Patterns</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#User-Guide">User Guide</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name, next, previous, up -->
<h2 class="chapter">5 User API Reference</h2>

<p><a name="index-User-API-Reference-6"></a><a name="index-API-Reference-7"></a>

</p>

<ul class="menu">
<li><a accesskey="1" href="#Store-Controller-API">Store Controllers</a>:  Connecting to a data store. 
</li><li><a accesskey="2" href="#Persistent-Object-API">Persistent Objects</a>:  Defining persistent classes and creating and manipulating persistent indices. 
</li><li><a accesskey="3" href="#Persistent-Object-Indexing-API">Persistent Object Indexing</a>:  Convenient indexing of persistent classes. 
</li><li><a accesskey="4" href="#Persistent-Set-API">Persistent Sets</a>:  Maintaining persistent collections the easy way. 
<!-- * Query Interfaces:: Finding instances. -->
</li><li><a accesskey="5" href="#BTree-API">BTrees</a>:  BTrees and indices, a low level persistent data structure. 
</li><li><a accesskey="6" href="#BTree-Cursor-API">BTree Cursors</a>:  Traversing BTrees. 
</li><li><a accesskey="7" href="#Index-Cursor-API">Index Cursors</a>:  Traversing BTree Indicies. 
</li><li><a accesskey="8" href="#Transaction-API">Transactions</a>:  Transaction functions. 
</li><li><a accesskey="9" href="#Migration-and-Upgrading-API">Migration and Upgrading</a>:  Migration and upgrading. 
<!-- * Miscellaneous API:: Other functions and data store specific functions -->
</li></ul>

<div class="node">

<p></p>

<hr>
<a name="Store-Controller-API"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Persistent-Object-API">Persistent Object API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-API-Reference">User API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">5.1 Store Controllers</h3>

<p><a name="index-Store-Controller-8"></a><a name="index-API-9"></a>
Store controllers provide the persistent storage for CLOS objects and
BTree collections.  Any persistent operations must be done in the
context of a store controller.  The default store-controller is stored
in a global variable.

   </p>

<p><a name="Variable-elephant_003a_002astore_002dcontroller_002a"></a>

</p>

<div class="defun">
 Variable: <b>elephant:*store-controller*</b><var><a name="index-elephant_003a_002astore_002dcontroller_002a-10"></a></var><br>
<blockquote>
<p><a name="index-elephant_003a_002astore_002dcontroller_002a-11"></a>The store controller which persistent objects talk to. 
</p>

</blockquote></div>

<!-- @include includes/class-elephant-store-controller.texinfo -->

<p><a href="#Class-elephant_003astore_002dcontroller">Class elephant:store-controller</a> is associated with the following
user methods and macros:

   </p>

<p><a name="Macro-elephant_003awith_002dopen_002dstore"></a>

</p>

<div class="defun">
 Macro: <b>elephant:with-open-store</b><var> spec &amp;body body<a name="index-elephant_003awith_002dopen_002dstore-12"></a></var><br>
<blockquote>
<p><a name="index-elephant_003awith_002dopen_002dstore-13"></a>Executes the body with an open controller,
   unconditionally closing the controller on exit. 
</p>

</blockquote></div>

<p><a name="Function-elephant_003aopen_002dstore"></a>

</p>

<div class="defun">
 Function: <b>elephant:open-store</b><var> spec &amp;rest args<a name="index-elephant_003aopen_002dstore-14"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aopen_002dstore-15"></a>Conveniently open a store controller.  Set *store-controller* to the new controller
   unless it is already set (opening a second controller means you must keep track of
   controllers yourself.  *store-controller* is a convenience variable for single-store
   applications or single-store per thread apps.  Multi-store apps should either confine
   their *store-controller* to a given dynamic context or wrap each store-specific op in
   a transaction using with or ensure transaction.  Returns the opened store controller. 
</p>

</blockquote></div>

<p><a name="Function-elephant_003aclose_002dstore"></a>

</p>

<div class="defun">
 Function: <b>elephant:close-store</b><var> &amp;optional sc<a name="index-elephant_003aclose_002dstore-16"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aclose_002dstore-17"></a>Conveniently close the store controller.  If you pass a custom store controller, you are responsible for setting it to <code>nil</code>. 
</p>

</blockquote></div>

<p><a name="Function-elephant_003aget_002dfrom_002droot"></a>

</p>

<div class="defun">
 Function: <b>elephant:get-from-root</b><var> key &amp;key sc<a name="index-elephant_003aget_002dfrom_002droot-18"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aget_002dfrom_002droot-19"></a>Get the value associated with key from the root.  Returns two
   values, the value, or nil, and a boolean indicating whether a
   value was found or not (so you know if nil is a value or an
   indication of non-presence)
</p>

</blockquote></div>

<p><a name="Function-elephant_003aadd_002dto_002droot"></a>

</p>

<div class="defun">
 Function: <b>elephant:add-to-root</b><var> key value &amp;key sc<a name="index-elephant_003aadd_002dto_002droot-20"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aadd_002dto_002droot-21"></a>Add an arbitrary persistent thing to the root, so you can
   retrieve it in a later session.  Anything referenced by an
   object added to the root is considered reachable and thus live
</p>

</blockquote></div>

<p><a name="Function-elephant_003aremove_002dfrom_002droot"></a>

</p>

<div class="defun">
 Function: <b>elephant:remove-from-root</b><var> key &amp;key sc<a name="index-elephant_003aremove_002dfrom_002droot-22"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aremove_002dfrom_002droot-23"></a>Remove something from the root by the key value
</p>

</blockquote></div>

<p><a name="Function-elephant_003aroot_002dexistsp"></a>

</p>

<div class="defun">
 Function: <b>elephant:root-existsp</b><var> key &amp;key sc<a name="index-elephant_003aroot_002dexistsp-24"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aroot_002dexistsp-25"></a>Test whether a given key is instantiated in the root
</p>

</blockquote></div>

<p><a name="Function-elephant_003amap_002droot"></a>

</p>

<div class="defun">
 Function: <b>elephant:map-root</b><var> fn &amp;key sc<a name="index-elephant_003amap_002droot-26"></a></var><br>
<blockquote>
<p><a name="index-elephant_003amap_002droot-27"></a>Takes a function of two arguments, key and value, to map over
   all key-value pairs in the root
</p>

</blockquote></div>

<div class="node">

<p></p>

<hr>
<a name="Persistent-Object-API"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Persistent-Object-Indexing-API">Persistent Object Indexing API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Store-Controller-API">Store Controller API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-API-Reference">User API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">5.2 Persistent Objects</h3>

<p><a name="index-Persistent-Objects-28"></a><a name="index-API-29"></a>
<a href="#Class-elephant_003apersistent_002dmetaclass">Class elephant:persistent-metaclass</a> can be used as the
:metaclass argument in a defclass form to create a persistent object. 
Slots of the metaclass take the :index and :transient keyword
arguments and the class accepts the :index keyword argument.

   </p>

<p><a name="Macro-elephant_003adefpclass"></a>

</p>

<div class="defun">
 Macro: <b>elephant:defpclass</b><var> cname parents slot-defs &amp;rest class-opts<a name="index-elephant_003adefpclass-30"></a></var><br>
<blockquote>
<p><a name="index-elephant_003adefpclass-31"></a>Shorthand for defining persistent objects.  Wraps the main
   class definition with persistent-metaclass
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003adrop_002dinstance"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:drop-instance</b><var> persistent-object<a name="index-elephant_003adrop_002dinstance-32"></a></var><br>
<blockquote>
<p><a name="index-elephant_003adrop_002dinstance-33"></a>drop-instance reclaims persistent object storage by unbinding
   all persistent slot values.  It can also helps catch errors
   where an object should be unreachable, but a reference still
   exists elsewhere in the <code>db</code>.  On access, the unbound slots
   should flag an error in the application program.  <code>important:</code>
   this function does not clear any serialized references still in the db. 
   Need a migration or <code>gc</code> for that!  drop-instances is the user-facing call
   as it implements the proper behavior for indexed classes
</p>

</blockquote></div>

<div class="node">

<p></p>

<hr>
<a name="Persistent-Object-Indexing-API"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Persistent-Set-API">Persistent Set API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Persistent-Object-API">Persistent Object API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-API-Reference">User API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">5.3 Persistent Object Indexing</h3>

<p><a name="index-Persistent-Object-Indexing-34"></a><a name="index-API-35"></a>

</p>

<h4 class="subsection">5.3.1 Indexed Object Accessors</h4>

<p><a name="Function-elephant_003amap_002dclass"></a>

</p>

<div class="defun">
 Function: <b>elephant:map-class</b><var> fn class &amp;key collect oids sc<a name="index-elephant_003amap_002dclass-36"></a></var><br>
<blockquote>
<p><a name="index-elephant_003amap_002dclass-37"></a>Perform a map operation over all instances of class.  Takes a
   function of one argument, a class instance. 
</p>

</blockquote></div>

<p><a name="Function-elephant_003amap_002dinverted_002dindex"></a>

</p>

<div class="defun">
 Function: <b>elephant:map-inverted-index</b><var> fn class index &amp;rest args &amp;key start end value from-end collect oids<a name="index-elephant_003amap_002dinverted_002dindex-38"></a></var><br>
<blockquote>
<p><a name="index-elephant_003amap_002dinverted_002dindex-39"></a>map-inverted-index maps a function of two variables, taking key
   and instance, over a subset of class instances in the order
   defined by the index.  Specify the class by classname or class object
   and index by quoted name.  The index may be a slot index, derived index,
   or a valued association slot.

        </p>

<p>To map only a subset of key-value pairs, specify the range
   using the :start and :end keywords; all elements greater than
   or equal to :start and less than or equal to :end will be
   traversed regardless of whether the start or end value is in
   the index.

        </p>

<p>Use nil in the place of start or end to specify the first
   element or last element, respectively.

        </p>

<p>To map a single value, iff it exists, use the :value keyword. 
   This is the only way to travers all nil values.

        </p>

<p>To map from :end to :start in descending order, set :from-end
   to true.  If :value is used, :from-end is ignored

        </p>

<p>The 'oids' argument passes the oid of the instance to the provided
   function instead of the recreated instance. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003aget_002dinstances_002dby_002dclass"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:get-instances-by-class</b><var> persistent-metaclass<a name="index-elephant_003aget_002dinstances_002dby_002dclass-40"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aget_002dinstances_002dby_002dclass-41"></a>Retrieve all instances from the class index as a list of objects
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003aget_002dinstance_002dby_002dvalue"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:get-instance-by-value</b><var> persistent-metaclass slot-name value<a name="index-elephant_003aget_002dinstance_002dby_002dvalue-42"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aget_002dinstance_002dby_002dvalue-43"></a>Retrieve instances from a slot index by value.  Will return only the first
                  instance if there are duplicates. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003aget_002dinstances_002dby_002dvalue"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:get-instances-by-value</b><var> persistent-metaclass slot-name value<a name="index-elephant_003aget_002dinstances_002dby_002dvalue-44"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aget_002dinstances_002dby_002dvalue-45"></a>Returns a list of all instances where the slot value is equal to value. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003aget_002dinstances_002dby_002drange"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:get-instances-by-range</b><var> persistent-metaclass slot-name start end<a name="index-elephant_003aget_002dinstances_002dby_002drange-46"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aget_002dinstances_002dby_002drange-47"></a>Returns a list of all instances that match
                   values between start and end.  An argument of
                   nil to start or end indicates, respectively,
                   the lowest or highest value in the index
</p>

</blockquote></div>

<p><a name="Function-elephant_003adrop_002dinstances"></a>

</p>

<div class="defun">
 Function: <b>elephant:drop-instances</b><var> instances &amp;key sc txn-size<a name="index-elephant_003adrop_002dinstances-48"></a></var><br>
<blockquote>
<p><a name="index-elephant_003adrop_002dinstances-49"></a>Removes a list of persistent objects from all class indices
   and unbinds any persistent slot values associated with those instances
</p>

</blockquote></div>

<!-- @subsection Direct Class Index Manipulation -->
<!-- @include includes/fun-elephant-find-class-index.texinfo -->
<!-- @include includes/fun-elephant-find-inverted-index.texinfo -->
<!-- @include includes/fun-elephant-make-class-cursor.texinfo -->
<!-- @include includes/macro-elephant-with-class-cursor.texinfo -->
<!-- @include includes/fun-elephant-make-inverted-cursor.texinfo -->
<!-- @include includes/macro-elephant-with-inverted-cursor.texinfo -->
<!-- @subsection Dynamic Indexing API -->
<!-- @include includes/fun-elephant-enable-class-indexing.texinfo -->
<!-- @include includes/fun-elephant-disable-class-indexing.texinfo -->
<!-- @include includes/fun-elephant-add-class-slot-index.texinfo -->
<!-- @include includes/fun-elephant-remove-class-slot-index.texinfo -->
<!-- @include includes/fun-elephant-add-class-derived-index.texinfo -->
<!-- @include includes/fun-elephant-remove-class-derived-index.texinfo -->
<div class="node">

<p></p>

<hr>
<a name="Persistent-Set-API"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#BTree-API">BTree API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Persistent-Object-Indexing-API">Persistent Object Indexing API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-API-Reference">User API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">5.4 Persistent Sets</h3>

<p><a name="index-Persistent-Sets-50"></a>
Persistent sets are a simple persistent collection abstraction.  They
maintain an unordered collection of objects.  Unlike the normal
list-oriented sets of Lisp, persistent sets use the equivalent of
<code>pushnew</code> such that only one copy of any object or value is
maintained using the serializer's <code>equal</code> implementation.

   </p>

<p><a name="Class-elephant_003apset"></a>

</p>

<div class="defun">
 Class: <b>elephant:pset</b><var><a name="index-elephant_003apset-51"></a></var><br>
<blockquote>
<p><a name="index-elephant_003apset-52"></a>Class precedence list: <code>pset<!-- /@w -->, persistent-collection<!-- /@w -->, persistent<!-- /@w -->, standard-object<!-- /@w -->, t<!-- /@w --></code>

        </p>

<p>An unordered persistent collection of unique elements according to
                   serializer equal comparison
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003ainsert_002ditem"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:insert-item</b><var> item pset<a name="index-elephant_003ainsert_002ditem-53"></a></var><br>
<blockquote>
<p><a name="index-elephant_003ainsert_002ditem-54"></a>Insert a new item into the pset
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003aremove_002ditem"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:remove-item</b><var> item pset<a name="index-elephant_003aremove_002ditem-55"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aremove_002ditem-56"></a>Remove specified item from pset
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003afind_002ditem"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:find-item</b><var> item pset &amp;key key test test<a name="index-elephant_003afind_002ditem-57"></a></var><br>
<blockquote>
<p><a name="index-elephant_003afind_002ditem-58"></a>Find a an item in the pset using key and test
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003amap_002dpset"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:map-pset</b><var> fn pset<a name="index-elephant_003amap_002dpset-59"></a></var><br>
<blockquote>
<p><a name="index-elephant_003amap_002dpset-60"></a>Map operator for psets
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003apset_002dlist"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:pset-list</b><var> pset<a name="index-elephant_003apset_002dlist-61"></a></var><br>
<blockquote>
<p><a name="index-elephant_003apset_002dlist-62"></a>Convert items of pset into a list for processing
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003adrop_002dpset"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:drop-pset</b><var> pset<a name="index-elephant_003adrop_002dpset-63"></a></var><br>
<blockquote>
<p><a name="index-elephant_003adrop_002dpset-64"></a>Release pset storage to database for reuse
</p>

</blockquote></div>

<!-- @node Query Interfaces -->
<!-- @comment node-name, next, previous, up -->
<!-- @section Query Interfaces -->
<!-- @cindex Query Interfaces -->
<!-- The query interface is currently unsupported.  See @code{query.lisp} -->
<!-- and @code{query-example.lisp} for a sketch of what the query interface -->
<!-- will eventually look like.  The upcoming version 0.9.1 will include -->
<!-- the query system and associated documentation system. -->
<!-- @include includes/fun-elephant-get-query-results.texinfo -->
<!-- @include includes/fun-elephant-map-class-query.texinfo -->
<div class="node">

<p></p>

<hr>
<a name="BTree-API"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#BTree-Cursor-API">BTree Cursor API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Persistent-Set-API">Persistent Set API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-API-Reference">User API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">5.5 BTrees</h3>

<p><a name="index-BTree-65"></a><a name="index-API-66"></a>

   </p>

<p>Persistent collections inherit from <a href="#Class-elephant_003apersistent_002dcollection">Class elephant:persistent-collection</a>
and consist of the <a href="#Class-elephant_003abtree">Class elephant:btree</a>, <a href="#Class-elephant_003aindexed_002dbtree">Class elephant:indexed-btree</a> and
 <a href="#Class-elephant_003abtree_002dindex">Class elephant:btree-index</a> classes.  The following operations are defined
on most of these classes.  More information can be found in <a href="#Persistent-BTrees">Persistent BTrees</a>
and <a href="#BTree-Indexing">BTree Indexing</a>.

   </p>

<p><a name="Function-elephant_003amake_002dbtree"></a>

</p>

<div class="defun">
 Function: <b>elephant:make-btree</b><var><a name="index-elephant_003amake_002dbtree-67"></a></var><br>
<blockquote>
<p><a name="index-elephant_003amake_002dbtree-68"></a>Constructs a new BTree instance for use by the user.  Each backend
   returns its own internal type as appropriate and ensures that the
   btree is associated with the store-controller that created it. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003aget_002dvalue"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:get-value</b><var> key bt<a name="index-elephant_003aget_002dvalue-69"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aget_002dvalue-70"></a>Get a value from a Btree. 
</p>

</blockquote></div>

<p>Values are written to a btree using the <code>setf</code> method on <code>get-value</code>. 
<!-- @include includes/fun-elephant-setf-get-value.texinfo -->

   </p>

<p><a name="Generic_002dFunction-elephant_003aremove_002dkv"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:remove-kv</b><var> key bt<a name="index-elephant_003aremove_002dkv-71"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aremove_002dkv-72"></a>Remove a key / value pair from a BTree. 
</p>

</blockquote></div>
   <a name="Method-elephant_003aremove_002dkv-_0028key-_0028bt-btree_002dindex_0029_0029"></a>

<div class="defun">
 Method: <b>elephant:remove-kv</b><var> key </var>(<var>bt btree-index</var>)<var><a name="index-elephant_003aremove_002dkv-73"></a></var><br>
<blockquote>
<p>Remove a key / value from the <code>primary</code> by a secondary
lookup, updating <code>all</code> other secondary indices. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003aexistsp"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:existsp</b><var> key bt<a name="index-elephant_003aexistsp-74"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aexistsp-75"></a>Test existence of a key / value pair in a BTree
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003adrop_002dbtree"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:drop-btree</b><var> bt<a name="index-elephant_003adrop_002dbtree-76"></a></var><br>
<blockquote>
<p><a name="index-elephant_003adrop_002dbtree-77"></a>Delete all key-value pairs from the btree and
   render it an invalid object in the data store
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003amap_002dbtree"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:map-btree</b><var> fn btree &amp;rest args &amp;key start end value from-end collect value &amp;allow-other-keys<a name="index-elephant_003amap_002dbtree-78"></a></var><br>
<blockquote>
<p><a name="index-elephant_003amap_002dbtree-79"></a>Map btree maps over a btree from the value start to the value of end. 
   If values are not provided, then it maps over all values.  BTrees
   do not have duplicates, but map-btree can also be used with indices
   in the case where you don't want access to the primary key so we
   require a value argument as well for mapping duplicate value sets. 
   The collect keyword will accumulate the results from
   each call of fn in a fresh list and return that list in the
   same order the calls were made (first to last). 
</p>

</blockquote></div>

<p>These functions are only defined on indexed btrees.

   </p>

<p><a name="Function-elephant_003amake_002dindexed_002dbtree"></a>

</p>

<div class="defun">
 Function: <b>elephant:make-indexed-btree</b><var><a name="index-elephant_003amake_002dindexed_002dbtree-80"></a></var><br>
<blockquote>
<p><a name="index-elephant_003amake_002dindexed_002dbtree-81"></a>Constructs a new indexed BTree instance for use by the user. 
   Each backend returns its own internal type as appropriate and
   ensures that the btree is associated with the store-controller
   that created it. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003aadd_002dindex"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:add-index</b><var> bt &amp;key index-name key-form populate<a name="index-elephant_003aadd_002dindex-82"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aadd_002dindex-83"></a>Add a secondary index.  The indices are stored in an eq
hash-table, so the index-name should be a symbol.  key-form
should be a symbol naming a function, a function call form
eg '(create-index 3) or a lambda expression <code>--</code>
actual functions aren't supported. 
Lambda expresssions are converted to functions through compile
and function call forms are transformed applying
the first element of the list to the rest of the list. 
The function should take 3 arguments: the secondary <code>db</code>, primary
key and value, and return two values: a boolean indicating
whether to index this key / value, and the secondary key if
so.  If populate = t it will fill in secondary keys for
existing primary entries (may be expensive!) 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003aget_002dindex"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:get-index</b><var> bt index-name<a name="index-elephant_003aget_002dindex-84"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aget_002dindex-85"></a>Get a named index. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003aget_002dprimary_002dkey"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:get-primary-key</b><var> key bt<a name="index-elephant_003aget_002dprimary_002dkey-86"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aget_002dprimary_002dkey-87"></a>Get the primary key from a secondary key. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003aremove_002dindex"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:remove-index</b><var> bt index-name<a name="index-elephant_003aremove_002dindex-88"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aremove_002dindex-89"></a>Remove a named index. 
</p>

</blockquote></div>

<p>This function is only valid for indexes.

   </p>

<p><a name="Generic_002dFunction-elephant_003amap_002dindex"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:map-index</b><var> fn index &amp;rest args &amp;key start end value from-end collect value &amp;allow-other-keys<a name="index-elephant_003amap_002dindex-90"></a></var><br>
<blockquote>
<p><a name="index-elephant_003amap_002dindex-91"></a>Map-index is like map-btree but for secondary indices, it
   takes a function of three arguments: key, value and primary
   key.  As with map-btree the keyword arguments start and end
   determine the starting element and ending element, inclusive. 
   Also, start = nil implies the first element, end = nil implies
   the last element in the index.  If you want to traverse only a
   set of identical key values, for example all nil values, then
   use the value keyword which will override any values of start
   and end.  The collect keyword will accumulate the results from
   each call of fn in a fresh list and return that list in the
   same order the calls were made (first to last)
</p>

</blockquote></div>

<div class="node">

<p></p>

<hr>
<a name="BTree-Cursor-API"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Index-Cursor-API">Index Cursor API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#BTree-API">BTree API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-API-Reference">User API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">5.6 Btree Cursors</h3>

<p><a name="index-Cursors-92"></a><a name="index-API-93"></a>
Cursors are objects of type cursor (see <a href="#Class-elephant_003acursor">Class elephant:cursor</a>)
which provide methods for complex traversals of BTrees.

   </p>

<p><a name="Macro-elephant_003awith_002dbtree_002dcursor"></a>

</p>

<div class="defun">
 Macro: <b>elephant:with-btree-cursor</b><var> var &amp;body body<a name="index-elephant_003awith_002dbtree_002dcursor-94"></a></var><br>
<blockquote>
<p><a name="index-elephant_003awith_002dbtree_002dcursor-95"></a>Macro which opens a named cursor on a BTree (primary or
not), evaluates the forms, then closes the cursor. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003amake_002dcursor"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:make-cursor</b><var> bt<a name="index-elephant_003amake_002dcursor-96"></a></var><br>
<blockquote>
<p><a name="index-elephant_003amake_002dcursor-97"></a>Construct a cursor for traversing BTrees. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dclose"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-close</b><var> cursor<a name="index-elephant_003acursor_002dclose-98"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dclose-99"></a>Close the cursor.  Make sure to close cursors before the
enclosing transaction is closed! 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dduplicate"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-duplicate</b><var> cursor<a name="index-elephant_003acursor_002dduplicate-100"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dduplicate-101"></a>Duplicate a cursor. 
</p>

</blockquote></div>
   <!-- fixme, not generated by docstrings -->
<!-- @include includes/fun-elephant-cursor-initialized-p.texinfo -->

<p>Each of the following methods return multiple values consisting of
<code>(exists? key value)</code>.

   </p>

<p><a name="Generic_002dFunction-elephant_003acursor_002dcurrent"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-current</b><var> cursor<a name="index-elephant_003acursor_002dcurrent-102"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dcurrent-103"></a>Get the key / value at the cursor position.  Returns
has-pair key value, where has-pair is a boolean indicating
there was a pair. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dfirst"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-first</b><var> cursor<a name="index-elephant_003acursor_002dfirst-104"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dfirst-105"></a>Move the cursor to the beginning of the BTree, returning
has-pair key value. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dlast"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-last</b><var> cursor<a name="index-elephant_003acursor_002dlast-106"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dlast-107"></a>Move the cursor to the end of the BTree, returning
has-pair key value. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dnext"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-next</b><var> cursor<a name="index-elephant_003acursor_002dnext-108"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dnext-109"></a>Advance the cursor, returning has-pair key value. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dprev"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-prev</b><var> cursor<a name="index-elephant_003acursor_002dprev-110"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dprev-111"></a>Move the cursor back, returning has-pair key value. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dset"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-set</b><var> cursor key<a name="index-elephant_003acursor_002dset-112"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dset-113"></a>Move the cursor to a particular key, returning has-pair
key value. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dset_002drange"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-set-range</b><var> cursor key<a name="index-elephant_003acursor_002dset_002drange-114"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dset_002drange-115"></a>Move the cursor to the first key-value pair with key
greater or equal to the key argument, according to the lisp
sorter.  Returns has-pair key value. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dget_002dboth"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-get-both</b><var> cursor key value<a name="index-elephant_003acursor_002dget_002dboth-116"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dget_002dboth-117"></a>Moves the cursor to a particular key / value pair,
returning has-pair key value. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dget_002dboth_002drange"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-get-both-range</b><var> cursor key value<a name="index-elephant_003acursor_002dget_002dboth_002drange-118"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dget_002dboth_002drange-119"></a>Moves the cursor to the first key / value pair with key
equal to the key argument and value greater or equal to the
value argument.  Not really useful for us since primaries
don't have duplicates.  Returns has-pair key value. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002ddelete"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-delete</b><var> cursor<a name="index-elephant_003acursor_002ddelete-120"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002ddelete-121"></a>Delete by cursor.  The cursor is at an invalid position,
and uninitialized, after a successful delete. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dput"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-put</b><var> cursor value &amp;key key<a name="index-elephant_003acursor_002dput-122"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dput-123"></a>Overwrite value at current cursor location.  Cursor remains
   at the current location
</p>

</blockquote></div>

<div class="node">

<p></p>

<hr>
<a name="Index-Cursor-API"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Transaction-API">Transaction API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#BTree-Cursor-API">BTree Cursor API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-API-Reference">User API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">5.7 Index Cursors</h3>

<p><a name="index-Cursor-124"></a><a name="index-Index-125"></a><a name="index-Indices-126"></a><a name="index-API-127"></a>
Index cursors are made the same way standard cursors are, with a call
to <code>make-cursor</code>, except with the index as the argument instead
of a standard btree.  In addition to the standard cursor operations,
which provide the direct key and value of a <code>btree-index</code>, the
following class of p cursors work on an index and allow you to get
the primary value of the <code>indexed-btree</code> that the
<code>btree-index</code> belongs to.

   </p>

<p>They each return multiple values <code>(exists? key primary-value
primary-key)</code>.

   </p>

<p><a name="Generic_002dFunction-elephant_003acursor_002dpcurrent"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-pcurrent</b><var> cursor<a name="index-elephant_003acursor_002dpcurrent-128"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dpcurrent-129"></a>Returns has-tuple / secondary key / value / primary key
at the current position. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dpfirst"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-pfirst</b><var> cursor<a name="index-elephant_003acursor_002dpfirst-130"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dpfirst-131"></a>Moves the key to the beginning of the secondary index. 
Returns has-tuple / secondary key / value / primary key. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dplast"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-plast</b><var> cursor<a name="index-elephant_003acursor_002dplast-132"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dplast-133"></a>Moves the key to the end of the secondary index.  Returns
has-tuple / secondary key / value / primary key. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dpnext"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-pnext</b><var> cursor<a name="index-elephant_003acursor_002dpnext-134"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dpnext-135"></a>Advances the cursor.  Returns has-tuple / secondary key /
value / primary key. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dpprev"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-pprev</b><var> cursor<a name="index-elephant_003acursor_002dpprev-136"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dpprev-137"></a>Moves the cursor back.  Returns has-tuple / secondary key
/ value / primary key. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dpset"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-pset</b><var> cursor key<a name="index-elephant_003acursor_002dpset-138"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dpset-139"></a>Moves the cursor to a particular key.  Returns has-tuple
/ secondary key / value / primary key. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dpset_002drange"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-pset-range</b><var> cursor key<a name="index-elephant_003acursor_002dpset_002drange-140"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dpset_002drange-141"></a>Move the cursor to the first key-value pair with key
greater or equal to the key argument, according to the lisp
sorter.  Returns has-pair secondary key value primary key. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dpget_002dboth"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-pget-both</b><var> cursor key value<a name="index-elephant_003acursor_002dpget_002dboth-142"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dpget_002dboth-143"></a>Moves the cursor to a particular secondary key / primary
key pair.  Returns has-tuple / secondary key / value /
primary key. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dpget_002dboth_002drange"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-pget-both-range</b><var> cursor key value<a name="index-elephant_003acursor_002dpget_002dboth_002drange-144"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dpget_002dboth_002drange-145"></a>Moves the cursor to a the first secondary key / primary
key pair, with secondary key equal to the key argument, and
primary key greater or equal to the pkey argument.  Returns
has-tuple / secondary key / value / primary key. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dnext_002dnodup"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-next-nodup</b><var> cursor<a name="index-elephant_003acursor_002dnext_002dnodup-146"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dnext_002dnodup-147"></a>Move to the next non-duplicate element (with different
key.)  Returns has-pair key value. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dnext_002ddup"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-next-dup</b><var> cursor<a name="index-elephant_003acursor_002dnext_002ddup-148"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dnext_002ddup-149"></a>Move to the next duplicate element (with the same key.) 
Returns has-pair key value. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dpnext_002dnodup"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-pnext-nodup</b><var> cursor<a name="index-elephant_003acursor_002dpnext_002dnodup-150"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dpnext_002dnodup-151"></a>Move to the next non-duplicate element (with different
key.)  Returns has-tuple / secondary key / value / primary
key. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dpnext_002ddup"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-pnext-dup</b><var> cursor<a name="index-elephant_003acursor_002dpnext_002ddup-152"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dpnext_002ddup-153"></a>Move to the next duplicate element (with the same key.) 
Returns has-tuple / secondary key / value / primary key. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dprev_002dnodup"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-prev-nodup</b><var> cursor<a name="index-elephant_003acursor_002dprev_002dnodup-154"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dprev_002dnodup-155"></a>Move to the previous non-duplicate element (with
different key.)  Returns has-pair key value. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dprev_002ddup"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-prev-dup</b><var> cursor<a name="index-elephant_003acursor_002dprev_002ddup-156"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dprev_002ddup-157"></a>Move to the previous duplicate element (with the same key.) 
Returns has-pair key value. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dpprev_002dnodup"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-pprev-nodup</b><var> cursor<a name="index-elephant_003acursor_002dpprev_002dnodup-158"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dpprev_002dnodup-159"></a>Move to the previous non-duplicate element (with
different key.)  Returns has-tuple / secondary key / value /
primary key. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acursor_002dpprev_002ddup"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:cursor-pprev-dup</b><var> cursor<a name="index-elephant_003acursor_002dpprev_002ddup-160"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor_002dpprev_002ddup-161"></a>Move to the previous duplicate element (with the same key.) 
Returns has-tuple / secondary key / value / primary key. 
</p>

</blockquote></div>

<div class="node">

<p></p>

<hr>
<a name="Transaction-API"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Migration-and-Upgrading-API">Migration and Upgrading API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Index-Cursor-API">Index Cursor API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-API-Reference">User API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">5.8 Transactions</h3>

<p><a name="index-Transaction-API-162"></a><a name="index-API-163"></a>

   </p>

<p><a name="Macro-elephant_003awith_002dtransaction"></a>

</p>

<div class="defun">
 Macro: <b>elephant:with-transaction</b><var> &amp;rest &amp;body body<a name="index-elephant_003awith_002dtransaction-164"></a></var><br>
<blockquote>
<p><a name="index-elephant_003awith_002dtransaction-165"></a>Execute a body with a transaction in place.  On success,
   the transaction is committed.  Otherwise, the transaction is
   aborted.  If the body deadlocks, the body is re-executed in
   a new transaction, retrying a fixed number of iterations. 
   If nested, the backend must support nested transactions. 
</p>

</blockquote></div>

<p>The following functions are an advanced use of the transaction system. 
They may be useful if, or example, you want to integrate Elephant
transactions with non-Elephant side-effects that you explicitely make
transactional.

   </p>

<p><a name="Generic_002dFunction-elephant_003acontroller_002dstart_002dtransaction"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:controller-start-transaction</b><var> store-controller &amp;key &amp;allow-other-keys<a name="index-elephant_003acontroller_002dstart_002dtransaction-166"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acontroller_002dstart_002dtransaction-167"></a>Start an elephant transaction
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acontroller_002dabort_002dtransaction"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:controller-abort-transaction</b><var> store-controller transaction &amp;key &amp;allow-other-keys<a name="index-elephant_003acontroller_002dabort_002dtransaction-168"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acontroller_002dabort_002dtransaction-169"></a>Abort an elephant transaction
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003acontroller_002dcommit_002dtransaction"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:controller-commit-transaction</b><var> store-controller transaction &amp;key &amp;allow-other-keys<a name="index-elephant_003acontroller_002dcommit_002dtransaction-170"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acontroller_002dcommit_002dtransaction-171"></a>Commit an elephant transaction
</p>

</blockquote></div>

<div class="node">

<p></p>

<hr>
<a name="Migration-and-Upgrading-API"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Transaction-API">Transaction API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-API-Reference">User API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">5.9 Migration and Upgrading</h3>

<p><a name="index-Migration-and-Upgrading-172"></a><a name="index-API-173"></a>
Upgrade is a call to Migrate with checks for compatability.  The
migrate methods are included here in case you wish to develop a more
specific partial upgrade or partial migrate of data from one
store to another instead of using the top-level copy which migrates all
live objects.

   </p>

<p><a name="Generic_002dFunction-elephant_003aupgrade"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:upgrade</b><var> sc spec<a name="index-elephant_003aupgrade-174"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aupgrade-175"></a>Given an open store controller from a prior version,
                   open a new store specified by spec and migrate the
                   data from the original store to the new one, upgrading
                   it to the latest version
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_003amigrate"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:migrate</b><var> dst src<a name="index-elephant_003amigrate-176"></a></var><br>
<blockquote>
<p><a name="index-elephant_003amigrate-177"></a>Migrate an object from the src object, collection or controller
    to the dst controller.  Returns a copy of the object in the new
    store so you can drop it into a parent object or the root of
    the dst controller
</p>

</blockquote></div>
   <a name="Method-elephant_003amigrate-_0028_0028dst-store_002dcontroller_0029-_0028src-hash_002dtable_0029_0029"></a>

<div class="defun">
 Method: <b>elephant:migrate</b> (<var>dst store-controller</var>) (<var>src hash-table</var>)<var><a name="index-elephant_003amigrate-178"></a></var><br>
<blockquote>
<p>Migrate each hash element as the types are non-uniform
</p>

</blockquote></div>
   <a name="Method-elephant_003amigrate-_0028_0028dst-store_002dcontroller_0029-_0028src-array_0029_0029"></a>

<div class="defun">
 Method: <b>elephant:migrate</b> (<var>dst store-controller</var>) (<var>src array</var>)<var><a name="index-elephant_003amigrate-179"></a></var><br>
<blockquote>
<p>We really only need to handle arrays of type 't' that point
   to other objects; fixnum, float, etc array can just be
   written to the new store but we don't bother to optimize here
</p>

</blockquote></div>
   <a name="Method-elephant_003amigrate-_0028_0028dst-store_002dcontroller_0029-_0028src-cons_0029_0029"></a>

<div class="defun">
 Method: <b>elephant:migrate</b> (<var>dst store-controller</var>) (<var>src cons</var>)<var><a name="index-elephant_003amigrate-180"></a></var><br>
<blockquote>
<p><code>warning:</code> This doesn't work for circular lists
</p>

</blockquote></div>
   <a name="Method-elephant_003amigrate-_0028_0028dst-store_002dcontroller_0029-_0028src-pathname_0029_0029"></a>

<div class="defun">
 Method: <b>elephant:migrate</b> (<var>dst store-controller</var>) (<var>src pathname</var>)<var><a name="index-elephant_003amigrate-181"></a></var><br>
<blockquote>
<p>Migrate pathname as just return itself
</p>

</blockquote></div>
   <a name="Method-elephant_003amigrate-_0028_0028dst-store_002dcontroller_0029-_0028src-structure_002dobject_0029_0029"></a>

<div class="defun">
 Method: <b>elephant:migrate</b> (<var>dst store-controller</var>) (<var>src structure-object</var>)<var><a name="index-elephant_003amigrate-182"></a></var><br>
<blockquote>
<p>Walks structure slot values and ensures that any persistent references
   are written back into the slot pointint to the new store
</p>

</blockquote></div>
   <a name="Method-elephant_003amigrate-_0028_0028dst-store_002dcontroller_0029-_0028src-standard_002dobject_0029_0029"></a>

<div class="defun">
 Method: <b>elephant:migrate</b> (<var>dst store-controller</var>) (<var>src standard-object</var>)<var><a name="index-elephant_003amigrate-183"></a></var><br>
<blockquote>
<p>If we have persistent objects that are unindexed and <code>only</code> stored in
   a standard object slot that is referenced from the root, then it
   will only be copied by recursing through the slot substructure just
   as the serializer will, but copying any persistent objects found
</p>

</blockquote></div>
   <a name="Method-elephant_003amigrate-_0028_0028dst-store_002dcontroller_0029-_0028src-indexed_002dbtree_0029_0029"></a>

<div class="defun">
 Method: <b>elephant:migrate</b> (<var>dst store-controller</var>) (<var>src indexed-btree</var>)<var><a name="index-elephant_003amigrate-184"></a></var><br>
<blockquote>
<p>Also copy the inverse indices for indexed btrees
</p>

</blockquote></div>
   <a name="Method-elephant_003amigrate-_0028_0028dst-store_002dcontroller_0029-_0028src-btree_0029_0029"></a>

<div class="defun">
 Method: <b>elephant:migrate</b> (<var>dst store-controller</var>) (<var>src btree</var>)<var><a name="index-elephant_003amigrate-185"></a></var><br>
<blockquote>
<p>Copy an index and it's contents to the target repository
</p>

</blockquote></div>
   <a name="Method-elephant_003amigrate-_0028_0028dst-store_002dcontroller_0029-_0028src-persistent_0029_0029"></a>

<div class="defun">
 Method: <b>elephant:migrate</b> (<var>dst store-controller</var>) (<var>src persistent</var>)<var><a name="index-elephant_003amigrate-186"></a></var><br>
<blockquote>
<p>Migrate a persistent object and apply a binary (lambda (dst src) ...) 
    function to the new object.  Users can override migrate by creating
    a function that calls the default copy and then does stuff with the
    slot values.  A dynamic variable: *inhibit-slot-copy* can be bound
    in the caller to keep the new object from having its slots copied
</p>

</blockquote></div>
   <a name="Method-elephant_003amigrate-after-_0028_0028dst-store_002dcontroller_0029-_0028src-store_002dcontroller_0029_0029"></a>

<div class="defun">
 Method: <b>after</b><var> elephant:migrate </var>(<var>dst store-controller</var>) (<var>src store-controller</var>)<var><a name="index-after-187"></a></var><br>
<blockquote>
<p>This method ensures that we reset duplicate object detection over the store-controller
</p>

</blockquote></div>
   <a name="Method-elephant_003amigrate-before-_0028_0028dst-store_002dcontroller_0029-_0028src-store_002dcontroller_0029_0029"></a>

<div class="defun">
 Method: <b>before</b><var> elephant:migrate </var>(<var>dst store-controller</var>) (<var>src store-controller</var>)<var><a name="index-before-188"></a></var><br>
<blockquote>
<p>This method ensures that we reset duplicate object detection over the store-controller
</p>

</blockquote></div>
   <a name="Method-elephant_003amigrate-before-_0028_0028dst-store_002dcontroller_0029-_0028src-persistent_0029_0029"></a>

<div class="defun">
 Method: <b>before</b><var> elephant:migrate </var>(<var>dst store-controller</var>) (<var>src persistent</var>)<var><a name="index-before-189"></a></var><br>
<blockquote>
<p>This provides some sanity checking that we aren't trying to copy
   to the same controller.  We also need to be careful about deadlocking
   our transactions among the two gets/puts.  Each leaf migration should
   be in its own transaction to avoid too many write locks. 
</p>

</blockquote></div>
   <a name="Method-elephant_003amigrate-_0028_0028dst-store_002dcontroller_0029-src_0029"></a>

<div class="defun">
 Method: <b>elephant:migrate</b> (<var>dst store-controller</var>)<var> src<a name="index-elephant_003amigrate-190"></a></var><br>
<blockquote>
<p>Default: standard objects are automatically migrated
</p>

</blockquote></div>

<!-- *-texinfo-*- -->
<div class="node">

<p></p>

<hr>
<a name="Design-Patterns"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Elephant-Architecture">Elephant Architecture</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#User-API-Reference">User API Reference</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name, next, previous, up -->
<h2 class="chapter">6 Design Patterns</h2>

<p><a name="index-Design-Patterns-191"></a>

</p>

<ul class="menu">
<li><a accesskey="1" href="#File-System-Replacement">File System Replacement</a>:  Deployment of Elephant as file replacement
</li><li><a accesskey="2" href="#Checkpointing-Conventional-Program-State">Checkpointing Conventional Program State</a>:
  How to recover the application state as recorded in a set of 
interdependant standard classes for purposes of undo, crash recovery and
 session persistence. 
</li><li><a accesskey="3" href="#Persistent-System-Objects">Persistent System Objects</a>:  Making persistent objects a natural part of your system
</li><li><a accesskey="4" href="#Elephant-as-Database">Elephant as Database</a>:  Using Elephant as a database for records and user data instead of using a SQL relational Database
</li><li><a accesskey="5" href="#Multithreaded-Web-Applications">Multithreaded Web Applications</a>:  Elephant is a natural match for web applications
<!-- * Graph-oriented Applications:: Elephant is good, but not optimized, for graph-oriented applications. -->
</li><li><a accesskey="6" href="#Real_002dWorld-Application-Examples">Real-World Application Examples</a>:
  See some real-world applications Elephant has been used for and a 
brief discussion of how it was used and any novel uses of Elephant. 
</li></ul>

<p>This chapter explores different ways that Elephant can be used to
solve common problems in user programs.  The term Design Pattern
may be overkill as there is no formal specification of patterns. 
However the goals is similar to classical design patterns: provide a
coherent description of how to approach ceratain common problems using
Elephant as an enabling tool.

   </p>

<p>Most of this chapter falls short of a tutorial in the application of a
pattern.  Instead it provides a conceptual guide to implementing the
pattern along with some code examples to show how Elephant features
are invoked to support the pattern.

   </p>

<p>The authors hope that users of Elephant will find this a good source
of inspiration for how to apply Elephant to their own programs and
that they will be motivated to contribute design patterns of their own.

</p>

<div class="node">

<p></p>

<hr>
<a name="Persistent-System-Objects"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Elephant-as-Database">Elephant as Database</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Checkpointing-Conventional-Program-State">Checkpointing Conventional Program State</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Design-Patterns">Design Patterns</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">6.1 Persistent System Objects</h3>

<p>The simplest design pattern supported by Elephant is the use of
persistent objects in the place of standard objects.  Typically you
can just modify the old class definition to inherit the
<code>persistent-metaclass</code>.  Depending on your application, objects
may need to have transient slots for performance reasons.  We'll
create a dummy class to illustrate:

</p>

<pre class="lisp">     (defclass system-object ()
       ((appname :accessor system-appname :initarg :name)
        (url :accessor system-url :initarg :url)
        (state :accessor system-state :initarg :state :initform 'idle))
       (:metaclass persistent-metaclass))
</pre>

<p>When starting up your application you need to recover references to
any persistent objects that were created in a prior session or
initialize a new one.

   </p>

<p>If you are storing system objects in parameters, you can just call
an initialization function on startup:

</p>

<pre class="lisp">     (defparameter *system* nil)

     (defun initialize-system (appname)
       (let ((system-object (get-from-root '*system*)))
         (setf *system
               (if system-object system-object
                   (make-instance 'system-object :name appname)))))

     *system*
     =&gt; #&lt;SYSTEM-OBJECT ...&gt;
</pre>

<p>And now you can use your parameter as you did before.  If you want to
avoid calling initialization functions, you can just accesss system
objects through functions instead of parameters.

</p>

<pre class="lisp">     (defparameter *system* nil)

     (defun sys-object ()
       (unless *system
         (let ((appname (get-application-name))
               (url (get-system-url)))
           (setf *system* (make-instance 'system-object
                                         :name appname
                                         :url url))))
       *system*)

     (sys-object)
     =&gt; #&lt;SYSTEM-OBJECT ...&gt;
</pre>

<p>One constraint to keep in mind is that slot access will be slower as
it has to synchronize to disk.  This is usually not noticable for
objects that are accessed on the order of seconds instead of
milliseconds.  For objects read constantly, but where you want to save
any written values it helps to have a transient slot to cache values. 
You can override some methods to ensure that the persistent value is
always updated, but that reads happen from the cached value and that
the cached value is restored whenever the object is loaded.

</p>

<pre class="lisp">     (defclass system-object ()
       ((appname :accessor system-appname :initarg :name)
        (url :accessor system-url :initarg :url)
        (laststate :accessor system-laststate :initarg :state
                   :initform 'idle)
        (state :accessor system-state :initarg :state :transient t)
       (:metaclass persistent-metaclass))

     (defmethod (setf system-state) :after (state (sys system-state))
       (setf (system-laststate sys) state))

     (defmethod initialize-instance :after ((sys system-state) &amp;rest rest)
       (declare (ignore rest))
       (when (slot-boundp sys 'laststate)
         (setf (system-state sys) (system-laststate sys))))
</pre>

<p>And now you have an instant read cache for a slot value.  This pattern
is used several times within the Elephant implementation.

</p>

<div class="node">

<p></p>

<hr>
<a name="File-System-Replacement"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Checkpointing-Conventional-Program-State">Checkpointing Conventional Program State</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Design-Patterns">Design Patterns</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">6.2 File System Replacement</h3>

<p>One of the more annoying time-wasting activities in programming is
saving and restoring data from disk.  Data in configuration files,
static data such as graphics and other formats take time and attention
away from solving the main problem and are additional sources of bugs. 
Because Elephant's serializer supports most lisp types, Elephant can
greatly simplify ease these concerns and allow you to work directly
with your natural in-memory representations with almost no work to
encode/decode formats or manage files in the file
system<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>.

   </p>

<p>The simplest way to accomplish this is to simply open a store
controller and initialize a key-value pair in the root btree as a
instead of a filename and file data in some system directory.  Like
the initialization process described for standard objects, you can
hide some of the details like this:

</p>

<pre class="lisp">     (defvar *resources* (make-hash-table))

     (defun get-resource (name)
       (multiple-value-bind (value foundp) (gethash name *resources*)
         (if foundp
             value
             (multiple-value-bind (value foundp) (get-from-root name)
                (if foundp
                    value
                    (error "Resource named ~A was not initialized" name))))))

     (defun set-resource (value name)
       (add-to-root name value)
       (setf (gethash name *resources*) value))

     (defsetf get-resource set-resource)
</pre>

<p>Another simple metaphor is to use Elephant btrees as persistent hash
tables that persist key-value pairs for you.  We'll wrap the Elephant
btree in a simple class to provide a little conceptual isolation.

</p>

<pre class="lisp">     (defclass phash ()
       ((btree :accessor phash-btree :initarg :btree
               :initform (make-btree))))

     (defun make-persistent-hash (name)
       (let ((btree (get-from-root name)))
         (if btree
             (make-instance 'phash :btree btree)
             (let ((phash (make-instance 'phash)))
                (add-to-root name (phash-btree phash))
                phash))))

     (defun getphash (key phash)
       (get-value key (phash-btree phash)))

     (defun setphash (value key phash)
       (setf (get-value key (phash-btree phash)) value))

     (defsetf getphash setphash)
</pre>

<p>Of course to make a proper abstraction we'd want to provide some
conditions that allowed restarts that initialized values or allowed
users to update the hash in the background and continue computation.

</p>

<div class="node">

<p></p>

<hr>
<a name="Checkpointing-Conventional-Program-State"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Persistent-System-Objects">Persistent System Objects</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#File-System-Replacement">File System Replacement</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Design-Patterns">Design Patterns</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">6.3 Checkpointing Conventional Program State</h3>

<p>Another challenge for many programs is saving some subset of program
state.  This could involve checkpointing an evolving computation,
keeping track of state for the purposes of 'undo' or enabling crash
recovery at key points in the program's execution.

   </p>

<p>One approach is to transform all our program state into persistent
objects.  However if the use of program state is slot-access
intensive, this can have a significant performance impact.  To improve
the performance of the application, careful use of transactions is
needed which further complicates program design and operation.

   </p>

<p>Can Elephant be used to provide a simple solution that retains the
in-memory performance that we want?  Can we do all this without having
to put a ton of persistence assumptions into our main program code? 
The answer is yes, assuming you are willing to explicitly checkpoint
your code and adhere to some simple constraints in accessing your
program objects.

</p>

<h4 class="subsection">6.3.1 Assumptions</h4>

<p>To maintain processing speed and convenience we would like all our
objects to be standard lisp objects without special harnesses that
would interfere with applying the full power of lisp.  At some point
during execution, we want to store the current state of a set of
objects to disk and yet make it easy to reproduce the original state
at a later point in time.  For simplicity, we'll limit ourselves
to collections of CLOS objects.

   </p>

<p>A complication is that many programs have sets of interdependant
objects.  These could be complex program graphs, the state of an
ongoing search process or a standard OO system that uses a bunch of
different program object types to run.  This means that we need to
persist not just object state, but also references to other objects.

   </p>

<p>Using CLOS reflection we can provide a general solution to capturing
objects, slot values and references.  However to reproduce references,
we'll need to be able to find the object referenced and the only way
to do that is to store it as well.  Thus we want to create a snapshot
of a closed set of self-referential objects.

   </p>

<p>The assumptions underlying the snapshot mechanism is:

     </p>

<ul>
<li><strong>Use standard CLOS objects and references to other CLOS objects.</strong>
We need reflection to
</li><li><strong>Use standard hash tables to keep track of sets of objects.</strong>
Your program should use the hash table as an entry point to find
objects.  When objects are restored, just replace an existing hash
table with the new one and access your objects that way.  Any parts of
your program that have pointers into your objects but are not
themselves snapshotted, will need to be able to refresh their pointers
in some way. 
</li><li><strong>Find your root object (s) and know what is reachable from them.</strong>
Ensure that you aren't referring to standard objects outside those you
want to store as they will be stored too (persistent object references
are fine though).  Make sure your root refers to objects that refers
to other objects and so on such that all objects you want to store can
be reached by some set of pointer traversals.  Looping references are
fine. 
</li></ul>

<h4 class="subsection">6.3.2 Snapshot Set</h4>

<p>The snapshot implementation is called a <code>snapshot-set</code>.  The next
section will go into detail, but a walkthrough will help make it
clearer<a rel="footnote" href="#fn-3" name="fnd-3"><sup>3</sup></a>.

   </p>

<p>A snapshot set is quite easy to use.  Load the complete code and play
with this simple walk through.  The code can be located in the
Elephant source tree under <code>src/conrib/eslick/snapshot-set.lisp</code>.

   </p>

<p>The first step is to create a <code>snapshot-set</code> object,

</p>

<pre class="lisp">     (setf my-set (make-instance 'snapshot-set))
</pre>

<p>and add it to the root so we don't lose track of it.

</p>

<pre class="lisp">     (add-to-root 'my-set my-set)
</pre>

<p>Then we need some objects to play with.

</p>

<pre class="lisp">     (defclass my-test-class ()
       ((value :accessor test-value :initarg :value)
        (reference :accessor test-reference :initarg :reference)))

     (setf obj1 (make-instance 'my-test-class :value 1 :reference nil))
     (setf obj2 (make-instance 'my-test-class :value 2 :reference obj1))
     (setf obj3 (make-instance 'my-test-class :value 3 :reference obj2))

     (register-object obj3 my-set)
     (snapshot my-set)
</pre>

<p>Now your set should have persistent versions of all three classes that
are reachable from <code>obj3</code>.

</p>

<pre class="lisp">     (map-set (lambda (x) (print (test-value x))) my-set)
     =&gt;
     3
     2
     1
</pre>

<p>Of course such fully connected objects are not always common, so we'll
demonstrate using hash tables to create root indexes into our objects
and sidestep registration calls entirely.  We'll create a fresh set to
work with.

</p>

<pre class="lisp">     (setf my-set (make-instance 'snapshot-set))
     (add-to-root 'my-set my-set)

     (setf obj4 (make-instance 'my-test-class :value 4 :reference obj1))
     (setf obj5 (make-instance 'my-test-class :value 5 :reference nil))

     (setf hash (make-hash-table))
     (setf (snapshot-root my-set) hash)

     (setf (gethash 'obj3 hash) obj3)
     (setf (gethash 'obj4 hash) obj4)
     (setf (gethash 'obj5 hash) obj5)

     (snapshot my-set)
</pre>

<p>To properly simulate restoring objects, we need to drop our old hash
table as well as clear the persistent object cache so the snapshot set
transient object is reset.

</p>

<pre class="lisp">     (setf my-set nil)
     (setf hash nil)
     (elephant::flush-instance-cache *store-controller*)
</pre>

<p>Now we'll pretend we're startup up a new session.

</p>

<pre class="lisp">     (setf my-set (get-from-root 'my-set))
     (setf hash (snapshot-root my-set))
</pre>

<p>The cache is automatically populated by the implicit <code>restore</code>
call during snapshot-set initialization, and our hash table should now
have all the proper references.  We'll pull out a few.

</p>

<pre class="lisp">     (setf o4 (gethash 'obj4 hash))
     (setf o3 (gethash 'obj3 hash))
     (setf o2 (test-reference o3))

     (not (or (eq o4 obj4)
              (eq o3 obj3)
              (eq o2 obj2)))
     =&gt; t
</pre>

<p>The new objects should not be eq the old ones as we have restored
fresh copies from the disk.

   </p>

<p>If you review the setup above, <code>obj3</code> references <code>obj2</code>
which references <code>obj1</code> and <code>obj4</code> also references
<code>obj1</code>.  So if the objects were properly restored, these
references should be <code>eq</code>.

</p>

<pre class="lisp">     (eq (test-reference o2) (test-reference o4))
     =&gt; t
</pre>

<p>And finally we can demonstrate the restorative power of snapshot sets.

</p>

<pre class="lisp">     (remhash 'obj5 hash)

     (gethash 'obj5 hash)
     =&gt; nil nil

     (restore my-set)
     (setf hash (snapshot-root my-set))

     (gethash 'obj5 hash)
     =&gt; #&lt;MY-TEST-CLASS ..&gt; t

     (test-value *)
     =&gt; 5
</pre>

<p>This means that while our set object was not reset, the restore
operation properly restored the old reference structure of our root
hash object.  Unfortunately, in this implementation you have to reset
your lisp pointers to get access to the restored objects.

   </p>

<p>A future version could traverse the existing object cache, dropping
new references and restoring old ones so that in-memory lisp pointers
were still valid.

</p>

<h4 class="subsection">6.3.3 Snapshot Set Implementation</h4>

<p>In this section we walk through the implementation of the snapshot set
in detail as it provides:

     </p>

<ul>
<li>Insight into constraints in serialization and lisp object identity
</li><li>How to leverage Elephant for some more sophisticated applications than
      persistent indices and class slots. 
</li><li>Helps you understand a useful utility (that we may add to an extensions
      release in the future)
</li></ul>

<p>To generalize the behavior discussed above, we will define a new
persistent class called a snapshot set.  The set itself is a wrapper
around the btree, but provides all the automation to store and recover
sets of standard objects.

</p>

<pre class="lisp">     (defpclass snapshot-set ()
       ((index :accessor snapshot-set-index :initform (make-btree))
        (next-id :accessor snapshot-set-next-id :initform 0)
        (root :accessor snapshot-set-root :initform nil)
        (cache :accessor snapshot-set-cache
               :initform (make-hash-table :weak-keys t)
               :transient t)
        (touched :accessor snapshot-set-touched
                 :initform (make-array 20 :element-type 'fixnum
                              :initial-element 0 :fill-pointer t
                              :adjustable t)
                 :transient t))
       (:documentation "Keeps track of a set of standard objects
         allowing a single snapshot call to update the store
         controller with the latest state of all objects registered with
         this set"))
</pre>

<p>The set class keeps track of IDs, a set of cached objects in memory,
the on-disk btree for storing instances by uid and the current uid
variable value.  Notice the use of the transient keyword argument for
the cache.

   </p>

<p>There are two major operations supported by sets <code>snapshot</code> and
<code>restore</code>.  These save objects to disk and restore objects to
memory, along with proper recovery of multiple references to the same
object.

   </p>

<p>Additional operations are:

     </p>

<ul>
<li>Registration: Adding and removing objects from a set
</li><li>Root operations: Easy access to a single root hash table or object
</li><li>Mapping: Walk over all objects in a set
</li></ul>

<p>To enable snapshots, we have to register a set of root objects with
the set. This function ignores objects that are already cached,
otherwise allocates a new ID and caches the object.

</p>

<pre class="lisp">     (defmethod register-object ((object standard-object) (set snapshot-set))
       "Register a standard object.  Not recorded until
        the snapshot function is called on db"
       (aif (lookup-cached-id object set)
            (values object it)
            (let ((id (incf (snapshot-set-next-id set))))
     	 (cache-snapshot-object id object set)
     	 (values object id))))

     (defun lookup-cached-id (obj set)
       (gethash obj (snapshot-set-cache set)))

     (defun cache-snapshot-object (id obj set)
       (setf (gethash obj (snapshot-set-cache set)) id))
</pre>

<p>A parallel function registers hash tables.  One very important
invariant implied here is that the cache always contains objects that
are eq and mapped back to a serialized object in the backing btree. 
There is no need, however, to immediately write objects to the store
and this gives us some transactional properties: snapshots are atomic,
consistent and durable.  Isolation is not enforced by snapshots.

   </p>

<p>This means that the transient cache has to be valid immediately after
the snapshot set is loaded from the data store.

</p>

<pre class="lisp">     (defmethod initialize-instance :after ((set snapshot-set) &amp;key lazy-load &amp;allow-other-keys)
       (unless lazy-load (restore set)))
</pre>

<p>This also has consequences for unregistration.  Removing a root object
should also result in the removal of all objects that are unreachable
from other roots.  However, since side effects are not permanent until
a snapshot operation, we merely have to garbage collect id's that were
not touched during a snapshot operation.  This makes unregistration
simple.

</p>

<pre class="lisp">     (defmethod unregister-object (object (set snapshot-set))
       "Drops the object from the cache and backing store"
       (let ((id (gethash object (snapshot-set-cache set))))
         (when (null id)
           (error "Object ~A not registered in ~A" object set))
         (drop-cached-object object set)))
</pre>

<p>But snapshots are a little bit more work.

</p>

<pre class="lisp">     (defmethod snapshot ((set snapshot-set))
       "Saves all objects in the set (and any objects reachable from the
        current set of objects) to the persistent store"
       (with-transaction (:store-controller (get-con
                                              (snapshot-set-index set)))
         (loop for (obj . id) in
                   (get-cache-entries (snapshot-set-cache set))
               do
     	  (save-snapshot-object id obj set))
         (collect-untouched set)))

     (defun save-snapshot-object (id obj set)
       (unless (touched id set)
         (setf (get-value id (snapshot-set-index set))
     	  (cond ((standard-object-subclass-p obj)
     		 (save-proxy-object obj set))
     		((hash-table-p obj)
     		 (save-proxy-hash obj set))
     		(t (error "Cannot only snapshot standard-objects and hash-tables"))))
         (touch id set))
       id)

     (defun collect-untouched (set)
       (map-btree (lambda (k v)
     	       (unless (touched k set)
     		 (remove-kv k (snapshot-set-index set))))
     	     (snapshot-set-index set))
       (clear-touched set))
</pre>

<p>We go through all objects in the cache, storing objects as we go via
<code>save-snapshot-object</code>.  This function is responsible for storing
objects and hash tables and recursing on any instances that are
referenced.  Any object that is saved is added to a touch list so they
are not stored again and we can mark stored instances for the
<code>collect-untouched</code> call which ensures that newly unreachable
objects are deleted from the persistent store.  Any newly found
objects are added to the in-memory cache which, being a weak array,
should eventually drop references to objects that are not referred to
elsewhere.

   </p>

<p>It should be noted that garbage objects not garbage collected from the
weak-array based cache may be stored to and restored from the
persistent store.  However this is merely a storage overhead as they
will eventually be dropped across sessions as there are no saved
references to them.

   </p>

<p>Now when we serialize a standard object, all the slot values are
stored inline.  This means that by default, a slot that refers to a
standard object would get an immediately serialized version rather
than a reference.  This of course makes it impossible to restore
multiple references to a single object.  The approach taken here is to
instantiate a <em>proxy</em> object which is a copy of the original
class and stores references to normal values in its slots.  Any
references to hashes or standard classes are replaced with a reference
object that records the unique id of the object so it can be properly
restored.

</p>

<pre class="lisp">     (defun save-proxy-object (obj set)
       (let ((svs (subsets 2 (slots-and-values obj))))
         (if (some #'reified-class-p (mapcar #'second svs))
     	(let ((proxy (make-instance (type-of obj))))
     	  (loop for (slotname value) in svs do
     	       (setf (slot-value proxy slotname)
     		     (if (reify-class-p value)
     			 (reify-value value set)
     			 value)))
     	  proxy)
     	obj)))
</pre>

<p>The function checks whether any slot value can be reified (represented
by a unique id) and if so, makes a new proxy instance and properly
instantiates its slots, returning it to the main store function which
writes the proxy object to the btree.

   </p>

<p>On restore, we simply load all objects into memory.

</p>

<pre class="lisp">     (defmethod restore ((set snapshot-set))
       "Restores a snapshot by setting the snapshot-set state to the last
     snapshot.  If this is used during runtime, the user needs to drop all
     references to objects and retrieve again from the snapshot set.  Also
     used to initialize the set state when a set is created, for example
     pulled from the root of a store-controller, unless :lazy-load is
     specified"
       (clear-cache set)
       (map-btree (lambda (id object)
     	       (load-snapshot-object id object set))
     	     (snapshot-set-index set)))

     (defun load-snapshot-object (id object set)
       (let ((object (ifret object (get-value id (snapshot-set-index set)))))
         (cond ((standard-object-subclass-p object)
     	   (load-proxy-object id object set))
     	  ((hash-table-p object)
     	   (load-proxy-hash id object set))
     	  (t (error "Unrecognized type ~A for id ~A in set ~A"
                         (type-of object) id set)))))
</pre>

<p>If an object has a reference object in a slot, then we simply restore
that object as well.  <code>load-snapshot-object</code> accepts null for an
object so it can be used recursively when a reference object refers to
an object (via the unique id) that is not yet cached.  The <code>load</code>
functions return an object so that they can used directly to create
values for writing slots or hash entries.

</p>

<pre class="lisp">     (defun load-proxy-object (id obj set)
       (ifret (lookup-cached-object id set)
     	 (progn
     	   (cache-snapshot-object id obj set)
     	   (let ((svs (subsets 2 (slots-and-values obj))))
     	     (loop for (slotname value) in svs do
     		  (when (setrefp value)
     		    (setf (slot-value obj slotname)
     			  (load-snapshot-object (snapshot-set-reference-id value) nil set)))))
     	   obj)))
</pre>
   <h4 class="subsection">6.3.4 Isolating multiple snapshot sets</h4>

<p>A brief note on how to separate out the objects you want to store from
those you don't may be useful.  We want to snapshot groups of
inter-referential objects without sucking in the whole system in one
snapshot.  These object sets must be closed and fully connected.  If
the program consists of a set of subgraphs, a root element of each
graph should be stored in a hash table that is then treated as the
snapshot root.

     </p>

<ul>
<li><strong>Manual registration:</strong>
Objects without external references are easy, just <code>register</code> or
<code>unregister</code> them from the <code>snapshot-set</code> as needed and then
map over them to get them back. 
</li><li><strong>Implicit registration:</strong>
Just store objects in a hash that is the root of a <code>snapshot-set</code>
and you are good to go. 
</li><li><strong>Graphs:</strong>
Graphs are easy to store as they naturally consist of a closed set of
objects.  If the graph nodes reference other system objects that you
don't want to store, you'll need to implement something akin to the
indirection provided here.  Just store the root of the graph in the
snapshot set root and go from there. 
</li><li><strong>All instances of a type:</strong>
Another easy way to create sets is to overload <code>make-instance</code> to
store all new objects in a weak hash table that is treated as the root
of a <code>snapshot-set</code> (NOTE: I have not verified that weak hashes
are properly serialized and reproduced - I suspect they are not so you
might have to copy after a <code>restore</code>). 
</li></ul>

<p>For more complex applications, you can isolate these closed sets of
objects by using <code>snapshot-set</code> root hash tables as an
indirection mechanism.  Instead of storing direct references in an
object slot or hash value, isolation is ensured by storing keys and
indirecting through a hash table to get the target object.  This can
be hidden from the programmer in multiple ways.  The easiest way is
just to make sure that when you store references you store a key and
overload the slot accessor.  A sketch of this follows:

</p>

<pre class="lisp">     (defparameter *island1-hash* (make-hash-table))
     (defparameter *island2-hash* (make-hash-table))
     (defvar *unique-id* 0)

     (defclass island1-object ()
       ((pointer-to-island1 :accessor child :initform nil)
        (pointer-to-island2 :accessor neighbor :initform nil)))

     (defmethod neighbor :around ((obj island1-object))
       (let ((key (call-next-method)))
          (when key (gethash key *island2-hash*))))

     (defmethod (setf neighbor) :around (ref (obj island1-object))
       (cond ((subtypep (type-of ref) 'island2-object)
              (let ((key (find-object ref *island2-hash*)))
                (if key
                    (progn
                      (call-next-method key obj)
                      obj)
                    (progn
                      (setf (gethash (incf *unique-id*) *island2-hash*) ref)
                      (call-next-method *unique-id* obj)
                      obj))))
             (t (call-next-method))))

     (defun find-object (obj hash)
        (map-hash (lambda (k v)
                    (declare (ignore k))
                    (if (eq obj v)
                        (return-from find-object obj)))
                   hash))
</pre>

<p>The same template would apply to <code>island2</code> references to
<code>island1</code> objects.  You could further simplify creating these
hash table indirections with a little macro:

</p>

<pre class="lisp">     (defmacro def-snapshot-wrapper (accessor-name
               (source-classname target-classname hashname uid))
       (with-gensysms (obj key ref)
        `(progn
           (defmethod ,accessorname :around ((,obj ,source-classname))
              (let ((,key (call-next-method)))
                (when ,key (gethash ,key ,hashname))))
           (defmethod (setf ,accessorname) :around
                      (,ref (,obj ,source-classname))
              (cond ((subtypep (type-of ,ref) ,target-classname)
                     (let ((,key (find-object ,ref ,hashname)))
                       (if ,key
                           (progn
                             (call-next-method ,key ,obj)
                             ,obj)
                           (progn
                             (setf (gethash (incf ,uid) ,hashname) ,ref)
                             (call-next-method ,uid ,obj)
                             ,obj))))
                    (t (call-next-method)))))))

     (defclass island2-object ()
       ((pointer-to-island2 :accessor child :initform nil)
        (pointer-to-island1 :accessor neighbor :initform nil)))

     (def-snapshot-wrapper neighbor
                           (island2 island1 *island1-hash* *unique-id*))
</pre>

<p>Of course this doesn't work for multi-threaded environments, or for
separating more complex collections of types.  I am also sure that
more elegant solutions are possible.  In most cases, we assume the
user will have a natural collection of objects that can be closed over
by types or references so such efforts are unnecessary.

</p>

<div class="node">

<p></p>

<hr>
<a name="Elephant-as-Database"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Multithreaded-Web-Applications">Multithreaded Web Applications</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Persistent-System-Objects">Persistent System Objects</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Design-Patterns">Design Patterns</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">6.4 Elephant as Database</h3>

<p>As we move beyond replacing standard objects with persistent objects
and using Elephant to save conventional lisp data, we can exploit
Elephant's advanced class indexing features and the query system. 
With these facilities, Elephant can be used as a full-fledged object
oriented database system

   </p>

<p><em>NOTE: Will finish this section after the query engine is done
            as it will be more coherent/complete</em>

</p>

<div class="node">

<p></p>

<hr>
<a name="Multithreaded-Web-Applications"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Real_002dWorld-Application-Examples">Real-World Application Examples</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Elephant-as-Database">Elephant as Database</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Design-Patterns">Design Patterns</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">6.5 Multithreaded Web Applications</h3>

<p>Web applications can exploit all of the patterns described in previous
sections.  Each server thread can have transactional access to objects
encapsulating user data, commercial transactions, database data, etc. 
Users can formulate queries against objects and get html rendering of
the result views.

   </p>

<p>The most important characteristic of Elephant in these settings is
that instances and <code>store-controller</code> objects in versions 0.9 and
greater are automatically thread-safe.  The only consideration in
these cases is transaction design.

   </p>

<p><em>NOTE: What are common wrappers for Elephant that come up in web
applications?  Presentation functions?</em>

   </p>

<p><em>NOTE: Should this section be supplanted by a full application example
which uses most of the patterns above?</em>

<!-- @node Graph-oriented Applications -->
<!-- @comment node-name, next, previous, up -->
<!-- @section Graph-oriented Applications -->
<!-- Graph traversal and matching -->
<!-- Using the query system for graph queries -->
<!-- Performance issues -->
</p>

<div class="node">

<p></p>

<hr>
<a name="Real-World-Application-Examples"></a>
<a name="Real_002dWorld-Application-Examples"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Multithreaded-Web-Applications">Multithreaded Web Applications</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Design-Patterns">Design Patterns</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">6.6 Real-World Application Examples</h3>

<p>This section contains a collection of case studies or overviews of
read-world applications that have exploited Elephant.

</p>

<h4 class="subsection">6.6.1 Konsenti</h4>

<p>Elephant is used by Konsenti(tm), a for-profit company of Robert
L. Read, one of the maintainers of Elephant.  It can be visited at
<a href="http://konsenti.com/">http://konsenti.com</a>.

   </p>

<p>Konsenti uses the Data Collection Management (DCM) package, found in
the <code>src/contrib/rread directory</code>.  DCM provides
prevalence-style in-memory write-through caching.  The most enjoyable
feature about Elephant for this project is that new Business Layer
objects can be created without having to deal with an
Object-Relational Mapping, enabling extremely rapid development.

   </p>

<p>All Business objects are persisted via a <code>director</code> in DCM (which
sits on top of Elephant.)  Many of these business objects are in fact
finite state machines decorated with functions.  The functions are
represented by lambda s-expressions stored in slots on the business
objects.  A complete Message Factory and double-entry accounting
system are also implemented as DCM objects.  Binary objects, such as
uploaded PDFs, can be attached to objects as comments and are stored
directly in Elephant.  Konsenti is based on utf-8, and unicode
characters outside of the ISO-8859-1 character set are routinely
stored in Elephant.  Konsenti uses Postgres as a backend for licensing
reasons; but use of other data stores is possible.

</p>

<h4 class="subsection">6.6.2 Conceptminer</h4>

<p>Conceptminer is an Elephant-based web-mining framework developed by
Ian Eslick (<a href="http://www.media.mit.edu/~eslick">http://www.media.mit.edu/~eslick</a>) that performs
large-scale text analysis over the web to identify semantic
relationships such as PartOf, DesireOf and EffectOf
between English phrases.

   </p>

<p>Elephant's persistence capability is used to keep full records of
all source material, extracted relationships and search queries so
that it is always possible to trace the source of a learned relation
and to avoid repeated queries to web search engines.  Conceptminer
used Elephant 0.6.0 and the development branch of Elephant 0.9 to
perform months of analysis consisting of millions of pages and a
page/query database of over ten gigabytes.

   </p>

<p>There are several interesting uses and extensions of Elephant in
Conceptminer:

     </p>

<ul>
<li>Bulk storage of post-processed web data: Elephant was used to
store hundreds of thousands of processed web pages as strings, associate
pages with queries and store related metadata. 
</li><li>Derived index: a custom string hash function over URLs was used to populate
a class derived index, allowing fast identification of pages from
their URL without requiring expensive eql comparisons. 
</li><li>Inverted document index: a (not terribly efficient) data structure
that efficiently maps words to documents allowing pages to indexed by
the words contained in them.  Allowed for phrase and conjunction searches. 
</li><li>User association data structure: a data structure based on oids that supports
general one-to-many mappings between classes.  Had a custom migrate
method to support migration of associations.  Supplanted by persistent
sets as of 0.9. 
</li></ul>

<p>The most interesting use of Elephant was extending its transactional
architecture to cover in-memory lisp operations. <code>PCOMP</code> (Process
Components) is a framework for constructing and managing simple,
dataflow-style multi-threaded applications in Common Lisp.  The goal
is to simplify the process sufficiently so that the ordinary user can
hide from many of the details associated with aborting transactions. 
To this end, the model provides for safe, asynchronous communications
among a set of components which may be scheduled together in a single
process or communicate across separate threads (and potentially
processes).  Components are packaged into a system inside a Container
object which schedules execution and mediates communications.

   </p>

<p>Communications between components can be in a dataflow style or using messages.  Each
component has a single port for receiving incoming data items.  These items, if access
is shared among components, should have the proper synchronization protections on
mutating accesses.  There is also an asynchronous communications method allowing you
to send messages to components with particular names.

   </p>

<p>The basic building block is a component.  Components are defined using the defcomponent
form and contain several major elements, such as:

</p>

<pre class="lisp">     (defcomponent counter
       (:vars (count 0) end (increment 1))
       (:initialize (assert end))
       (:body
          (when (&gt;= (incf count increment) end)
             (terminate))))
</pre>

<p>The arguments to defcomponent behave as follows:

     </p>

<ul>
<li><code>:vars</code> - Values that the body wants to retain between invocations
</li><li><code>:initialize</code> - A reserved message handler called at the begining of time
</li><li><code>:body</code> - A body expression that is executed whenever data has arrived
</li></ul>

<p>The body and messages are evaluated in a very specific environment.  Within the body
certain variables and functions are bound:

     </p>

<ul>
<li>Variables:
          <ul>
  <li><code>data</code> - The current data item
  </li><li><code>self</code> - The component object
  </li><li><code>"vars"</code> - all variables named in <code>:vars</code> are bound using <code>symbol-macrolet</code> and available as in a <code>let</code>
 statement.  Any side effects to those vars are visible, but not saved 
to th component state until the component commits (see below). 
  </li></ul>
     </li><li>Functions:
          <ul>
  <li><code>(terminate)</code>
  </li><li><code>(send data)</code>
  </li><li><code>(receive data)</code>
  </li><li><code>(get-ctrl-msg target type data)</code>
  </li><li><code>(pause)</code>
  </li><li><code>(abort)</code>
  </li></ul>
     </li></ul>

<p>Each component execution is bound in a transactional framework.  No
variables are written, messages consumed or messages sent until the
body or control handler has exited normally.  Users can tap into this
transactional framework by overriding <code>start-transaction</code>,
<code>commit-transaction</code> and <code>abort-transaction</code> methods for the
component class.  Transactional variables are implemented via
<code>:after</code> methods on these generic functions.

   </p>

<p>When signals are asserted by the body or a message handler, they are also wrapped
in restart handlers called:

     </p>

<ul>
<li><strong>retry:</strong> Try to execute the component again

     </li><li><strong>retry n times:</strong> Using retry you can retry the body or
      message again.  Usually this works best at the REPL when you can
      test or repair the error and then keep the procesess running

     </li><li><strong>replace:</strong> Interactively or automatically enter an
      expression to replace the current data item with one of your
      choosing

     </li><li><strong>ignore:</strong> Drop the message or data input as if it never arrived

     </li><li><strong>terminate:</strong> Terminate execution of the current component
</li></ul>

<!-- *-texinfo-*- -->
<!-- *** FINISH *** -->
<div class="node">

<p></p>

<hr>
<a name="Elephant-Architecture"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Data-Store-API-Reference">Data Store API Reference</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Design-Patterns">Design Patterns</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name, next, previous, up -->
<h2 class="chapter">7 Elephant Architecture</h2>

<p><a name="index-design-192"></a>
Elephant's early architecture was tightly coupled to the Berkeley DB
API.  Over time we've moved towards a more modular architecture to
support easy upgrading, repository migration, shared functionality
between data stores and general hygene.

   </p>

<p>The architecture has been carefully modularized:

   </p>

<div class="block-image"><img src="ElephantUserManual_files/ArchDiagram.png" alt="[Architecture Diagram]"></div>

<p>To get a feeling for what is happening inside elephant, it is probably
best to walk through the various major protocols to see how these
components participate in implementing them.

     </p>

<ul>
<li>Initialization of a store controller
</li><li>Creating a persistent object
</li><li>Operations on persistent slots
</li><li>Operations on persistent collections
</li><li>Implementing <code>with-transaction</code>
</li></ul>

<h3 class="section">7.1 Initializing a store controller</h3>

<p>When the main elephant <code>open-store</code> function is called with a
specification, it calls get-controller which first checks to see if a
controller already exists for that spec.

   </p>

<p>If there is no controller, it calls <code>build-controller</code> to
construct one.  If the data store code base is not present,
<code>load-data-store</code> is called to ensure that any asdf dependencies
are satisfied.  The associations for asdf dependencies are statically
configured in <code>*elephant-data-stores*</code> for each data store type
supported by elephant.

   </p>

<p>While being loaded, the data store is responsible for calling
<code>register-data-store-con-init</code> to register a data store
initialization function for its spec type (i.e. :BDB or :CLSQL). 
For example, from bdb-controller.lisp:

</p>

<pre class="lisp">     (eval-when (:compile-toplevel :load-toplevel)
       (register-data-store-con-init :bdb 'bdb-test-and-construct))
</pre>

<p>This mapping between spec types and initialization functions is
accessed by <code>lookup-data-store-con-init</code> from within
<code>build-controller</code>.  The function returned by
<code>lookup-data-store-con-init</code> is passed the full specification and
returns a <code>store-controller</code> subclass instance for the specified
data store.

   </p>

<p>The new controller is stored in the <code>*dbconnection-spec*</code> hash
table, associating the object with its specification.  Finally
Elephant calls open-controller to actually establish a connection to
or create the files of the data store.

   </p>

<p>Finally, if the default store controller <code>*store-controller*</code> is
nil, it will be initialized with the new store controller, otherwise
the original value is left in <code>*store-controller*</code> until that
store controller is closed using <code>close-store</code>.

   </p>

<p>The data store implementor has access to various utilities to aid
initialization.

     </p>

<ul>
<li><code>get-user-configuration-parameter</code> - Access symbol tags
      in my-config.sexp to access data store specific user
configuration.  You can also add special variables to variables.lisp
and add a tag-variable pair to <code>*user-configurable-parameters*</code>
in variables.lisp to automatically initialize it when the store
controller is opened. 
</li><li><code>get-con</code> behavior when store is closed or lost
</li><li><code>database-version</code> a store controller implements this
      in order to tell Elephant what serializer to use.  Currently,
      version 0.6.0 databases use serializer1 and all later database
      use serializer version 2.  This is to ensure that a given version
      of the Elephant code can open databases from prior versions in
      order to properly upgrade to the new code base. 
</li><li>Symbol conversions.  To aid in opening legacy databases, a
      symbol conversion facility is provided in controller.lisp to
      be applied to any symbols extracted from the legacy data store. 
      (if, for instance, the type name of subclasses changed, such as
       sleepycat-btree becoming bdb-btree)
</li></ul>

<p>At this point, all operations referencing the store controller should
be able to proceed.

   </p>

<p>At the end of a session,

</p>

<h3 class="section">7.2 Persistent Object Creation</h3>

<p>The only thing that a data store has to do to support new object
creation, other than implement the slot protocol, is implement the
method <code>next-oid</code> to return the next unique object id for the
persistent object being created.

   </p>

<p>Existing objects are created during deserialization of object
references.  The serializer subsystem is built-into the core of
elephant and can be used by data stores.  The serializer is abstracted
so that multiple serializers can be co-resident and the data store can
choose the appropriate one.  The abstraction boundary between the
serializer, the data store, and the core Elephant system is not
perfect, so be aware and refer to existing data store implementations
if in doubt.

   </p>

<p>A serializer takes as arguments the store-controller, lisp object and
a <code>buffer-stream</code> from the memory utility library and returns the
buffer-stream with the binary serialized object.  The deserializer
reverses this process.  For all lisp objects except persistent
classes, this means reallocating the storage space for the object and
recreating all its contents.  Deserializing a standard object results
in a new standard object of the same class with the same slot values.

   </p>

<p>Persistent classes are dealt with specially.  When a persistent object
is serialized, it's oid and class are stored in the
<code>buffer-stream</code>.  On deserialization it uses the oid to check in
the store-controller's cache for an existing placeholder object.  If
the cache misses, then it creates a new placeholder object using the
class and oid as described in See <a href="#Persistent-Classes-and-Objects">Persistent Classes and Objects</a>. 
The store controller contains a cache instance that is automatically
initialized by the core Elephant object protocol.

   </p>

<p>Currently the serializer is selected by the core Elephant code based
on the store controller's database version.  See the reference section
for details on implementing the store-controller database version
method.  It is a relatively small change to have the data store choose
its own serializer, however we will have to tighten up and document
the contracts between the Elephant core code, serializer and data store.

</p>

<h3 class="section">7.3 Persistent Slot Protocol</h3>

<p>The core protocol that the data store needs to support is the slot
access protocol.  During object initialization, these functions are
called to initialize the slots of the object.  The four functions are:

     </p>

<ul>
<li><code>persistent-slot-reader</code>
</li><li><code>persistent-slot-writer</code>
</li><li><code>persistent-slot-boundp</code>
</li><li><code>persistent-slot-makunbound</code>
</li></ul>

<p>More details can be found in the data store api reference section.  In
short, these functions specialize on the specific <code>store-controller</code> of
the data store and take instances, values and slotnames as appropriate.

   </p>

<p>Typically the oid will be extracted from the instance and be used to
update a table or record where the oid and slotname identifies the
value.  A slot is typically unbound when no value exists (as opposed to
nil).

</p>

<h3 class="section">7.4 Persistent Collection Protocols</h3>

<p>The BTree protocol is the most extensive interface that data stores must
implement.  Data store implementations are required to subclass the
abstract classes <code>btree</code>, <code>indexed-btree</code>, and <code>index</code>
and implement their complete APIs.  Each class type is constructed
by Elephant using a <code>store-controller</code> that builds them.  These
methods are <code>build-btree</code>, <code>build-indexed-btree</code> and
<code>build-index</code>.

   </p>

<p>The <code>get-value</code> interface is similar to the persistent
slot reader and writer, but instead of using oid and slotname to set
values, it uses the btree oid and a key value as a unique identifier
for a value.

   </p>

<p>The BTree protocol almost requires an actual BTree implementation to
be at all efficient.  Keys and values need to be accessible via the
cursor API, which means they need to be walked linearly in the sort
order of the keys (described in <a href="#Persistent-BTrees">Persistent BTrees</a>).

   </p>

<p>An indexed BTree automatically maintains a hash table of the indices
defined on it so that users can access them by mapping or
lookup-by-name.  The data store also has access to this interface.

   </p>

<p>A BTree index must also maintain a connection to its parent BTree so
that an index value can be used as a primary tree key to retrieve the
primary BTree value as part of the <code>cursor-pnext</code> and
<code>cursor-pprev</code> family of methods.

   </p>

<p>The contract of <code>remove-kv</code> is that the storage in the data store
is actually freed for reuse.

   </p>

<p>Persistent set implemenation is optional.  A default BTree based
implementation is provided by default

</p>

<h3 class="section">7.5 Implementing Transactions</h3>

<p>One of the most important pieces of functionality remaining to discuss
is implementing transactions.  In existing data stores, transactions
are merely extensions of the underlying start, commit and abort
methods of the 3rd party library or server being used.  The Elephant
user interfaces to these functions in two ways: a call to
<code>execute-transaction</code> or explicit calls to <code>controller-start-transaction</code>,
<code>controller-commit-transaction</code> and <code>controller-abort-transaction</code>.

</p>

<h4 class="subsection">7.5.1 Implementing Execute Transaction</h4>

<p>The macros <code>with-transaction</code> and <code>ensure-transaction</code> wrap
access to the data store's <code>execute-transaction</code>.  This function
has a rich contract.  It accepts as arguments the store controller, a
closure that executes the transaction body and a set of keywords. 
Keywords required to be supported by the method (or ignored without
loss of semantics) are <code>:parent</code> and <code>:retries</code>.

   </p>

<p>The semantics of <code>with-transaction</code> are that a new transaction
will always be requested of the data store.  If a transaction exists,
<code>ensure-transaction</code> will merely call the transaction closure. 
If not it will function as a call to <code>with-transaction</code>.

   </p>

<p><code>execute-transaction</code> is that it must ensure that the transaction
closure is executed within a dynamic context that insures the ACID
properties of any database operations (<code>pset</code>,<code>btree</code> or
persistent slot operations).  If there is a non-local exit during this
execution, the transaction should be aborted.  If it returns normally,
the transaction is committed.  The integer in the <code>:retries</code>
argument dictates how many times <code>execute-transaction</code> should
retry the transaction before failing.

   </p>

<p>Elephant provides some bookkeeping to the data store to help with
nested transactions by using the <code>*current-transaction*</code> dynamic
variable.  In the dynamic context of the transaction closure, another
call to <code>execute-transaction</code> may occur with the transaction
argument defaulting to the value of <code>*current-transaction*</code>.  The
data store has to decide how to handle these cases.  To support this,
the first call to execute transaction can create a dynamic binding for
<code>*current-transaction*</code> using the <code>make-transaction-record</code>
call.  This creates a transaction object that records the store
controller that started the transaction and any data store-specific
transaction data.

   </p>

<p>The current policy is that the body of a transaction is executed with
the <code>*store-controller*</code> variable bound to the store-controller
object creating the transaction.  This is important for default
arguments and generally helps more than it hurts, so is an
implementation requirement placed on <code>execute-transaction</code>.

   </p>

<p>If two nested calls to <code>with-transaction</code> are made successively
in a dynamic context, the data store can create true nested
transactions.  The first transaction is passed to the <code>:parent</code>
argument of the second.  The second can choose to just continue the
current transaction (the CLSQL data store policy) or to nest the
transaction (the BDB data store policy).

</p>

<h4 class="subsection">7.5.2 Interleaving Multiple Store Transactions</h4>

<p>Finally, some provision is made for the case where two store
controllers have concurrently active transactions in the same thread. 
This feature was created to allow for migration, where a read from one
database happens in one transaction, and while active has to writes to
another data store with a valid transaction.

   </p>

<p>The trick is that <code>with-transaction</code> checks to see if the current
transaction object is the same as the <code>store-controller</code> object
passed to the <code>:store-controller</code> argument.  If not, a fresh
transaction is started.

   </p>

<p>Currently no provision is made for more than two levels of multi-store
nesting as we do not implement a full transaction stack (to avoid
walking the stack on each call to handle this rare case).  If a third
transaction is started by the store controller that started the first
transaction, it will have no access to the parent transaction which
may be a significant source of problems for the underlying database.

<!-- *-texinfo-*- -->
</p>

<div class="node">

<p></p>

<hr>
<a name="Data-Store-API-Reference"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Copyright-and-License">Copyright and License</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Elephant-Architecture">Elephant Architecture</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name, next, previous, up -->
<h2 class="chapter">8 Data Store API Reference</h2>

<p><a name="index-Data-Store-193"></a><a name="index-API-194"></a>
This reference includes functions that need to be overridden, classes
inherited from or other action taken to implement support for a new
data store.  Included are the exported elephant functions that
need methods defined on them as well as the data-store-only functions
exported in data-store-api.lisp.  Some functions here are utilities from the
main elephant package that support store implementations, but are not
required.  Migration, class indices and query interfaces are
implemented on top of the store API and require no special support by
implementors.

   </p>

<p>Because the number of data store implementors is small, this is a
minimal documentation set intended to serve as an initial guide and a
reference.  However, it is anticipated that some interaction will be
needed with the developers to properly harden a datastore for release.

   </p>

<p>The sections each contain a short guide and a list of functions
relevant to them.

</p>

<ul class="menu">
<li><a accesskey="1" href="#DSR-Registration">Registration</a>:  Register the data store for the appropriate controller specifications. 
</li><li><a accesskey="2" href="#DSR-Store-Controllers">Store Controllers</a>:  Subclassing the store controller. 
</li><li><a accesskey="3" href="#DSR-Handling-Serialization">Handling Serialization</a>:  Available facilities for serializing objects. 
</li><li><a accesskey="4" href="#DSR-Persistent-Objects-and-Slot-Access">Persistent Objects and Slot access</a>:  Support for metaprotocol slot access. 
</li><li><a accesskey="5" href="#DSR-Collections">Collections</a>:  BTrees and indices. 
</li><li><a accesskey="6" href="#DSR-Cursors">Cursors</a>:   Traversing BTrees. 
</li><li><a accesskey="7" href="#DSR-Transactions">Transactions</a>:  Transaction implementation. 
</li><li><a accesskey="8" href="#DSR-Multithreading-Considerations">Multithreading Considerations</a>:   Multithreading considerations. 
<!-- * Memory Utilities: DSR Memory Utilities. Writing primitive C types. -->
<!-- * Foreign Libraries: DSR Foreign Libraries. Using UFFI and ASDF to build or link foreign libraries -->
</li></ul>

<div class="node">

<p></p>

<hr>
<a name="DSR-Registration"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#DSR-Store-Controllers">DSR Store Controllers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data-Store-API-Reference">Data Store API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">8.1 Registration</h3>

<p><a name="index-Registration-and-Initialization-195"></a>
Elephant looks at the first element of the specification list to
determine which data store module to use.  The master table for this
information is <code>*elephant-data-stores*</code> in elephant/controller.lisp. 
This will need to be augmented for every data store with the
specification keyword tag to be used (such as <code>:BDB</code> or
<code>:CLSQL</code>) and the required asdf dependencies.

   </p>

<p>In addition, the data store source should use an eval-when statement to
call the following function:

   </p>

<p><a name="Function-elephant_002ddata_002dstore_003aregister_002ddata_002dstore_002dcon_002dinit"></a>

</p>

<div class="defun">
 Function: <b>elephant-data-store:register-data-store-con-init</b><var> name controller-init-fn<a name="index-elephant_002ddata_002dstore_003aregister_002ddata_002dstore_002dcon_002dinit-196"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003aregister_002ddata_002dstore_002dcon_002dinit-197"></a>Data stores must call this function during the
   loading/compilation process to register their initialization
   function for the tag name in *elephant-data-stores*.  The
   initialization function returns a fresh instance of the
   data stores store-controller subclass
</p>

</blockquote></div>

<p>If the data store requires any special user-specified configuration,
augment the key types in config.sexp with what you need and use the
following function to access.

   </p>

<p><a name="Function-elephant_002ddata_002dstore_003aget_002duser_002dconfiguration_002dparameter"></a>

</p>

<div class="defun">
 Function: <b>elephant-data-store:get-user-configuration-parameter</b><var> name<a name="index-elephant_002ddata_002dstore_003aget_002duser_002dconfiguration_002dparameter-198"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003aget_002duser_002dconfiguration_002dparameter-199"></a>This function pulls a value from the key-value pairs stored in
   my-config.sexp so data stores can have their own pairs for appropriate
   customization after loading. 
</p>

</blockquote></div>

<div class="node">

<p></p>

<hr>
<a name="DSR-Store-Controllers"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#DSR-Handling-Serialization">DSR Handling Serialization</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DSR-Registration">DSR Registration</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data-Store-API-Reference">Data Store API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">8.2 Store Controllers</h3>

<p><a name="index-Store-Controllers-200"></a>
Subclass store-controller and implement store and close controller
which are called by open-store and close-store respectively.

   </p>

<p><a name="Class-elephant_003astore_002dcontroller"></a>

</p>

<div class="defun">
 Class: <b>elephant:store-controller</b><var><a name="index-elephant_003astore_002dcontroller-201"></a></var><br>
<blockquote>
<p><a name="index-elephant_003astore_002dcontroller-202"></a>Class precedence list: <code>store-controller<!-- /@w -->, standard-object<!-- /@w -->, t<!-- /@w --></code>

        </p>

<p>Slots:
          </p>

<ul>
<li><code>spec</code>  initargs: <code>:spec<!-- /@w --></code>

<p>Data store initialization functions are
	 expected to initialize :spec on the call to
	 make-instance
</p>

</li><li><code>root</code>

<p>This is an instance of the data store
	 persistent btree.  It should have an <code>oid</code> that is fixed in
	 the code and does not change between sessions.  Usually
	 it this is something like 0, 1 or -1
</p>

</li><li><code>schema-table</code>

<p>Schema id to schema database table
</p>

</li><li><code>schema-name-index</code>

<p>Schema name to schema database table
</p>

</li><li><code>schema-cache</code>

<p>This is a cache of class schemas stored in the database indexed by classid
</p>

</li><li><code>schema-classes</code>

<p>Maintains a list of all classes that have a cached schema value so we can shutdown cleanly
</p>

</li><li><code>schema-cache-lock</code>

<p>Protection for updates to the cache from multiple threads. 
                                        Do not override. 
</p>

</li><li><code>instance-table</code>

<p>Contains btree of oid to class ids
</p>

</li><li><code>instance-class-index</code>

<p>A reverse map of class id to oid
</p>

</li><li><code>instance-cache</code>

<p>This is an instance cache and part of the
                    metaclass protocol.  Data stores should not
                    override the default behavior. 
</p>

</li><li><code>instance-cache-lock</code>

<p>Protection for updates to
			the cache from multiple threads.  Do not
			override. 
</p>

</li><li><code>index-table</code>

<p>This is another root for class indexing that is
	       also a data store specific persistent btree instance
	       with a unique <code>oid</code> that persists between sessions. 
               No cache is needed because we cache in the class slots. 
</p>

</li><li><code>serializer-version</code>

<p>Governs the default
		       behavior regarding which serializer
		       version the current elephant core is
		       using.  Data stores can override by creating
		       a method on initialize-serializer. 
</p>

</li><li><code>serialize</code>

<p>Accessed by elephant::serialize to
	      get the entry point to the default serializer or to
	      a data store specific serializer
</p>

</li><li><code>serialize-fn</code>

<p>Accessed by elephant::serialize to
	      get the entry point to the default serializer or to
	      a data store specific serializer
</p>

</li><li><code>deserialize</code>

<p>Contains the entry point for the
		specific serializer to be called by
		elephant::deserialize
</p>

</li><li><code>deserialize-fn</code>

<p>Contains the entry point for the
		specific serializer to be called by
		elephant::deserialize
</p>

</li></ul>

<p>Superclass for the data store controller, the main interface
    to any book-keeping, references to <code>db</code> handles, the instance
    cache, btree table creation, counters, locks, the roots (for
    garbage collection,) et cetera.  Behavior is shared between
    the superclass and subclasses.  See slot documentation for
    details. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_002ddata_002dstore_003aopen_002dcontroller"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant-data-store:open-controller</b><var> sc &amp;key recover recover-fatal thread &amp;allow-other-keys<a name="index-elephant_002ddata_002dstore_003aopen_002dcontroller-203"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003aopen_002dcontroller-204"></a>Opens the underlying environment and all the necessary
database tables.  Different data stores may use different keys so
all methods should &amp;allow-other-keys.  There are three standard
keywords: :recover, :recover-fatal and :thread.  Recover means
that recovery should be checked for or performed on startup. 
Recover fatal means a full rebuild from log files is requested. 
Thread merely indicates to the data store that it is a threaded
application and any steps that need to be taken (for example
transaction implementation) are taken.  :thread is usually
true. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_002ddata_002dstore_003aclose_002dcontroller"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant-data-store:close-controller</b><var> sc<a name="index-elephant_002ddata_002dstore_003aclose_002dcontroller-205"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003aclose_002dcontroller-206"></a>Close the db handles and environment.  Should be in a state
   where lisp could be shut down without causing an inconsistent
   state in the db.  Also, the object could be used by
   open-controller to reopen the database
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_002ddata_002dstore_003aconnection_002dis_002dindeed_002dopen"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant-data-store:connection-is-indeed-open</b><var> controller<a name="index-elephant_002ddata_002dstore_003aconnection_002dis_002dindeed_002dopen-207"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003aconnection_002dis_002dindeed_002dopen-208"></a>Validate the controller and the db that it is connected to
</p>

</blockquote></div>

<p>For upgrading and opening legacy databases it is important that a
store be able to indicate which version of elephant was used to create
it.  This governs the chosen serializer, mappings between elephant
symbols used in an old vs. new version, etc.  Because this is called
to initialize the serializer, it must directly implemented by the
data store without using the serializer.

   </p>

<p><a name="Generic_002dFunction-elephant_002ddata_002dstore_003adatabase_002dversion"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant-data-store:database-version</b><var> sc<a name="index-elephant_002ddata_002dstore_003adatabase_002dversion-209"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003adatabase_002dversion-210"></a>Data stores implement this to store the serializer version. 
                   The protocol requires that data stores report their database
                   version.  On new database creation, the database is written with the
                   *elephant-code-version* so that is returned by database-version. 
                   If a legacy database does not have a version according to the method
                   then it should return nil
</p>

</blockquote></div>
   <a name="Method-elephant_002ddata_002dstore_003adatabase_002dversion-around-_0028sc_0029"></a>

<div class="defun">
 Method: <b>around</b><var> elephant-data-store:database-version sc<a name="index-around-211"></a></var><br>
<blockquote>
<p>Default version assumption for unmarked databases is 0.6.0. 
   It is possible to check for 0.5.0 databases, but it is not implemented
   now due to the low (none?) number of users still on 0.5.0
</p>

</blockquote></div>

<p>There are some utilities for serializing simple data without a
serializer using the memutil package.

   </p>

<p><a name="Function-elephant_002ddata_002dstore_003aserialize_002ddatabase_002dversion_002dkey"></a>

</p>

<div class="defun">
 Function: <b>elephant-data-store:serialize-database-version-key</b><var> bs<a name="index-elephant_002ddata_002dstore_003aserialize_002ddatabase_002dversion_002dkey-212"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003aserialize_002ddatabase_002dversion_002dkey-213"></a>Given a buffer-stream, encode a key indicating the version using
   the constant +elephant-version+
</p>

</blockquote></div>

<p><a name="Function-elephant_002ddata_002dstore_003aserialize_002ddatabase_002dversion_002dvalue"></a>

</p>

<div class="defun">
 Function: <b>elephant-data-store:serialize-database-version-value</b><var> version bs<a name="index-elephant_002ddata_002dstore_003aserialize_002ddatabase_002dversion_002dvalue-214"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003aserialize_002ddatabase_002dversion_002dvalue-215"></a>Serializes a list containing three integers to the buffer stream bs
</p>

</blockquote></div>

<p><a name="Function-elephant_002ddata_002dstore_003adeserialize_002ddatabase_002dversion_002dvalue"></a>

</p>

<div class="defun">
 Function: <b>elephant-data-store:deserialize-database-version-value</b><var> bs<a name="index-elephant_002ddata_002dstore_003adeserialize_002ddatabase_002dversion_002dvalue-216"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003adeserialize_002ddatabase_002dversion_002dvalue-217"></a>Deserializes the 3 integer list from buffer stream bs
</p>

</blockquote></div>

<div class="node">

<p></p>

<hr>
<a name="DSR-Persistent-Objects-and-Slot-Access"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#DSR-Collections">DSR Collections</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DSR-Handling-Serialization">DSR Handling Serialization</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data-Store-API-Reference">Data Store API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">8.3 Slot Access</h3>

<p><a name="index-Persistent-Objects-and-Slot-Access-218"></a>
Persistence is implement with a metaclass and several required base
classes.

   </p>

<p><a name="Class-elephant_003apersistent_002dmetaclass"></a>

</p>

<div class="defun">
 Class: <b>elephant:persistent-metaclass</b><var><a name="index-elephant_003apersistent_002dmetaclass-219"></a></var><br>
<blockquote>
<p><a name="index-elephant_003apersistent_002dmetaclass-220"></a>Class precedence list: <code>persistent-metaclass<!-- /@w -->, standard-class<!-- /@w -->, class<!-- /@w -->, specializer<!-- /@w -->, metaobject<!-- /@w -->, standard-object<!-- /@w -->, t<!-- /@w --></code>

        </p>

<p>Slots:
          </p>

<ul>
<li><code>%class-schema</code>  initargs: <code>:schemas<!-- /@w --></code>

<p>The code master schema
</p>

</li></ul>

<p>Metaclass for persistent classes.  Use this metaclass to
    define persistent classes.  All slots are persistent by
    default; use the :transient flag otherwise.  Slots can also
    be indexed for by-value retrieval. 
</p>

</blockquote></div>

<p><a name="Class-elephant_003apersistent"></a>

</p>

<div class="defun">
 Class: <b>elephant:persistent</b><var><a name="index-elephant_003apersistent-221"></a></var><br>
<blockquote>
<p><a name="index-elephant_003apersistent-222"></a>Class precedence list: <code>persistent<!-- /@w -->, standard-object<!-- /@w -->, t<!-- /@w --></code>

        </p>

<p>Slots:
          </p>

<ul>
<li><code>oid</code>  initargs: <code>:from-oid<!-- /@w --></code>

<p>All persistent objects have an oid
</p>

</li><li><code>spec</code>  initargs: <code>:db-spec<!-- /@w --></code>

<p>Persistent objects use a spec pointer to identify which store
                         they are connected to
</p>

</li></ul>

<p>Abstract superclass for all persistent classes (common
    to both user-defined classes and Elephant-defined objects such as collections.) 
</p>

</blockquote></div>

<p><a name="Class-elephant_003apersistent_002dobject"></a>

</p>

<div class="defun">
 Class: <b>elephant:persistent-object</b><var><a name="index-elephant_003apersistent_002dobject-223"></a></var><br>
<blockquote>
<p><a name="index-elephant_003apersistent_002dobject-224"></a>Class precedence list: <code>persistent-object<!-- /@w -->, persistent<!-- /@w -->, standard-object<!-- /@w -->, t<!-- /@w --></code>

        </p>

<p>Superclass for all user-defined persistent classes.  This is
    automatically inherited if you use the persistent-metaclass
    metaclass.  This allows specialization of functions for user
    objects that would not be appropriate for Elephant objects
    such as persistent collections
</p>

</blockquote></div>

<p>Persistent objects can be queries for their home store controller so
that functions such as map-btree do not need a store-controller
argument.  (NOTE: Should this function be user visible?)

   </p>

<p><a name="Generic_002dFunction-elephant_002ddata_002dstore_003aget_002dcon"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant-data-store:get-con</b><var> instance<a name="index-elephant_002ddata_002dstore_003aget_002dcon-225"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003aget_002dcon-226"></a>This is used to find and validate the connection spec
   maintained for in-memory persistent objects.  Should
   we re-open the controller from the spec if it's not
   cached?  That might be dangerous so for now we error
</p>

</blockquote></div>

<p>All objects require a unique object identifier.  During new object
creation the data store is asked to produce a unique id.

   </p>

<p><a name="Generic_002dFunction-elephant_002ddata_002dstore_003anext_002doid"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant-data-store:next-oid</b><var> sc<a name="index-elephant_002ddata_002dstore_003anext_002doid-227"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003anext_002doid-228"></a>Provides a persistent source of unique id's
</p>

</blockquote></div>

<p>These functions are called by the metaclass protocol to implement the
appropriate operations on persistent class slots.  Unless protected by
a transaction, the side effects of these functions should be atomic,
persistent and visible to other threads on completion.

   </p>

<p><a name="Generic_002dFunction-elephant_002ddata_002dstore_003apersistent_002dslot_002dwriter"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant-data-store:persistent-slot-writer</b><var> sc new-value instance name<a name="index-elephant_002ddata_002dstore_003apersistent_002dslot_002dwriter-229"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003apersistent_002dslot_002dwriter-230"></a>Data store specific slot writer function
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_002ddata_002dstore_003apersistent_002dslot_002dreader"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant-data-store:persistent-slot-reader</b><var> sc instance name &amp;optional oids-only<a name="index-elephant_002ddata_002dstore_003apersistent_002dslot_002dreader-231"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003apersistent_002dslot_002dreader-232"></a>Data store specific slot reader function
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_002ddata_002dstore_003apersistent_002dslot_002dboundp"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant-data-store:persistent-slot-boundp</b><var> sc instance name<a name="index-elephant_002ddata_002dstore_003apersistent_002dslot_002dboundp-233"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003apersistent_002dslot_002dboundp-234"></a>Data store specific slot bound test function
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_002ddata_002dstore_003apersistent_002dslot_002dmakunbound"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant-data-store:persistent-slot-makunbound</b><var> sc instance name<a name="index-elephant_002ddata_002dstore_003apersistent_002dslot_002dmakunbound-235"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003apersistent_002dslot_002dmakunbound-236"></a>Data store specific slot makunbound handler
</p>

</blockquote></div>

<div class="node">

<p></p>

<hr>
<a name="DSR-Collections"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#DSR-Cursors">DSR Cursors</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DSR-Persistent-Objects-and-Slot-Access">DSR Persistent Objects and Slot Access</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data-Store-API-Reference">Data Store API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">8.4 Collections</h3>

<p><a name="index-Collections-237"></a>
To support collections, the data store must subclass the following
classes.

   </p>

<p><a name="Class-elephant_003apersistent_002dcollection"></a>

</p>

<div class="defun">
 Class: <b>elephant:persistent-collection</b><var><a name="index-elephant_003apersistent_002dcollection-238"></a></var><br>
<blockquote>
<p><a name="index-elephant_003apersistent_002dcollection-239"></a>Class precedence list: <code>persistent-collection<!-- /@w -->, persistent<!-- /@w -->, standard-object<!-- /@w -->, t<!-- /@w --></code>

        </p>

<p>Abstract superclass of all collection types. 
</p>

</blockquote></div>

<p><a name="Class-elephant_003abtree"></a>

</p>

<div class="defun">
 Class: <b>elephant:btree</b><var><a name="index-elephant_003abtree-240"></a></var><br>
<blockquote>
<p><a name="index-elephant_003abtree-241"></a>Class precedence list: <code>btree<!-- /@w -->, persistent-collection<!-- /@w -->, persistent<!-- /@w -->, standard-object<!-- /@w -->, t<!-- /@w --></code>

        </p>

<p>A hash-table like interface to a BTree, which stores things
    in a semi-ordered fashion. 
</p>

</blockquote></div>

<p><a name="Class-elephant_003abtree_002dindex"></a>

</p>

<div class="defun">
 Class: <b>elephant:btree-index</b><var><a name="index-elephant_003abtree_002dindex-242"></a></var><br>
<blockquote>
<p><a name="index-elephant_003abtree_002dindex-243"></a>Class precedence list: <code>btree-index<!-- /@w -->, btree<!-- /@w -->, persistent-collection<!-- /@w -->, persistent-object<!-- /@w -->, persistent<!-- /@w -->, standard-object<!-- /@w -->, t<!-- /@w --></code>

        </p>

<p>Secondary index to an indexed-btree. 
</p>

</blockquote></div>

<p><a name="Class-elephant_003aindexed_002dbtree"></a>

</p>

<div class="defun">
 Class: <b>elephant:indexed-btree</b><var><a name="index-elephant_003aindexed_002dbtree-244"></a></var><br>
<blockquote>
<p><a name="index-elephant_003aindexed_002dbtree-245"></a>Class precedence list: <code>indexed-btree<!-- /@w -->, btree<!-- /@w -->, persistent-collection<!-- /@w -->, persistent<!-- /@w -->, standard-object<!-- /@w -->, t<!-- /@w --></code>

        </p>

<p>A BTree which supports secondary indices. 
</p>

</blockquote></div>

<p>To create the data store-appropriate type of btree, the data store
implements this method (and possibly related methods) aginst their store-controller.

   </p>

<p><a name="Generic_002dFunction-elephant_002ddata_002dstore_003abuild_002dbtree"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant-data-store:build-btree</b><var> sc<a name="index-elephant_002ddata_002dstore_003abuild_002dbtree-246"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003abuild_002dbtree-247"></a>Construct a btree of the appropriate type corresponding to this store-controller. 
</p>

</blockquote></div>

<p>Most of the user-visible operations over BTrees must be implemented. 
Class indexing functions such as <code>map-class</code> and
<code>get-instances-by-value</code> and related functions are all
implemented using map-btree and map-index.

     </p>

<ul>
<li><a href="#Generic_002dFunction-elephant_003aget_002dvalue">Generic-Function elephant:get-value</a> (and <code>(setf get-value)</code>)
<!-- @item @ref{Generic-Function (setf elephant:get-value)} -->
</li><li><a href="#Generic_002dFunction-elephant_003aexistsp">Generic-Function elephant:existsp</a>
</li><li><a href="#Generic_002dFunction-elephant_003aremove_002dkv">Generic-Function elephant:remove-kv</a>
</li><li><a href="#Generic_002dFunction-elephant_003aget_002dindex">Generic-Function elephant:get-index</a>
</li><li><a href="#Generic_002dFunction-elephant_003aremove_002dindex">Generic-Function elephant:remove-index</a>
</li><li><a href="#Generic_002dFunction-elephant_003amap_002dbtree">Generic-Function elephant:map-btree</a>
</li><li><a href="#Generic_002dFunction-elephant_003amap_002dindex">Generic-Function elephant:map-index</a>
</li></ul>

<p>Mapping over the indices of a btree is important to derived facilities
such as class indexing and the query subsystem.

   </p>

<p><a name="Generic_002dFunction-elephant_003amap_002dindices"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant:map-indices</b><var> fn bt<a name="index-elephant_003amap_002dindices-248"></a></var><br>
<blockquote>
<p><a name="index-elephant_003amap_002dindices-249"></a>Calls a two input function with the name and
   btree-index object of all secondary indices in the btree
</p>

</blockquote></div>

<div class="node">

<p></p>

<hr>
<a name="DSR-Cursors"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#DSR-Transactions">DSR Transactions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DSR-Collections">DSR Collections</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data-Store-API-Reference">Data Store API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">8.5 Cursors</h3>

<p><a name="index-Cursors-250"></a>
Data stores must subclass these cursor classes and implement all the
methods described in <a href="#DSR-Cursors">DSR Cursors</a> except <a href="#Macro-elephant_003awith_002dbtree_002dcursor">Macro elephant:with-btree-cursor</a>.

   </p>

<p><a name="Class-elephant_003acursor"></a>

</p>

<div class="defun">
 Class: <b>elephant:cursor</b><var><a name="index-elephant_003acursor-251"></a></var><br>
<blockquote>
<p><a name="index-elephant_003acursor-252"></a>Class precedence list: <code>cursor<!-- /@w -->, standard-object<!-- /@w -->, t<!-- /@w --></code>

        </p>

<p>Slots:
          </p>

<ul>
<li><code>initialized-p</code>  initargs: <code>:initialized-p<!-- /@w --></code>

<p>Predicate indicating whether
the btree in question is initialized or not.  Initialized means
that the cursor has a legitimate position, not that any
initialization action has been taken.  The implementors of this
abstract class should make sure that happens under the
sheets...  Cursors are initialized when you invoke an operation
that sets them to something (such as cursor-first), and are
uninitialized if you move them in such a way that they no longer
have a legimtimate value. 
</p>

</li></ul>

<p>A cursor for traversing (primary) BTrees. 
</p>

</blockquote></div>

<p><a name="Class-elephant_003asecondary_002dcursor"></a>

</p>

<div class="defun">
 Class: <b>elephant:secondary-cursor</b><var><a name="index-elephant_003asecondary_002dcursor-253"></a></var><br>
<blockquote>
<p><a name="index-elephant_003asecondary_002dcursor-254"></a>Class precedence list: <code>secondary-cursor<!-- /@w -->, cursor<!-- /@w -->, standard-object<!-- /@w -->, t<!-- /@w --></code>

        </p>

<p>Cursor for traversing secondary indices. 
</p>

</blockquote></div>

<div class="node">

<p></p>

<hr>
<a name="DSR-Transactions"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#DSR-Multithreading-Considerations">DSR Multithreading Considerations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DSR-Cursors">DSR Cursors</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data-Store-API-Reference">Data Store API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">8.6 Transactions</h3>

<p><a name="index-Transactions-255"></a>
These functions must be implemented or stubbed by all data stores.

   </p>

<p><a name="Generic_002dFunction-elephant_002ddata_002dstore_003aexecute_002dtransaction"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant-data-store:execute-transaction</b><var> store-controller txn-fn &amp;rest rest &amp;key &amp;allow-other-keys<a name="index-elephant_002ddata_002dstore_003aexecute_002dtransaction-256"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003aexecute_002dtransaction-257"></a>This is an interface to the backend's transaction function.  The
    body should be executed in a dynamic environment that protects against
    non-local exist, provides <code>acid</code> properties for <code>db</code> operations within the
    body and properly binds any relevant parameters. 
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_002ddata_002dstore_003acontroller_002dstart_002dtransaction"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant-data-store:controller-start-transaction</b><var> store-controller &amp;key &amp;allow-other-keys<a name="index-elephant_002ddata_002dstore_003acontroller_002dstart_002dtransaction-258"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003acontroller_002dstart_002dtransaction-259"></a>Start an elephant transaction
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_002ddata_002dstore_003acontroller_002dcommit_002dtransaction"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant-data-store:controller-commit-transaction</b><var> store-controller transaction &amp;key &amp;allow-other-keys<a name="index-elephant_002ddata_002dstore_003acontroller_002dcommit_002dtransaction-260"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003acontroller_002dcommit_002dtransaction-261"></a>Commit an elephant transaction
</p>

</blockquote></div>

<p><a name="Generic_002dFunction-elephant_002ddata_002dstore_003acontroller_002dabort_002dtransaction"></a>

</p>

<div class="defun">
 Generic Function: <b>elephant-data-store:controller-abort-transaction</b><var> store-controller transaction &amp;key &amp;allow-other-keys<a name="index-elephant_002ddata_002dstore_003acontroller_002dabort_002dtransaction-262"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003acontroller_002dabort_002dtransaction-263"></a>Abort an elephant transaction
</p>

</blockquote></div>

<p>These are supporting functions and variables for implementing
transactions.

   </p>

<p><a name="Variable-elephant_002ddata_002dstore_003a_002acurrent_002dtransaction_002a"></a>

</p>

<div class="defun">
 Variable: <b>elephant-data-store:*current-transaction*</b><var><a name="index-elephant_002ddata_002dstore_003a_002acurrent_002dtransaction_002a-264"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003a_002acurrent_002dtransaction_002a-265"></a>The transaction which is currently in effect. 
</p>

</blockquote></div>

<p><a name="Function-elephant_002ddata_002dstore_003amake_002dtransaction_002drecord"></a>

</p>

<div class="defun">
 Function: <b>elephant-data-store:make-transaction-record</b><var> sc txn &amp;optional prior<a name="index-elephant_002ddata_002dstore_003amake_002dtransaction_002drecord-266"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003amake_002dtransaction_002drecord-267"></a>Backends must use this to assign values to *current-transaction* binding
</p>

</blockquote></div>

<p><a name="Function-elephant_002ddata_002dstore_003atransaction_002dstore"></a>

</p>

<div class="defun">
 Function: <b>elephant-data-store:transaction-store</b><var> txnrec<a name="index-elephant_002ddata_002dstore_003atransaction_002dstore-268"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003atransaction_002dstore-269"></a>Get the store that owns the transaction from a transaction record
</p>

</blockquote></div>

<p><a name="Function-elephant_002ddata_002dstore_003atransaction_002dobject"></a>

</p>

<div class="defun">
 Function: <b>elephant-data-store:transaction-object</b><var> txnrec<a name="index-elephant_002ddata_002dstore_003atransaction_002dobject-270"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003atransaction_002dobject-271"></a>Get the backend-specific transaction object
</p>

</blockquote></div>

<p>;; Designer considerations:
;; - with-transaction passes *current-transaction* or the user parameter to execute-transaction
;;   in the parent keyword argument.  Backends allowing nested transactions can treat the transaction
;;   as a parent, otherwise they can reuse the current transaction by ignoring it (inheriting the dynamic
;;   value of *current-transaction*) or rebinding the dynamic context (whatever makes coding easier). 
;; - ensure-transaction uses *current-transaction* to determine if there is a current transaction
;;   in progress (not null).  If so, it jumps to the body directly.  Otherwise it executes the body in a
;;   new transaction by calling ... 
;; - execute-transaction contract:
;;   - Backends must dynamically bind *current-transaction* to a meaningful identifier for the
;;     transaction in progress and execute the provided closure in that context
;;   - All non-local exists result in an abort; only regular return values result in a commit
;;   - If a transaction is aborted due to a deadlock or read conflict, execute-transaction should
;;     automatically retry with an appropriate default amount
;;   - execute-transaction can take any number of backend-defined keywords, although designers should
;;     make sure there are no semantic conflicts if there is a name overlap with existing backends
;; - A typical design approach is to make sure that the most primitive interfaces to the backend
;;   database look at *current-transaction* to determine whether a transaction is active.  Users code can also
;;   access this parameter to check whether a transaction is active.

</p>

<div class="node">

<p></p>

<hr>
<a name="DSR-Multithreading-Considerations"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DSR-Transactions">DSR Transactions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data-Store-API-Reference">Data Store API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">8.7 Multithreading Considerations</h3>

<p><a name="index-Multithreading-272"></a>
This expands slightly on the multithreading discussion in
<a href="#Multi_002dthreaded-Applications">Multi-threaded Applications</a>.

   </p>

<p>Elephant provides a set of generic locking functions in
<code>src/utils/locks.lisp</code> to help protect any shared structures. 
There are standard locking functions (<code>ele-with-lock</code>) and then
a special locking interface called <code>ele-with-fast-lock</code> which
on some lisps provides a faster locking option than the standard OS
locks of the basic interface.  (i.e. under Allegro this uses
<code>without-interrupts</code> because Allegro still runs in a single
OS process on all platforms, this is not true of SBCL).

   </p>

<p>See the sections on Transaction handling, particularly the dynamic
behavior of <code>*current-transaction*</code>.  Also read up on the
store controller section in the User Guide to better understand the
role of <code>*store-controller*</code>.  At this time there are no other
global variables to worry about.

</p>

<div class="node">

<p></p>

<hr>
<a name="DSR-Handling-Serialization"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#DSR-Persistent-Objects-and-Slot-Access">DSR Persistent Objects and Slot Access</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DSR-Store-Controllers">DSR Store Controllers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data-Store-API-Reference">Data Store API Reference</a>

</div>

<!-- node-name, next, previous, up -->
<h3 class="section">8.8 Handling Serialization</h3>

<p><a name="index-Serializer-273"></a>
Data stores must initialize <a href="#Class-elephant_003astore_002dcontroller">Class elephant:store-controller</a> with
internal serializer functions.  Packages <code>elephant-serializer1</code>
and <code>elephant-serializer2</code> contains serialize and deserialize
methods on buffer-streams as defined in <code>elephant-memutil</code>.  The
elephant functions <code>serialize</code> and <code>deserialize</code> dispatch on
the appropriate slot values of the store-controller.

</p>

<pre class="verbatim">NOTE: This should perhaps become entirely the job of the data store to
decide how to serialize values and for a specific version, what
serializer to use.  The elphant main package can define serializers
for use by different data stores.
</pre>

<p><a name="Function-elephant_002ddata_002dstore_003aserialize"></a>

</p>

<div class="defun">
 Function: <b>elephant-data-store:serialize</b><var> frob bs sc<a name="index-elephant_002ddata_002dstore_003aserialize-274"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003aserialize-275"></a>Generic interface to serialization that dispatches based on the
   current Elephant version
</p>

</blockquote></div>

<p><a name="Function-elephant_002ddata_002dstore_003adeserialize"></a>

</p>

<div class="defun">
 Function: <b>elephant-data-store:deserialize</b><var> bs sc &amp;optional oid-only<a name="index-elephant_002ddata_002dstore_003adeserialize-276"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003adeserialize-277"></a>Generic interface to serialization that dispatches based on the
   current Elephant version
</p>

</blockquote></div>

<p>These utility functions are useful if a data store does not have the
ability to store variable length binary data.  They are based on the
<code>cl-base64</code> library.

   </p>

<p><a name="Function-elephant_002ddata_002dstore_003aserialize_002dto_002dbase64_002dstring"></a>

</p>

<div class="defun">
 Function: <b>elephant-data-store:serialize-to-base64-string</b><var> x sc<a name="index-elephant_002ddata_002dstore_003aserialize_002dto_002dbase64_002dstring-278"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003aserialize_002dto_002dbase64_002dstring-279"></a>Encode object using the store controller's serializer format,
   but encoded in a base64
</p>

</blockquote></div>

<p><a name="Function-elephant_002ddata_002dstore_003adeserialize_002dfrom_002dbase64_002dstring"></a>

</p>

<div class="defun">
 Function: <b>elephant-data-store:deserialize-from-base64-string</b><var> x sc<a name="index-elephant_002ddata_002dstore_003adeserialize_002dfrom_002dbase64_002dstring-280"></a></var><br>
<blockquote>
<p><a name="index-elephant_002ddata_002dstore_003adeserialize_002dfrom_002dbase64_002dstring-281"></a>Decode a base64-string using the store controller's deserialize method
</p>

</blockquote></div>

<!-- @node DSR Memory Utilities -->
<!-- @comment node-name, next, previous, up -->
<!-- @section Memory utilities -->
<!-- @cindex Memory utilities -->
<!-- Details about memory utilities here. -->
<!-- @node DSR Foreign Libraries -->
<!-- @comment node-name, next, previous, up -->
<!-- @section Foreign libraries -->
<!-- @cindex Foreign libraries -->
<!-- How foreign libraries are built and used via UFFI.  What functions are -->
<!-- in the .asd files or main lisp code to build & load libraries? -->
<!-- *-texinfo-*- -->
<div class="node">

<p></p>

<hr>
<a name="Copyright-and-License"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Concept-Index">Concept Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Data-Store-API-Reference">Data Store API Reference</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name, next, previous, up -->
<h2 class="chapter">9 Copyright and License</h2>

<p><a name="index-Copyright-and-License-282"></a><a name="index-License-283"></a>

</p>

<h3 class="section">9.1 Elephant Licensing</h3>

<p>Elephant is a persistent metaprotocol and object-oriented database for
Common Lisp.  Detailed information and distributions can be found at
<a href="http://www.common-lisp.net/project/elephant">http://www.common-lisp.net/project/elephant</a>.

   </p>

<p>The program is released under the following license:

   </p>

<blockquote>
Elephant users are granted the rights to distribute and use this
software as governed by the terms of the Lisp Lesser GNU Public
License <a href="http://opensource.franz.com/preamble.html">http://opensource.franz.com/preamble.html</a>, also known
as the LLGPL. 
</blockquote>

<p>Copyrights include:

   </p>

<blockquote>
Original Version, Copyright © 2004 Ben Lee and Andrew Blumberg. <br>
Version 0.5, Copyright © 2006 Robert L. Read. <br>
Versions 0.6-0.9, Copyright © 2006-2007 Ian Eslick and Robert L. Read <br>
Portions copyright respective contributors (see <samp><span class="file">CREDITS</span></samp>). 
</blockquote>

<p>Portions of the program (namely the C unicode string sorter) are
derived from IBM's ICU: <a href="http://oss.software.ibm.com/icu/">ICU Website</a> whose copyright and license follows below.

   </p>

<blockquote>
ICU License - ICU 1.8.1 and later
COPYRIGHT AND PERMISSION NOTICE

<p>Copyright (c) 1995-2003 International Business Machines
Corporation and others All rights reserved.

        </p>

<p>Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the
Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute,
and/or sell copies of the Software, and to permit persons to
whom the Software is furnished to do so, provided that the
above copyright notice(s) and this permission notice appear
in all copies of the Software and that both the above
copyright notice(s) and this permission notice appear in
supporting documentation.

        </p>

<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO
EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS
NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR
CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

        </p>

<p>Except as contained in this notice, the name of a copyright
holder shall not be used in advertising or otherwise to
promote the sale, use or other dealings in this Software
without prior written authorization of the copyright holder.

        </p>

<p>

        </p>

<p>All trademarks and registered trademarks mentioned herein
are the property of their respective owners. 
</p>

</blockquote>

<h3 class="section">9.2 Elephant Manual Copyright and Licensing</h3>

<blockquote>
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License. 
</blockquote>

<p>Copyrights include:

   </p>

<blockquote>
Original Version, Copyright © 2004 Ben Lee. <br>
Versions 0.5-0.6, Copyright © 2006 Robert L. Read. <br>
Current Version, Copyright © 2006-2007 Ian Eslick and Robert L. Read <br>
</blockquote>

<h3 class="section">9.3 3rd Party Libraries</h3>

<p>Elephant depends on 3rd party lisp libraries.  See their respective
distributions for detailed copyright and licensing information.  The
following is a brief summary.

     </p>

<ul>
<li><b>uffi</b>: By Kevin Rosenberg, no significant restrictions
</li><li><b>cl-base64</b>: By Kevin Rosenberg, no significant restrictions
</li><li><b>rt</b>: By Richard Waters, MIT License
</li></ul>

<h3 class="section">9.4 Data Store Licensing Considerations</h3>

<p>The Berkeley DB data store is based on the Berkeley DB C library, now
owned by Oracle, but available as GPL'ed software.  It is important to
understand that applications using Berkeley DB must also be GPL'ed
unless you negotiate a commercial license from Oracle.  In most
interpretations of the license, this includes a requirement to make
code available for the entirety of any publicly visible website that
is based on Berkeley DB.  See

   </p>

<p><a href="http://www.oracle.com/technology/software/products/berkeley-db/htdocs/bdboslicense.html">http://www.oracle.com/technology/software/products/berkeley-db/htdocs/bdboslicense.html</a>.

   </p>

<p>The CL-SQL backend, depending on which SQL engine you use, may not
carry this restriction and you can easily migrate data between the
two.  Since the Berkeley DB store is 4-5x faster than SQL, it may make
sense to develop under BDB and transition to SQL after you've tuned
the performance of the application.  Licenses for various SQL engines
can be found at:

     </p>

<ul>
<li>SQLite: Public Domain, see <a href="http://www.sqlite.org/copyright.html">the SQLite license page</a>
</li><li>Postgresql: BSD License, see <a href="http://www.postgresql.org/about/licence">the Postgresql license page</a>
</li><li>MySQL: Dual licensing (similar to BDB), see <a href="http://www.mysql.com/company/legal/licensing/">the MySQL license page</a>
</li></ul>

<div class="node">

<p></p>

<hr>
<a name="Concept-Index"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Object-Index">Object Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Copyright-and-License">Copyright and License</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="appendix">Appendix A Concept Index</h2>

<ul class="index-cp" compact="compact">
<li><a href="#index-API-194">API</a>: <a href="#Data-Store-API-Reference">Data Store API Reference</a></li>
<li><a href="#index-API-173">API</a>: <a href="#Migration-and-Upgrading-API">Migration and Upgrading API</a></li>
<li><a href="#index-API-163">API</a>: <a href="#Transaction-API">Transaction API</a></li>
<li><a href="#index-API-127">API</a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-API-93">API</a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-API-66">API</a>: <a href="#BTree-API">BTree API</a></li>
<li><a href="#index-API-35">API</a>: <a href="#Persistent-Object-Indexing-API">Persistent Object Indexing API</a></li>
<li><a href="#index-API-29">API</a>: <a href="#Persistent-Object-API">Persistent Object API</a></li>
<li><a href="#index-API-9">API</a>: <a href="#Store-Controller-API">Store Controller API</a></li>
<li><a href="#index-API-Reference-7">API Reference</a>: <a href="#User-API-Reference">User API Reference</a></li>
<li><a href="#index-BTree-65">BTree</a>: <a href="#BTree-API">BTree API</a></li>
<li><a href="#index-Collections-237">Collections</a>: <a href="#DSR-Collections">DSR Collections</a></li>
<li><a href="#index-Copyright-and-License-282">Copyright and License</a>: <a href="#Copyright-and-License">Copyright and License</a></li>
<li><a href="#index-Cursor-124">Cursor</a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-Cursors-250">Cursors</a>: <a href="#DSR-Cursors">DSR Cursors</a></li>
<li><a href="#index-Cursors-92">Cursors</a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-Data-Store-193">Data Store</a>: <a href="#Data-Store-API-Reference">Data Store API Reference</a></li>
<li><a href="#index-design-192">design</a>: <a href="#Elephant-Architecture">Elephant Architecture</a></li>
<li><a href="#index-Design-Patterns-191">Design Patterns</a>: <a href="#Design-Patterns">Design Patterns</a></li>
<li><a href="#index-Goals-2">Goals</a>: <a href="#Introduction">Introduction</a></li>
<li><a href="#index-History-1">History</a>: <a href="#Introduction">Introduction</a></li>
<li><a href="#index-Index-125">Index</a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-Indices-126">Indices</a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-Installation-4">Installation</a>: <a href="#Installation">Installation</a></li>
<li><a href="#index-License-283">License</a>: <a href="#Copyright-and-License">Copyright and License</a></li>
<li><a href="#index-Migration-and-Upgrading-172">Migration and Upgrading</a>: <a href="#Migration-and-Upgrading-API">Migration and Upgrading API</a></li>
<li><a href="#index-Multithreading-272">Multithreading</a>: <a href="#DSR-Multithreading-Considerations">DSR Multithreading Considerations</a></li>
<li><a href="#index-Persistent-Object-Indexing-34">Persistent Object Indexing</a>: <a href="#Persistent-Object-Indexing-API">Persistent Object Indexing API</a></li>
<li><a href="#index-Persistent-Objects-28">Persistent Objects</a>: <a href="#Persistent-Object-API">Persistent Object API</a></li>
<li><a href="#index-Persistent-Objects-and-Slot-Access-218">Persistent Objects and Slot Access</a>: <a href="#DSR-Persistent-Objects-and-Slot-Access">DSR Persistent Objects and Slot Access</a></li>
<li><a href="#index-Persistent-Sets-50">Persistent Sets</a>: <a href="#Persistent-Set-API">Persistent Set API</a></li>
<li><a href="#index-Registration-and-Initialization-195">Registration and Initialization</a>: <a href="#DSR-Registration">DSR Registration</a></li>
<li><a href="#index-Serializer-273">Serializer</a>: <a href="#DSR-Handling-Serialization">DSR Handling Serialization</a></li>
<li><a href="#index-Store-Controller-8">Store Controller</a>: <a href="#Store-Controller-API">Store Controller API</a></li>
<li><a href="#index-Store-Controllers-200">Store Controllers</a>: <a href="#DSR-Store-Controllers">DSR Store Controllers</a></li>
<li><a href="#index-Transaction-API-162">Transaction API</a>: <a href="#Transaction-API">Transaction API</a></li>
<li><a href="#index-Transactions-255">Transactions</a>: <a href="#DSR-Transactions">DSR Transactions</a></li>
<li><a href="#index-Tutorial-3">Tutorial</a>: <a href="#Tutorial">Tutorial</a></li>
<li><a href="#index-User-API-Reference-6">User API Reference</a>: <a href="#User-API-Reference">User API Reference</a></li>
<li><a href="#index-User-Guide-5">User Guide</a>: <a href="#User-Guide">User Guide</a></li>
   </ul><div class="node">

<p></p>

<hr>
<a name="Object-Index"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Function-_002f-Macro-Index">Function / Macro Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Concept-Index">Concept Index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="appendix">Appendix B Object Index</h2>

<ul class="index-tp" compact="compact">
<li><a href="#index-elephant_003abtree-240"><code>elephant:btree</code></a>: <a href="#DSR-Collections">DSR Collections</a></li>
<li><a href="#index-elephant_003abtree_002dindex-242"><code>elephant:btree-index</code></a>: <a href="#DSR-Collections">DSR Collections</a></li>
<li><a href="#index-elephant_003acursor-251"><code>elephant:cursor</code></a>: <a href="#DSR-Cursors">DSR Cursors</a></li>
<li><a href="#index-elephant_003aindexed_002dbtree-244"><code>elephant:indexed-btree</code></a>: <a href="#DSR-Collections">DSR Collections</a></li>
<li><a href="#index-elephant_003apersistent-221"><code>elephant:persistent</code></a>: <a href="#DSR-Persistent-Objects-and-Slot-Access">DSR Persistent Objects and Slot Access</a></li>
<li><a href="#index-elephant_003apersistent_002dcollection-238"><code>elephant:persistent-collection</code></a>: <a href="#DSR-Collections">DSR Collections</a></li>
<li><a href="#index-elephant_003apersistent_002dmetaclass-219"><code>elephant:persistent-metaclass</code></a>: <a href="#DSR-Persistent-Objects-and-Slot-Access">DSR Persistent Objects and Slot Access</a></li>
<li><a href="#index-elephant_003apersistent_002dobject-223"><code>elephant:persistent-object</code></a>: <a href="#DSR-Persistent-Objects-and-Slot-Access">DSR Persistent Objects and Slot Access</a></li>
<li><a href="#index-elephant_003apset-51"><code>elephant:pset</code></a>: <a href="#Persistent-Set-API">Persistent Set API</a></li>
<li><a href="#index-elephant_003asecondary_002dcursor-253"><code>elephant:secondary-cursor</code></a>: <a href="#DSR-Cursors">DSR Cursors</a></li>
<li><a href="#index-elephant_003astore_002dcontroller-201"><code>elephant:store-controller</code></a>: <a href="#DSR-Store-Controllers">DSR Store Controllers</a></li>
   </ul><div class="node">

<p></p>

<hr>
<a name="Function-/-Macro-Index"></a>
<a name="Function-_002f-Macro-Index"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Variable-Index">Variable Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Object-Index">Object Index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="appendix">Appendix C Function / Macro Index</h2>

<ul class="index-fn" compact="compact">
<li><a href="#index-after-187"><code>after</code></a>: <a href="#Migration-and-Upgrading-API">Migration and Upgrading API</a></li>
<li><a href="#index-around-211"><code>around</code></a>: <a href="#DSR-Store-Controllers">DSR Store Controllers</a></li>
<li><a href="#index-before-188"><code>before</code></a>: <a href="#Migration-and-Upgrading-API">Migration and Upgrading API</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003abuild_002dbtree-246"><code>elephant-data-store:build-btree</code></a>: <a href="#DSR-Collections">DSR Collections</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003aclose_002dcontroller-205"><code>elephant-data-store:close-controller</code></a>: <a href="#DSR-Store-Controllers">DSR Store Controllers</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003aconnection_002dis_002dindeed_002dopen-207"><code>elephant-data-store:connection-is-indeed-open</code></a>: <a href="#DSR-Store-Controllers">DSR Store Controllers</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003acontroller_002dabort_002dtransaction-262"><code>elephant-data-store:controller-abort-transaction</code></a>: <a href="#DSR-Transactions">DSR Transactions</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003acontroller_002dcommit_002dtransaction-260"><code>elephant-data-store:controller-commit-transaction</code></a>: <a href="#DSR-Transactions">DSR Transactions</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003acontroller_002dstart_002dtransaction-258"><code>elephant-data-store:controller-start-transaction</code></a>: <a href="#DSR-Transactions">DSR Transactions</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003adatabase_002dversion-209"><code>elephant-data-store:database-version</code></a>: <a href="#DSR-Store-Controllers">DSR Store Controllers</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003adeserialize-276"><code>elephant-data-store:deserialize</code></a>: <a href="#DSR-Handling-Serialization">DSR Handling Serialization</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003adeserialize_002ddatabase_002dversion_002dvalue-216"><code>elephant-data-store:deserialize-database-version-value</code></a>: <a href="#DSR-Store-Controllers">DSR Store Controllers</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003adeserialize_002dfrom_002dbase64_002dstring-280"><code>elephant-data-store:deserialize-from-base64-string</code></a>: <a href="#DSR-Handling-Serialization">DSR Handling Serialization</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003aexecute_002dtransaction-256"><code>elephant-data-store:execute-transaction</code></a>: <a href="#DSR-Transactions">DSR Transactions</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003aget_002dcon-225"><code>elephant-data-store:get-con</code></a>: <a href="#DSR-Persistent-Objects-and-Slot-Access">DSR Persistent Objects and Slot Access</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003aget_002duser_002dconfiguration_002dparameter-198"><code>elephant-data-store:get-user-configuration-parameter</code></a>: <a href="#DSR-Registration">DSR Registration</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003amake_002dtransaction_002drecord-266"><code>elephant-data-store:make-transaction-record</code></a>: <a href="#DSR-Transactions">DSR Transactions</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003anext_002doid-227"><code>elephant-data-store:next-oid</code></a>: <a href="#DSR-Persistent-Objects-and-Slot-Access">DSR Persistent Objects and Slot Access</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003aopen_002dcontroller-203"><code>elephant-data-store:open-controller</code></a>: <a href="#DSR-Store-Controllers">DSR Store Controllers</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003apersistent_002dslot_002dboundp-233"><code>elephant-data-store:persistent-slot-boundp</code></a>: <a href="#DSR-Persistent-Objects-and-Slot-Access">DSR Persistent Objects and Slot Access</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003apersistent_002dslot_002dmakunbound-235"><code>elephant-data-store:persistent-slot-makunbound</code></a>: <a href="#DSR-Persistent-Objects-and-Slot-Access">DSR Persistent Objects and Slot Access</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003apersistent_002dslot_002dreader-231"><code>elephant-data-store:persistent-slot-reader</code></a>: <a href="#DSR-Persistent-Objects-and-Slot-Access">DSR Persistent Objects and Slot Access</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003apersistent_002dslot_002dwriter-229"><code>elephant-data-store:persistent-slot-writer</code></a>: <a href="#DSR-Persistent-Objects-and-Slot-Access">DSR Persistent Objects and Slot Access</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003aregister_002ddata_002dstore_002dcon_002dinit-196"><code>elephant-data-store:register-data-store-con-init</code></a>: <a href="#DSR-Registration">DSR Registration</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003aserialize-274"><code>elephant-data-store:serialize</code></a>: <a href="#DSR-Handling-Serialization">DSR Handling Serialization</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003aserialize_002ddatabase_002dversion_002dkey-212"><code>elephant-data-store:serialize-database-version-key</code></a>: <a href="#DSR-Store-Controllers">DSR Store Controllers</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003aserialize_002ddatabase_002dversion_002dvalue-214"><code>elephant-data-store:serialize-database-version-value</code></a>: <a href="#DSR-Store-Controllers">DSR Store Controllers</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003aserialize_002dto_002dbase64_002dstring-278"><code>elephant-data-store:serialize-to-base64-string</code></a>: <a href="#DSR-Handling-Serialization">DSR Handling Serialization</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003atransaction_002dobject-270"><code>elephant-data-store:transaction-object</code></a>: <a href="#DSR-Transactions">DSR Transactions</a></li>
<li><a href="#index-elephant_002ddata_002dstore_003atransaction_002dstore-268"><code>elephant-data-store:transaction-store</code></a>: <a href="#DSR-Transactions">DSR Transactions</a></li>
<li><a href="#index-elephant_003aadd_002dindex-82"><code>elephant:add-index</code></a>: <a href="#BTree-API">BTree API</a></li>
<li><a href="#index-elephant_003aadd_002dto_002droot-20"><code>elephant:add-to-root</code></a>: <a href="#Store-Controller-API">Store Controller API</a></li>
<li><a href="#index-elephant_003aclose_002dstore-16"><code>elephant:close-store</code></a>: <a href="#Store-Controller-API">Store Controller API</a></li>
<li><a href="#index-elephant_003acontroller_002dabort_002dtransaction-168"><code>elephant:controller-abort-transaction</code></a>: <a href="#Transaction-API">Transaction API</a></li>
<li><a href="#index-elephant_003acontroller_002dcommit_002dtransaction-170"><code>elephant:controller-commit-transaction</code></a>: <a href="#Transaction-API">Transaction API</a></li>
<li><a href="#index-elephant_003acontroller_002dstart_002dtransaction-166"><code>elephant:controller-start-transaction</code></a>: <a href="#Transaction-API">Transaction API</a></li>
<li><a href="#index-elephant_003acursor_002dclose-98"><code>elephant:cursor-close</code></a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dcurrent-102"><code>elephant:cursor-current</code></a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002ddelete-120"><code>elephant:cursor-delete</code></a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dduplicate-100"><code>elephant:cursor-duplicate</code></a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dfirst-104"><code>elephant:cursor-first</code></a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dget_002dboth-116"><code>elephant:cursor-get-both</code></a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dget_002dboth_002drange-118"><code>elephant:cursor-get-both-range</code></a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dlast-106"><code>elephant:cursor-last</code></a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dnext-108"><code>elephant:cursor-next</code></a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dnext_002ddup-148"><code>elephant:cursor-next-dup</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dnext_002dnodup-146"><code>elephant:cursor-next-nodup</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dpcurrent-128"><code>elephant:cursor-pcurrent</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dpfirst-130"><code>elephant:cursor-pfirst</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dpget_002dboth-142"><code>elephant:cursor-pget-both</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dpget_002dboth_002drange-144"><code>elephant:cursor-pget-both-range</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dplast-132"><code>elephant:cursor-plast</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dpnext-134"><code>elephant:cursor-pnext</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dpnext_002ddup-152"><code>elephant:cursor-pnext-dup</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dpnext_002dnodup-150"><code>elephant:cursor-pnext-nodup</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dpprev-136"><code>elephant:cursor-pprev</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dpprev_002ddup-160"><code>elephant:cursor-pprev-dup</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dpprev_002dnodup-158"><code>elephant:cursor-pprev-nodup</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dprev-110"><code>elephant:cursor-prev</code></a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dprev_002ddup-156"><code>elephant:cursor-prev-dup</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dprev_002dnodup-154"><code>elephant:cursor-prev-nodup</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dpset-138"><code>elephant:cursor-pset</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dpset_002drange-140"><code>elephant:cursor-pset-range</code></a>: <a href="#Index-Cursor-API">Index Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dput-122"><code>elephant:cursor-put</code></a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dset-112"><code>elephant:cursor-set</code></a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-elephant_003acursor_002dset_002drange-114"><code>elephant:cursor-set-range</code></a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-elephant_003adefpclass-30"><code>elephant:defpclass</code></a>: <a href="#Persistent-Object-API">Persistent Object API</a></li>
<li><a href="#index-elephant_003adrop_002dbtree-76"><code>elephant:drop-btree</code></a>: <a href="#BTree-API">BTree API</a></li>
<li><a href="#index-elephant_003adrop_002dinstance-32"><code>elephant:drop-instance</code></a>: <a href="#Persistent-Object-API">Persistent Object API</a></li>
<li><a href="#index-elephant_003adrop_002dinstances-48"><code>elephant:drop-instances</code></a>: <a href="#Persistent-Object-Indexing-API">Persistent Object Indexing API</a></li>
<li><a href="#index-elephant_003adrop_002dpset-63"><code>elephant:drop-pset</code></a>: <a href="#Persistent-Set-API">Persistent Set API</a></li>
<li><a href="#index-elephant_003aexistsp-74"><code>elephant:existsp</code></a>: <a href="#BTree-API">BTree API</a></li>
<li><a href="#index-elephant_003afind_002ditem-57"><code>elephant:find-item</code></a>: <a href="#Persistent-Set-API">Persistent Set API</a></li>
<li><a href="#index-elephant_003aget_002dfrom_002droot-18"><code>elephant:get-from-root</code></a>: <a href="#Store-Controller-API">Store Controller API</a></li>
<li><a href="#index-elephant_003aget_002dindex-84"><code>elephant:get-index</code></a>: <a href="#BTree-API">BTree API</a></li>
<li><a href="#index-elephant_003aget_002dinstance_002dby_002dvalue-42"><code>elephant:get-instance-by-value</code></a>: <a href="#Persistent-Object-Indexing-API">Persistent Object Indexing API</a></li>
<li><a href="#index-elephant_003aget_002dinstances_002dby_002dclass-40"><code>elephant:get-instances-by-class</code></a>: <a href="#Persistent-Object-Indexing-API">Persistent Object Indexing API</a></li>
<li><a href="#index-elephant_003aget_002dinstances_002dby_002drange-46"><code>elephant:get-instances-by-range</code></a>: <a href="#Persistent-Object-Indexing-API">Persistent Object Indexing API</a></li>
<li><a href="#index-elephant_003aget_002dinstances_002dby_002dvalue-44"><code>elephant:get-instances-by-value</code></a>: <a href="#Persistent-Object-Indexing-API">Persistent Object Indexing API</a></li>
<li><a href="#index-elephant_003aget_002dprimary_002dkey-86"><code>elephant:get-primary-key</code></a>: <a href="#BTree-API">BTree API</a></li>
<li><a href="#index-elephant_003aget_002dvalue-69"><code>elephant:get-value</code></a>: <a href="#BTree-API">BTree API</a></li>
<li><a href="#index-elephant_003ainsert_002ditem-53"><code>elephant:insert-item</code></a>: <a href="#Persistent-Set-API">Persistent Set API</a></li>
<li><a href="#index-elephant_003amake_002dbtree-67"><code>elephant:make-btree</code></a>: <a href="#BTree-API">BTree API</a></li>
<li><a href="#index-elephant_003amake_002dcursor-96"><code>elephant:make-cursor</code></a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-elephant_003amake_002dindexed_002dbtree-80"><code>elephant:make-indexed-btree</code></a>: <a href="#BTree-API">BTree API</a></li>
<li><a href="#index-elephant_003amap_002dbtree-78"><code>elephant:map-btree</code></a>: <a href="#BTree-API">BTree API</a></li>
<li><a href="#index-elephant_003amap_002dclass-36"><code>elephant:map-class</code></a>: <a href="#Persistent-Object-Indexing-API">Persistent Object Indexing API</a></li>
<li><a href="#index-elephant_003amap_002dindex-90"><code>elephant:map-index</code></a>: <a href="#BTree-API">BTree API</a></li>
<li><a href="#index-elephant_003amap_002dindices-248"><code>elephant:map-indices</code></a>: <a href="#DSR-Collections">DSR Collections</a></li>
<li><a href="#index-elephant_003amap_002dinverted_002dindex-38"><code>elephant:map-inverted-index</code></a>: <a href="#Persistent-Object-Indexing-API">Persistent Object Indexing API</a></li>
<li><a href="#index-elephant_003amap_002dpset-59"><code>elephant:map-pset</code></a>: <a href="#Persistent-Set-API">Persistent Set API</a></li>
<li><a href="#index-elephant_003amap_002droot-26"><code>elephant:map-root</code></a>: <a href="#Store-Controller-API">Store Controller API</a></li>
<li><a href="#index-elephant_003amigrate-176"><code>elephant:migrate</code></a>: <a href="#Migration-and-Upgrading-API">Migration and Upgrading API</a></li>
<li><a href="#index-elephant_003aopen_002dstore-14"><code>elephant:open-store</code></a>: <a href="#Store-Controller-API">Store Controller API</a></li>
<li><a href="#index-elephant_003apset_002dlist-61"><code>elephant:pset-list</code></a>: <a href="#Persistent-Set-API">Persistent Set API</a></li>
<li><a href="#index-elephant_003aremove_002dfrom_002droot-22"><code>elephant:remove-from-root</code></a>: <a href="#Store-Controller-API">Store Controller API</a></li>
<li><a href="#index-elephant_003aremove_002dindex-88"><code>elephant:remove-index</code></a>: <a href="#BTree-API">BTree API</a></li>
<li><a href="#index-elephant_003aremove_002ditem-55"><code>elephant:remove-item</code></a>: <a href="#Persistent-Set-API">Persistent Set API</a></li>
<li><a href="#index-elephant_003aremove_002dkv-71"><code>elephant:remove-kv</code></a>: <a href="#BTree-API">BTree API</a></li>
<li><a href="#index-elephant_003aroot_002dexistsp-24"><code>elephant:root-existsp</code></a>: <a href="#Store-Controller-API">Store Controller API</a></li>
<li><a href="#index-elephant_003aupgrade-174"><code>elephant:upgrade</code></a>: <a href="#Migration-and-Upgrading-API">Migration and Upgrading API</a></li>
<li><a href="#index-elephant_003awith_002dbtree_002dcursor-94"><code>elephant:with-btree-cursor</code></a>: <a href="#BTree-Cursor-API">BTree Cursor API</a></li>
<li><a href="#index-elephant_003awith_002dopen_002dstore-12"><code>elephant:with-open-store</code></a>: <a href="#Store-Controller-API">Store Controller API</a></li>
<li><a href="#index-elephant_003awith_002dtransaction-164"><code>elephant:with-transaction</code></a>: <a href="#Transaction-API">Transaction API</a></li>
   </ul><div class="node">

<p></p>

<hr>
<a name="Variable-Index"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Colophon">Colophon</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Function-_002f-Macro-Index">Function / Macro Index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="appendix">Appendix D Variable Index</h2>

<ul class="index-vr" compact="compact">
<li><a href="#index-elephant_002ddata_002dstore_003a_002acurrent_002dtransaction_002a-264"><code>elephant-data-store:*current-transaction*</code></a>: <a href="#DSR-Transactions">DSR Transactions</a></li>
<li><a href="#index-elephant_003a_002astore_002dcontroller_002a-10"><code>elephant:*store-controller*</code></a>: <a href="#Store-Controller-API">Store Controller API</a></li>
   </ul><div class="node">

<p></p>

<hr>
<a name="Colophon"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variable-Index">Variable Index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="unnumbered">Colophon</h2>

<p>This manual is maintained in Texinfo, and automatically translated
into other forms (e.g. HTML or pdf). If you're <em>reading</em> this
manual in one of these non-Texinfo translated forms, that's fine, but
if you want to <em>modify</em> this manual, you are strongly advised to
seek out a Texinfo version and modify that instead of modifying a
translated version. Even better might be to seek out <em>the</em>
Texinfo version (maintained at the time of this writing as part of the
Elephant project at
<a href="http://www.common-lisp.net/project/elephant/">http://www.common-lisp.net/project/elephant/</a>) and submit a
patch.

   </p>

<div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> If you attempt to store an object
from one store into another, the system will issue an error condition
called <code>cross-reference-error</code></p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> Example provided by Ian Eslick, April 2007</p>

   <p class="footnote"><small>[<a name="fn-3" href="#fnd-3">3</a>]</small> Example provided by Ian Eslick, April 2007</p>

<p></p>

<hr></div>

</body></html>
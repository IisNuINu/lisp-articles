<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>``Condition Handling in the Lisp Language Family'' 
c       by Kent Pitman (2001)</title>
<meta http-equiv="Keywords" content="Conditions, Errors, Exceptions, Handling, Lisp, Signaling">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta name="ROBOTS" content="INDEX, NOFOLLOW">
</head>
<body vlink="#7700bb" text="#440077" link="#7700bb" bgcolor="#eeeeff" alink="#ff0000">

<font color="green">

<h1 align="center">Обработка условий в семействе языков Lisp </h1>

<p align="center">
<b>This paper appears in<br>
<a href="http://www.springer.de/cgi-bin/bag_generate.pl?ISBN=3-540-41952-7"><i>Advances in Exception Handling Techniques</i></a>,<br>
edited by A. Romanovsky, C. Dony, J.L. Knudsen, and A. Tripathi.<br>
This book, published in 2001, is part of 
<a href="http://www.springer.de/cgi-bin/search_book.pl?series=558">Lecture Notes in Computer Science, Volume 2022</a>,<br>
published by <a href="http://www.springer.de/">Springer</a>.
</b>
</p>

<p>
 This paper was originally written as an HTML document, exactly as shown
 below.  Any final reformatting that was done for hardcopy publication 
 in LaTeX may have been lost in this version.  
 Any new text that has been added for this annotated version
 appears bracketed and in color green; such text is intended to
 help clarify the historical context as time passes.<br>
--<a href="http://www.nhplace.com/kent/contact-kent.html"><i>Kent Pitman</i></a>, 28-Feb-2002.
</p>

<p align="center">
<a href="#ORIGINAL-START">Annotated original document follows.</a><br>
<a href="http://www.nhplace.com/kent/Papers/index.html"><i>Click here for an index 
of other titles by Kent Pitman.</i></a>
</p>

</font>

<hr>

<div align="center">

<a name="ORIGINAL-START"><h1>Обработка условий в семействе языков Lisp </h1></a>

<p>
<b><font color="green">by <a href="http://www.nhplace.com/kent/contact-kent.html">Kent M. Pitman</a></font></b>
</p>

<p>
<a href="#COPYRIGHT">Copyright Â© 2001, Kent M. Pitman.
                     All Rights Reserved.</a>
</p>

<p>
<a href="#COPYRIGHT"><font color="green">[ Web version Copyright Â© 2002, Kent M. Pitman.
                     All Rights Reserved. ]</font></a>
</p>

</div>

<h2>Введение</h2>

<p>
Семейство языков Lisp уже давно является богатым источником идей и 
вдохновения в области обработки ошибок. Здесь мы рассмотрим некоторые 
абстрактные концепции и терминологию, а также некоторые конкретные 
языковые конструкции, внесенные Lisp.
</p>

<p>
Хотя существует множество диалектов Лиспа, некоторые из которых предлагают 
современные концепции и возможности, описанные здесь, мы сосредоточимся 
конкретно на Common Lisp, как описано в стандарте ANSI, X3.226-1994
<a href="#x3j13-1994">[X3J13 1994]</a>.
</p>

<h3>Системы условий и системы ошибок</h3>

<p>
Сообщество Common Lisp обычно предпочитает говорить о своей 
<b class="newterm">condition system/системе условий</b>, а не о своей 
<b class="newterm">error system/системе ошибок</b>, чтобы подчеркнуть, 
что существуют не только фатальные, но и нефатальные ситуации, в 
которых возможности, предоставляемые этой системой, полезны.
</p>

<p>
Не все <b class="newterm">exceptional situations(исключительные ситуации)</b> 
представлены или иногда даже обнаруживаются. Ситуация, представленная в языке, 
называется в Common Lisp <b class="newterm">condition(условием)</b>; объект класса 
<code>CONDITION</code> используется для представления такой ситуации. 
</p>

<p>
<b class="newterm">Условие(condition)</b> называется обобщением 
<b class="newterm">ошибки(error)</b>. Соответственно, внутри языка 
класс <code>CONDITION</code> является суперклассом другого класса 
<code>ERROR</code>, который представляет ситуации, которые были бы 
фатальными, если бы не управлялись должным образом.
</p>

<p>
Таким образом, набор всех ситуаций, включающих условия, включает не 
только описания явно ошибочных ситуаций, но и описания ситуаций, которые 
просто необычны или сомнительны. Даже в случае отсутствия ошибок 
программист может, исходя из свободы выражения, выбрать использование тех же 
возможностей и протоколов, которые использовались бы для обработки 
«реальных» ошибок. 
</p>

<h3>Обработка условий - в первую очередь важен Протокол
</h3>

<p>
Чтобы правильно понять обработку условий, важно понимать, что в первую очередь 
речь идет о <b class="newterm">протоколе(protocol)</b>, а не просто о 
вычислительных возможностях. Установление протоколов - это своего рода преграда 
от «дилеммы заключенного»; то есть он создает очевидный способ для двух людей, 
которые не общаются напрямую, структурировать независимо разработанный код так, 
чтобы он работал таким образом, который оставался бы согласованным при 
последующем объединении такого кода.
</p>

<p>
Например, если мы хотим написать программу, которая ищет в списке объект, 
возвращая истину, если объект присутствует, и ложь в противном случае, мы 
могли бы написать следующее, но обычно этого не делали бы: 
</p>

<pre class="code"> (defun search-list (goal-item list-to-search)
   (handler-case 
       ;; Main body
       (progn (dolist (item list-to-search) 
                (when (eq item goal-item)
                  (return-from search-list t)))
              ;; Search has failed, signal an error.
              (error 'search-failure 
                     :item goal-item))
     ;; Upon error, just return false.
     (error () nil)))
</pre>

<p>
Причина не писать об этом заключается не в том, что это не сработает, а в том, 
что это связано с чрезмерным количеством ненужного механизма. Язык уже содержит 
более простые способы выражения передачи управления от точки A к точке B в программе, 
где один и тот же программист, действуя в той же роли, контролирует код в обеих точках. 
Например, достаточно следующего: 
</p>

<pre class="code"> (defun search-list (goal-item list-to-search)
   (dolist (item list-to-search) 
     (when (eq item goal-item)
       (return-from search-list t)))
   nil)
</pre>

<p>
<emph>Однако<emph>, если предполагаемое действие в случае неудачного поиска 
не было указано и должно было быть выполнено вызывающей стороной, 
использование механизмов обработки условий могло бы быть целесообразным. 
Например, в следующем коде происходит только сигнализация, а обработка 
предоставляется вызывающей стороне. Из-за этого использование средств 
обработки условий является целесообразным, поскольку эти средства будут 
обеспечивать службы согласования и передачи данных между сигнализатором 
и обработчиком. 
</emph></emph></p>

<pre class="code"> (defun search-list (goal-item list-to-search)
   (dolist (item list-to-search) 
     (when (eq item goal-item)
       (return-from search-list t)))
   (error 'search-failure :item goal-item))
</pre>

<p>
Протокол просто не нужен при лексическом взаимодействии между частями 
программы, которые были написаны как единое целое и которые не вызываются 
другими программами, которые либо логически разделены, либо, как минимум, логически разделены. Различие субъективно, но, тем не менее, важно.
</p>

<h2>Исторические влияния</h2>

<p>
Прежде чем начать подробно рассматривать особенности системы условий Common Lisp, 
полезно заметить, что компьютерные языки, как и человеческие языки, со временем 
развиваются как для удовлетворения текущих потребностей, так и для устранения проблем, 
наблюдаемых в прошлом опыте. Интересные особенности системы условий Common Lisp 
не возникли внезапно в один прекрасный день как спонтанный творческий акт, 
а скорее выросли из многолетнего предыдущего опыта работы с другими языками 
и системами. 
</p>

<h3>Влияние Multics PL/I на Symbolics Zetalisp</h3>

<p>
Язык PL/I, разработанный в IBM в начале 1960-х годов, включал обширный 
механизм условий, который имел расширяемый набор именованных сигналов 
и динамических обработчиков, работающих в динамическом контексте сигнала. 
Поскольку PL/I включал «нисходящие» лексические замыкания, эти обработчики 
имели доступ к среде с ошибками, а иногда и к деталям ошибки.

</p>

<p>
Multics, официальным языком которой был PL/I, адаптировал и расширил это, 
включая добавление <code>any_other</code>, <code>cleanup</code> и 
<code>unclaimed_signal</code>, передачу условий машины и других 
произвольных данных, сигналов домена перекрестной защиты и использование 
этого механизма для управления несколькими приостановленными средами 
в одном стеке. 
</p>

<p>
По соображениям безопасности в Multics было тщательно разработано и 
строго соблюдено разделение различных типов кода на защищенные «кольца». 
Операционная система Multics полагалась на свою расширенную систему 
сигнализации для нескольких важных системных функций, в основном в кольце 
пользователя, хотя в некоторых случаях возможны перекрестные сигналы вызова, 
связанные с  с ошибками подкачки или памяти.
</p>

<p>
Исторически Multics была «ранней» средой, но, судя по любому анализу, 
не была игрушкой. Его система условий была тщательно спроектирована, 
тщательно протестирована и обладала многими важными характеристиками, 
которые повлияли на более позднее проектирование Lisp: 
</p>

<ul>
<li>

<p>
Она отделяет понятие <b class="newterm">condition signaling(сигнализации условия)</b> 
от <b class="newterm">condition handling(обработки условия)</b>.
</p>

</li>

<li>

<p>
Она давала возможность через условия <code>program_interrupt</code> возобновить 
ошибочные вычисления, предположительно после исправления 
проблемной ситуации.
</p>

</li>

<li>

<p>
Она начала заниматься посредничеством сигнализации и обработки 
не только с помощью <b class="newterm">condition type</b>(типа условия), 
но и с помощью набора связанных(ассоциированных) данных, соответствующих 
этому типу: с помощью определенного системой оператора, называемого 
"<code>signal_</code>", ​​вместо обычного PL/I "<code>signal</code>" ,
блок данных может быть связан с сигнализируемым условием, что является 
грубым предшественником идеи объектно-ориентированных описаний условий, 
которая позже возникла в Лиспе.
</p>

</li>

<li>

<p>
Она начала работать с понятием обработки по умолчанию с помощью 
псевдоусловия <code>unclaimed_signal</code>.
</p>

</li>
</ul>

<p>
В начале 1980-х некоторые бывшие пользователи системы Multics, 
в том числе Дэниел Л. Вайнреб, Бернард Гринберг и Дэвид Мун, собрали
 хорошие идеи системы условий Multics PL/I и переработали их в Zetalisp, 
диалекте, работающем на Symbolics Lisp Машины. Этот редизайн назывался 
просто "New Error System"(Новая система ошибок) (или иногда просто «NES»). 
</p>

<h3>Влияние Symbolics Zetalisp на Common Lisp</h3>

<p>
Ключевыми элементами Новой системы ошибок (New Error System - NES) в Symbolics Zetalisp были:
</p>

<ul>
<li>
<p> NES имела объектно-ориентированный характер.</p>

</li>
<li>
<p>В NES обработка исключительных ситуаций четко разделена на 
три логически различных программных действия:</p>

<ul>
<li>Установление обработчиков.</li>
<li>Управление "proceed types"(типами продолжений) (то, что Common Lisp позже называл "restarts"(перезапусками)).</li>
<li>Обнаружение исключительных ситуаций и сигнализация соответствующих условий.</li>
</ul>

<p></p>

</li>

<li>
<p>NES обеспечивала возобновление работы ошибочных программ в интерактивном 
или неинтерактивном режиме, отделяя информацию о запросе на замену данных от 
каналов, которые будут передавать такие данные, чтобы программы, желающие 
выполнить механическое восстановление, могли обойти запрос, но использовать 
остальную часть конвейера восстановления. </p>

</li>
</ul>

<p>
NES напрямую и сильно повлияла на разработку системы условий Common Lisp. 
Фактически, одна из первых проблем, высказанных рядом поставщиков, 
заключалась в том, что они опасались, что каким-то образом идеи 
системы условий, взятые из среды Lisp Machine, не будут хорошо работать 
на стандартном оборудовании. Потребовалось несколько месяцев обсуждения 
и доступности бесплатной публичной реализации идей, прежде чем эти 
опасения улеглись и сообщество Common Lisp смогло принять их. Тем не менее, 
в процессе было внесено множество мелких изменений и несколько 
серьезных изменений.
</p>

<p>
И в Zetalisp, и в Common Lisp обработчики - это функции, которые вызываются 
в динамическом контексте операции сигнализации. При вызове обработчиков 
раскрутки стека еще не произошло. Потенциальные обработчики проверяются 
по порядку, пока один из них не решит обработать условие. Вероятно, 
наиболее заметным изменением между NES и Common Lisp Condition System 
был выбор того, как функция-обработчик сообщает о своем решении выбрать 
конкретный режим восстановления для сигнализируемого условия. 
</p>

<p>
NES использовала <b class="newterm">passive</b>(пассивный) механизм восстановления. 
То есть во всех случаях обработчик вернет одно или несколько значений. 
Природа возвращаемых значений будет определять, какой режим восстановления 
(в Zetalisp он называется "proceed type"(тип продолжения)) должен использоваться. 
Если был возвращен <code>NIL</code>, обработчик не выбрал тип продолжения, 
и был испробован следующий обработчик. В противном случае обработчик должен 
вернуть по крайней мере одно значение, ключевое слово, обозначающее тип обработки, 
и, необязательно, дополнительные значения, которые были данными, соответствующими 
этому способу обработки.
</p>

<p>
Common Lisp использует <b class="newterm">active</b>(активный) механизм восстановления. 
То есть любой обработчик, который желает назначить механизм восстановления 
(называемый "restart"(перезапуском) в Common Lisp), должен обязательно 
передать управление этому перезапуску. Если обработчик не передает управление, 
то есть, если обработчик нормально возвращается, любые возвращаемые значения 
игнорируются, и говорят, что обработчик "restart"(отклонил) (то есть не выбрал перезапуск), 
и пробуется следующий обработчик. 
</p>

<h3>Опыт Maclisp</h3>

<p>
Мне обычно приписывают «создание» Common Lisp Condition System, хотя 
я надеюсь показать в этой статье, что моя роль в разработке заключалась 
в основном в том, чтобы брать идеи других и аккуратно переносить их в 
Common Lisp. При этом я полагался на свой личный опыт, который руководил мной, 
и многие из моих формирующих опытов пришли из моей работы с Маклиспом 
<a href="#pitman-1983">[Pitman 1983]</a>, 
которая зародилась в проекте MAC Массачусетского технологического института 
(позже переименованном в Лабораторию компьютерных наук), и который работал н
а системах Digital Equipment Corporation (DEC) PDP10, DEC TOPS20 и Honeywell Multics.
</p>

<p>
Маклисп имел относительно примитивную систему ошибок, которую я широко 
использовал. В то время, когда я пришел к NES Лисп-машины, я не знал, 
что я ищу в системе ошибок, но я знал, основываясь на моем опыте работы 
с Maclisp, то, что я не искал. Итак, что меня сначала впечатлило в NES, 
так это то, что в ней были исправлены многие ошибки проектирования, 
которые я видел в Maclisp.
</p>

<p>
Одним из важных моментов в истории Maclisp, по крайней мере, о реализации PDP10, 
которую я использовал, было то, что у него не было типа данных STRING. Почти во 
всех случаях, когда можно было ожидать использования строк, вместо них 
использовались интернированные символы. Символы, содержащие символы, которые 
в противном случае могли бы сбить с толку токенизатор, были ограничены с обоих 
концов вертикальной чертой (<tt>|</tt>). Кроме того, поскольку символы обычно 
именуют переменные, их обычно приходилось заключать в кавычки с ведущей одинарной 
кавычкой (<tt>'</tt>), чтобы защитить их от механизма оценки Lisp и позволить 
использовать их как псевдостроки. 
</p>

<pre class="code"> '|This is a quoted Maclisp symbol.|
</pre>

<h4>Плохое разделение сигнализации и обработки в Maclisp</h4>

<p>
Маклисп имел две формы функции <code>ERROR</code>. В простой и наиболее широко 
используемой форме можно просто вызвать <code>ERROR</code> с одним аргументом, 
описанием ошибки. Такие ошибки остановят выполнение программы без возможности 
восстановления, кроме передачи на самый внутренний <code>ERRSET</code>, 
приблизительный Maclisp-эквивалент <code>IGNORE-ERRORS</code> в Common Lisp. 
</p>

<pre class="code"> (error '|YOU LOSE|)
</pre>

<p>
Однако можно было ограниченным образом указать конкретный вид ошибки. Было около 
дюжины предопределенных типов ошибок, которые можно было идентифицировать и которые 
действительно позволяли исправить ситуацию. Например, 
</p>

<pre class="code"> (error '|VARIABLE HAS NO VALUE| 'A 'UNBND-VRBL)
</pre>

<p>
«Ключевое слово» <code>UNBND-VRBL</code> было системным именем, которое 
указывало системе, что это была ошибка типа "unbound variable"(несвязанная переменная). 
В этом случае была разрешена конкретная стратегия восстановления. Можно либо интерактивно 
в точке останова, либо путем динамического установления обработчика таких ошибок указать 
значение для переменной. Если это произойдет, вызов <code>ERROR</code> затем вернет список 
этого значения, и ожидается, что вызывающий <code>ERROR</code> получит это значение и 
использует его.
</p>

<p>
Это прекрасно работало в случае, когда программист знал тип ошибки и был готов 
исправить ее. Но произошла странная ситуация, когда человек знал, что за ошибка,
 но не был готов к исправлению. Иногда кто-то знал, что у него есть несвязанная 
переменная, и хотел вызвать <code>ERROR</code>, но не был готов к восстановлению. 
В этом случае программист был вынужден солгать и сказать, что это была ошибка 
произвольного типа, используя только краткую форму, чтобы избежать неправильного 
восприятия со стороны потенциальных обработчиков, что возврат значения восстановления 
был бы полезен. 
</p>

<pre class="code"> (error '|VARIABLE HAS NO VALUE| 'A)
</pre>

<p>
Одна из особенностей NES, которая лично мне показалась очень привлекательной, 
заключалась в том, что я мог свободно указывать класс ошибки, независимо от того, 
готов ли я справиться с ней каким-либо определенным образом. Вопрос о том, как 
обрабатывать ошибку, был задан ортогонально.
</p>

<h4>Идентификация сообщения об ошибке в Maclisp</h4>

<p>
В PDP10 Maclisp сообщения об ошибках всегда были в верхнем регистре, 
поскольку в системе были примитивные сообщения об ошибках, и многие 
пользователи находили эстетически неприятным иметь некоторые сообщения 
в смешанном регистре, в то время как другие были полностью в верхнем регистре. 
Однако в какой-то момент возникла необходимость предоставлять сообщения 
об ошибках со смешанным регистром. Сторонники Maclisp того времени решили
не поддаваться такому давлению.
</p>

<p>
Проблема заключалась в том, что многие программы, столкнувшиеся с сообщением об ошибке, 
проверяли его на идентичность объекта. Например: 
</p>

<pre class="code"> (eq msg '|UNBOUND VARIABLE|)
</pre>

<p>
Если бы мы изменили регистр всех сообщений об ошибках в системе Maclisp 
на любой другой, более низкий или смешанный, эти тесты немедленно начали 
бы давать сбои, ломая много установленного кода и требуя больших денег для 
исправления. Это изменение было бы беспричинным.
</p>

<p>
Урок из этого для всех нас в сообществе Maclisp, который стал более заметным позже, 
когда мы столкнулись с более широким сообществом международных пользователей, 
заключался в том, что идентичность ошибки не должна быть ее именем. То есть, 
если бы мы сделали это снова, мы бы не использовали <code>|unbound variable|</code> 
ни <code>|Unbound Variable|</code> как идентификатор ошибки, а скорее создавали 
бы объекты, чьи слоты или методы отвечали за выдачу представленной строки, 
но чьи идентичность и природа контролировались ортогонально. Это была еще 
одна вещь, которую предложила NES, которая сразу же привлекла меня к ней. 
</p>

<h3>Терминологические влияния</h3>

<p>
Во время разработки Common Lisp в Scheme не было системы ошибок, и поэтому 
ее вклад в диалог по системам условий не был вкладом оператора или поведения. 
Однако ему все же было что внести: полезный термин <b class="newterm">continuation</b>(продолжение).
Для наших целей здесь достаточно рассматривать продолжение как актуальную или 
концептуальную функцию, которая представляет, по сути, один из, возможно, 
нескольких «будущих миров», в любой из которых можно войти, выбрав вызов связанного 
с ним продолжения. 
</p>

<p>
Эта метафора имела для меня огромную социальную ценность в моих усилиях по 
принятию системы условий, потому что она позволяла удобное и краткое объяснение 
того, что означает "restarts"(перезапуск) в Common Lisp. Хотя по традиции 
продолжения Scheme обычно передаются явным потоком данных, это не является 
обязательным требованием. И поэтому я часто обнаруживал, что благодарен за 
доступность концепции, так что я мог говорить об установлении именованных 
точек перезапуска как «взятие продолжения, маркировка его тегом и хранение 
его где-нибудь на полке для возможного дальнейшего использования. . "

</p>

<p>
Точно так же я счел полезным в некоторых кругах сослаться на некоторые 
концепции рефлексивных Лиспов, такие как «3Lisp» Брайана Смита 
<a href="#smith-1982">[Smith 1982]</a>, и более поздние работы, вдохновленные им. 
Я считаю, что способность системы условий анализировать (с помощью таких операторов, 
как <code>FIND-RESTART</code>), какие возможные действия ожидают выполнения, 
без фактического вызова этих ожидающих действий, является важной отражающей 
способностью. Несмотря на то, что Common Lisp не предлагает универсального 
отражения, возможность использовать эту метафору для обсуждения тех аспектов 
языка, которые с его помощью описываются с пользой, упрощает общение. 
</p>

<h2>Абстрактные концепции</h2>

<p>
Теперь, когда мы надеемся, что твердо установили, что формирующие идеи 
в Common Lisp Condition System не все возникли вместе с самим языком и 
действительно являются наследием сообщества, использующего континуум языков, 
частью которых является Common Lisp, мы можем теперь обратить внимание на 
обзор некоторых важных функциональностей, которые предоставляет Common Lisp.
</p>

<h3>Разделение сигнализации и обработки</h3>

<p>
Традиционно "error handling"(обработка ошибок) в основном представляла собой 
процесс остановки программ, и единственный реальный вопрос заключался в том, 
«какая часть программы останавливается?» или "как далеко мне throw(бросить исключение)?" 
Именно на этом фоне можно лучше всего понять современную обработку условий.
</p>

<p>
Правильный способ думать об обработке условий - это:
</p>

<p>
Процесс программирования заключается в том, чтобы говорить, что делать в 
любых обстоятельствах. В этом отношении компьютер иногда характеризовали 
как «беспощадный судья незавершенности». Когда программа достигает места, 
где есть несколько возможных следующих шагов, и программа не желает или 
неспособна выбрать среди них, программа обнаружила исключительную ситуацию(<b class="newterm">exceptional situation</b>).
</p>

<p>
Возможные следующие шаги называются перезапусками(<b class="newterm">restarts</b>). 
Фактически перезапуски называются продолжениями(continuations).
</p>

<p>
Процесс обращения за помощью в решении проблемы выбора среди возможных следующих 
шагов называется сигнализацией(<b class="newterm">signaling</b>).
</p>

<p>
Независимые фрагменты кода, которые используются в процессе сигнализации, 
называются обработчиками(<b class="newterm">handlers</b>). В Common Lisp 
это функции, вносимые динамической цепочкой вызовов, которые проверяются(пробуются/tried) 
в порядке от самой внутренней  (то есть, наиболее специфичной/специальной) 
к самой внешней(то есть, наиболее общей). Каждый обработчик(функция) вызывается 
с аргументом, который является описанием проблемной ситуации. Обработчик 
передаст управление (с помощью <code>GO</code>, <code>RETURN</code> или 
<code>THROW</code>), если он решит решить проблему, описанную его аргументом.
</p>

<p>
Описывая обработку условий, я рассказываю следующую историю, чтобы помочь 
людям визуализировать потребность в ее различных частях:
</p>

<blockquote>

<p>
Думайте о процессе сигнализации и обработке как о поиске развилки на дороге, 
по которой вы обычно не путешествуете. Вы не знаете, куда идти, поэтому вы 
заявляете о своей дилемме, то есть вы сигнализируете о условии(состоянии). 
Представляются различные источники мудрости (обработчики), и вы консультируетесь 
с каждым, полагаясь на них, потому что у вас нет специальных знаний о том, 
что делать. Не все источники мудрости являются экспертами по всем темам, 
поэтому некоторые могут отказаться от помощи вам, прежде чем вы найдете того, 
кто уверен в их советах. Когда будет найден достаточно надежный источник мудрости, 
он будет действовать от вашего имени. Ситуация разрешена(обработана). 
</p>

</blockquote>

<p>
В случае, если ситуация не обрабатывается, следующее действие зависит от того, 
какой оператор использовался для подачи сигнала. Функция <code>signal</code> 
просто вернется в обычном режиме, когда условие не будет обработано. 
Функция <code>error</code> похожа на signal(сигнал), но вместо возврата 
она попадает в <b class="newterm">debugger</b>(отладчик). Отладчик 
Common Lisp может разрешить доступ к функциональности отладки низкого уровня, 
таким как проверка отдельных мест хранения, но это не обязательно. 
Его <emph>основная</emph> роль - быть интерактивным обработчиком
(<b class="newterm">interactive handler</b>); то есть интерактивно представить 
пользователю-человеку различные варианты возобновления вычислений. 
Концептуально это то же самое, как если бы он действовал в качестве доверенного 
лица пользователя, являясь элементом в списке обработчиков, так что пользователь-человек 
является источником мудрости, выбор которого будет определять дальнейшие действия. 
Другие возможности, которые отладчик может предложить для поддержки решения этого человека,
вероятно, очень важны на практике, но концептуально неинтересны для такого понимания роли 
отладчика в передаче сигналов и обработке.
</p>

<p>
Также обратите внимание, что в некотором возможном мире будущего представление 
знаний может быть достаточно продвинутым, чтобы обработчики могли вместо того, 
чтобы действовать безоговорочно от имени сигнализатора, просто возвращать представление 
набора потенциальных действий, сопровождаемых описательной информацией, соответствующей 
мотивации, последствиям и т. Д. и даже качественные представления о добродетели каждого 
из них. Такую информацию можно комбинировать, сравнивать или подтверждать рекомендациями 
из других источников мудрости, чтобы получить лучший результат. Вот как, вероятно, будет 
работать консультация с источниками мудрости в реальном мире. Учтите, что даже врач, 
уверенный в том, что нужно пациенту, прежде чем действовать, спросит у пациента разрешения. 
Однако этот последний шаг подтверждения, который обеспечил бы большую гибкость в 
процессе рассуждений, не проявился в Common Lisp на момент написания этой статьи. 
Это открытая область для будущих исследований.
</p>

<p>
Некоторые из этих вопросов обсуждаются более подробно в моем докладе на 
конференции 1990 года  <a href="#pitman-1990">[Pitman 1990]</a>.
</p>

<h3>Обобщенные условия</h3>

<p>
Ранее упоминалось, что пространство условий, которое может использоваться 
в Common Lisp Condition System, является более общим, чем пространство простых ошибок. 
Вот несколько примеров. 
</p>

<h4>Серьезные, Условия без ошибок</h4>

<p>
Суперкласс <code>error</code>(ошибки) это  <code>serious-condition</code>(серьезное условие). 
Этот вид условий является подклассом <code>condition</code>(условий), но достаточно серьезным, 
чтобы условия такого рода обычно попадали в отладчик, если не обрабатывались. Серьезные условия,
которые Zetalisp NES назвал "debugger conditions"(условиями попадания в отладчик, или просто
условиями отладчика", существуют как концепция, отдельно от названных "error conditions"
(условий ошибки), чтобы приспособить вещи, которые не являются семантическими ошибками 
в программе, а являются ограничениями ресурсов и другими случайными дополнениями к 
прагматике.
</p>

<p>
Предположим, кто-то пишет следующее: 
</p>

<pre class="code"> (ignore-errors (open "some.file"))
</pre>

<p>
Это позволит отловить ошибки во время открытия файла. Однако что, если произойдет 
переполнение стека не по причинам бесконечной рекурсии, а просто потому, 
что вызов очень глубоко вложен в другой код? Ответ заключается в том, 
что переполнение стека считается серьезным условием(serious condition), 
но не ошибкой. Приведенный выше код эквивалентен: 
</p>

<pre class="code"> (handler-case (open "some.file")
   (error (c)
     (values nil c)))
</pre>

<p>
И поскольку любое условие, представляющее переполнение стека, будет своего 
рода <code>SERIOUS-CONDITION</code>(СЕРЬЕЗНЫМ УСЛОВИЕМ), но не разновидностью 
<code>ERROR</code>(ОШИБКИ), использование <code>IGNORE-ERRORS</code> приведет 
к улавливанию ошибки файла, но не переполнения стека. Если бы кто-то хотел 
перехватить еще и серьезными условия, вместо этого он бы написал: 
</p>

<pre class="code"> (handler-case (open "some.file")
   (serious-condition (c)
     (values nil c)))
</pre>

<h4>Не серьезные условия(Non-serious conditions)</h4>

<p>
Некоторые условия вовсе не серьезные. Такие условия могут быть обработаны, 
но есть очевидное действие по умолчанию в случае, если они не будут обработаны.
</p>

<p>
Рассмотрим программу, которая выводит на консоль построчно. Можно было бы 
предположить, что экран имеет бесконечную высоту, и результат может 
выглядеть так: 
</p>

<pre class="code"> (defvar *line-number* 0)
 (defun show-lines (lines)
   (dolist (line lines)
     (show-line line)))
</pre>

<p>
Тем не менее, может быть полезно указать высоту строки экрана и сделать так, 
чтобы консоль приостанавливалась каждые несколько строк, чтобы человек-читатель 
подтвердил, что можно продолжить. Конечно, есть несколько способов программирования 
такой функциональности, но один из возможных способов - использовать систему условий. 
Например, 
</p>

<pre class="code"> (defvar *line-number* 0)
 (defvar *page-height* nil)
 (define-condition end-of-page (condition) ())
 (defun show-lines (lines)
   (dolist (line lines)
     <font color="green">(show-line line)  ; Oops. Omitted this call from original paper!</font>
     (incf *line-number*)
     (when (and *page-height*
                (zerop (mod *line-number* *page-height*)))
       (restart-case (signal 'end-of-page)
         (continue ())))))
</pre>

<p>
В приведенном выше описании есть только один способ продолжения. Перезапуск с 
именем <code>CONTINUE</code> предлагается в качестве способа обязательного 
выбора этой опции (обязательного обхода любых других ожидающих обработчиков), 
но если обработчик отклоняется и условие остается необработанным, будет 
достигнут тот же результат.
</p>

<p>
Подобное средство можно использовать для управления обработкой конца строки. 
Там обычно разрешаются различные режимы, поэтому должен быть установлен 
соответствующий набор перезапусков, из которых будут выбирать обработчики. 
Однако, если ни один обработчик не выберет обработотку условия, большого 
вреда не будет. Вот пример того, как это может выглядеть: 
</p>

<pre class="code"> (defvar *line-length* nil)
 (define-condition end-of-line (condition) ())
 (defun show-line (line)
   (let ((eol (or *line-length* -1)) (hpos 0))
     (loop for pos below (length line)
           for ch = (char line pos)
           do (write-char ch)
           when (= hpos eol)
             do (restart-case (signal 'end-of-line)
                  (wrap ()
                    (write-char #\Newline)
                    (setq hpos 0))
                  (truncate ()
                    (return))
                  (continue ()
                    ;; just allow to continue
                    ))
           else do (incf hpos))))
</pre>

<h3>Независимая рефлексивная/отражающая спецификация перезапусков</h3>

<p>
Уже давно Lisp предлагал возможность динамически принимать решение о 
передаче в вычисленную точку возврата с помощью специального оператора 
<code>THROW</code>. Однако без рефлексивных возможностей у программиста 
не было возможности определить, есть ли ожидающий <code>CATCH</code>, 
на который может быть брошен элемент управления, кроме относительно неуклюжих 
идиом, таких как следующие: 
</p>

<pre class="code"> (ignore-errors (throw 'some-tag 'some-value))
</pre>

<p>
Проблема с вышеуказанной идиомой заключается в том, что,  хотя она "обнаруживает" 
наличие или отсутствие ожидающего тега, она сохраняет только локальный контроль 
и способность рассуждать об этом знании в случае отсутствия тега. Ценой обнаружения 
существования тега является переход на этот тег.
</p>

<p>
Система условий Common Lisp добавляет ограниченную способность отражения/рефлексии 
в форме нового типа точки перехвата(catch point), называемой <b class="newterm">restart</b>
(перезапуском), о наличии или отсутствии которой можно судить без каких-либо 
попыток фактического выполнения передачи. С перезапуском также может быть связана 
описательная текстовая строка, которую пользователь-человек может показать отладчику 
для описания потенциального действия, предлагаемого перезапуском.  
</p>

<p>
Точки перезапуска, которые требуют передачи управления, но не могут 
быть установлены напрямую с помощью <code>WITH-SIMPLE-RESTART</code>. 
Например: 
</p>

<pre class="code"> (defun lisp-top-level-loop ()
   (with-simple-restart (exit "Exit from Lisp.")
     (loop
       (with-simple-restart (continue "Return to Lisp toplevel.")
         (print (eval (read)))))))
</pre>

<p>
Перезапуски(Restarts), требующие данных, также могут быть выполнены с 
использованием немного более сложного синтаксиса. Этот синтаксис не 
только учитывает программный поток данных для перезапуска, но также 
предоставляет достаточно информации для функции Common Lisp 
<code>INVOKE-RESTART-INTERACTIVELY</code>, чтобы правильно запрашивать 
любые подходящие значения, которые должны быть предоставлены для этого 
перезапуска. Например: 
</p>

<pre class="code"> (defun my-symbol-value (name)
   (if (boundp name)
       (symbol-value name)
     (restart-case (error 'unbound-variable :name name)
       (use-value (value)
         :report "Specify a value to use."
         :interactive (lambda ()
                        (format t "~&amp;Value to use: ")
                        (list (eval (read))))
         value)
       (store-value (value)
         :report "Specify a value to use and store."
         :interactive (lambda ()
                        (format t "~&amp;Value to use and store: ")
                        (list (eval (read))))
         (setf (symbol-value name) value)
         value))))
</pre>

<p>
Код, который запрашивает такие перезапуски, обычно использует 
<code>FIND-RESTART</code> для проверки доступности перезапуска, 
а затем <code>INVOKE-RESTART</code> для запуска перезапуска(restart). 
Например: 
</p>

<pre class="interaction"> (handler-bind ((unbound-variable
                  #'(lambda (c) ;argument is condition description
                      ;; Try to make unbound variables get value 17
                      (dolist (tag '(store-value use-value))
                        (let ((restart (find-restart tag c)))
                          (when restart
                            (invoke-restart restart 17)))))))
   (+ (my-symbol-value 'this-symbol-has-no-value) 
      (my-symbol-value 'pi))) ;pi DOES have a value!
 =&gt; 20.141592653589793
</pre>

<p>
При отсутствии такого обработчика перезапуск будет предлагаться отладчиком 
интерактивно, как в: 
</p>

<pre class="interaction"> (+ (my-symbol-value 'this-symbol-has-no-value) 
    (my-symbol-value 'pi))
 Error: The variable THIS-SYMBOL-HAS-NO-VALUE is unbound.
 Please select a restart option:
   1 - Specify a value to use.
   2 - Specify a value to use and store.
   3 - Return to Lisp toplevel.
   4 - Exit from Lisp.
 Option: 1
 Value to use: 19
 =&gt; 22.141592653589793
</pre>

<h3>Обработка в контексте сигнализатора(Signaler)</h3>

<p>
Ключевой возможностью, предоставляемой Common Lisp, является тот факт, 
что на самом примитивном уровне обработка может выполняться в динамическом 
контексте сигнализатора, в то время как определенная очень важная информация 
о динамическом состоянии все еще доступна, которая будет потеряна, если 
раскрутка стека произойдет раньше запуска обработчика.
</p>

<p>
Эта возможность отражается в способности оператора <code>handler-bind</code>
взять на себя управление вычислением <emph>до того</emph>, как произойдет 
какая-либо передача управления. Обратите внимание, что оператор
<code>handler-case</code> а Common Lisp, который более аналогичен средствам, 
предлагаемым в других языках, не позволяет запускать код, поставляемый 
программистом, до момента передачи управления; это полезно в некоторых 
простых ситуациях, но менее эффективно.
</p>

<p>
Рассмотрим такой фрагмент кода: 
</p>

<pre class="code"> (handler-case (main-action)
   (error (c) (other-action)))
</pre>

<p>
В этом примере выражение <code>(other-action)</code> будет выполняться 
<emph>после</emph> unwinding(раскрутки) из того места, где <code>(main-action)</code>
сигнализировало об ошибке, независимо от того, насколько глубоко в <code>main-action</code>
(основном действии) произошла сигнализация.
</p>

<p> 
Напротив, <code>handler-bind</code> берет на себя управление <emph>внутри</emph> 
динамического контекста вызова <code>SIGNAL</code> и, таким образом, может получать 
доступ к перезапускам, которые динамически происходят между вызовом <code>SIGNAL</code> 
и использованием <code>HANDLER-BIND</code>. Рассмотрим этот пример: 
</p>

<pre class="code"> (with-simple-restart (foo "Outer foo.")
   (handler-case (with-simple-restart (foo "Inner foo.")
                   (error "Lossage."))
      (error (c) (invoke-restart 'foo))))
</pre>

<p>
В приведенном выше примере будет выбран внешний перезапуск <code>FOO</code>, в отличие 
от следующего, где будет выбран внутренний перезапуск <code>FOO</code>: 
</p>

<pre class="code"> (with-simple-restart (foo "Outer foo.")
   (handler-bind ((error #'(lambda (c) (invoke-restart 'foo))))
     (with-simple-restart (foo "Inner foo.")
       (error "Lossage."))))
</pre>

<p>
Это важно, потому что при обработке ошибок обычно используются все доступные 
перезапуски, но <emph>особенно</emph> те, которые находятся в той области кода, 
которую <code>HANDLER-BIND</code> может видеть, но <code>HANDLER-CASE</code> не может. 
Рассмотрим другой пример: 
</p>

<pre class="code"> (handler-case (foo)
   (unbound-variable (c)
     (let ((r (find-restart 'use-value c))) 
       (if r (invoke-restart r nil)))))
</pre>

<p>
В приведенном выше примере не будет достигнута предполагаемая цель, 
заключающаяся в предоставлении NIL в качестве значения по умолчанию 
для любой несвязанной переменной, обнаруженной во время вызова <code>FOO</code>. 
Проблема в том, что любой перезапуск <code>USE-VALUE</code>, который, вероятно, 
будет обнаружен, также будет в рамках вызова <code>FOO</code> и больше не будет 
активен к моменту выполнения предложения <code>ERROR</code> выражения 
<code>HANDLER-CASE</code>.
</p>

<p>
Использование <code>HANDLER-BIND</code> позволяет этому примеру работать 
способом, который невозможен с <code>HANDLER-CASE</code> и его аналогами 
на других языках программирования. Рассмотрите: 
</p>

<pre class="code"> (handler-bind (error
                 #'(lambda (c)
                     (let ((r (find-restart 'use-value c))) 
                       (if r (invoke-restart r nil)))))
   (foo))
</pre>

<h3>Обработка по умолчанию</h3> 

<p>
Zetalisp содержал средство не только для asserting(утверждения) обработчиков, 
которые будут использоваться для условий, но также и дополнительное средство 
для утверждения обработчиков, которые должны временно использоваться только в 
том случае, если не были найдены нормальные обработчики. Фактически это означало, 
что существует два списка поиска, список обработчиков и список обработчиков по 
умолчанию, поиск в которых выполняется по порядку. 
</p>

<p>
При использовании NES от Zetalisp я убедился, что поиск в списке обработчиков 
по умолчанию по порядку концептуально неверен; Я чувствовал, что его(обработчик) 
нужно искать в обратном порядке. Я сообщил об этом как об ошибке, но она так и 
не была исправлена. Честно говоря, я не уверен, что тогда или, возможно, даже 
сейчас было достаточно данных, чтобы сказать, был ли я прав, хотя я по-прежнему считаю, 
что обработка по умолчанию - это то, что должно происходить снаружи вовнутрь, а не изнутри. 
Тем не менее, был ли я прав или нет, в данном контексте не так важно, как тот факт, 
что это был предмет разногласий, который в конечном итоге повлиял на разработку системы 
условий Common Lisp. Я не доверял оператору <code>condition-bind-default</code>, который 
предлагала NES, и поэтому исключил его из набора предложений, которые я перенес в 
Common Lisp.
</p>

<p>
Система условий Common Lisp действительно предоставляет способ реализовать концепцию 
обработчика по умолчанию, но это идиоматично. И, возможно, не совсем случайно, это 
имеет чистый эффект поиска обработчиков по умолчанию снаружи вовнутрь, а не изнутри, 
как я всегда считал правильным.
</p>

<p>
Механизм Zetalisp выглядел так: 
</p>

<pre class="code">(condition-bind-default ((error
                            #'(lambda (c)
                                <i>...default handling...</i>)))
  <i>...body in which handler is in effect...</i>)
</pre>

<p>
Соответствующая идиома Common Lisp выглядит так: 
</p>

<pre class="code">(handler-bind ((error
                 #'(lambda (c)
                     (signal c) ;resignal
                     <i>...default handling...</i>)))
  <i>...body in which handler is in effect...</i>)
</pre>

<p>
По сути, идиома Common Lisp продолжает процесс передачи сигналов, 
но без явной передачи управления. Если отмененное условие не обработано, 
управление вернется к этому обработчику, и будет выполнена обработка по умолчанию. 
Если, с другой стороны, некоторый внешний обработчик действительно обрабатывает условие, 
код обработки по умолчанию никогда не будет достигнут и поэтому не будет запущен.
</p>

<!--
We later note that the correct behavior of this code relies on
the presence of the "condition firewall".
-->

<h3>Объединение "Signals"(сигналов) и "Exceptions"(исключений)</h3>

<p>
В некоторых системах, таких как Unix, "signals"(сигналы) представляют собой 
асинхронный механизм, который в основном используется для реализации интерфейсов 
программирования, управляемого событиями, но обычно не используется в обычном 
синхронном программировании. 
</p>

<p>
Хотя решение проблемы прерываний или многозадачности выходит за рамки 
стандарта ANSI Common Lisp, большинство реализаций Common Lisp имеют 
конвергентный способ справиться с этими проблемами, который достаточно 
стабилен, чтобы о нем упомянуть. Подход заключался в том, чтобы отделить 
понятие "interrupting"(прерывание) от понятия "signaling"(сигнализация).
</p>

<p>
То есть в Common Lisp все сигналы синхронны. <i>Однако</i> такое 
синхронное поведение может быть полезно сочетать с прерыванием процесса 
для получения интересных эффектов.
</p>

<p>
При таком разделении прерывания процесса без сигнализации могут происходить 
по любой причине, связанной с необходимостью чтения или изменения динамического 
состояния другого процесса. Вот пример, который просто считывает динамическое 
состояние другого процесса: 
</p>

<pre class="interaction"> (defvar *my-dynamic-variable* 1)

 (let ((temporary-process
          (mp:process-run-function "temp" '()
             ;; Launch a temporary process that
             ;;  merely dynamically binds a 
             ;;  certain variable and then
             ;;  sleeps for a minute.
             #'(lambda ()
                 (let ((*my-dynamic-variable* 2)) 
                   (sleep 60)))))
       (result-value nil))
   ;; Now interrupt our temporary process 
   ;; to see the value of the variable
   (mp:process-interrupt temporary-process
     #'(lambda () 
         (setq result-value *my-dynamic-variable*)))
   ;; Now wait for the interrupt to occur
   (mp:process-wait "not yet assigned"
     #'(lambda () result-value)) ;tests for a non-null value
   ;; If we get this far, the result-value has been assigned
   ;; and can be returned.
   result-value)

 =&gt; 2
</pre>

<p>
Обратите внимание, что этот код просто проверяет динамическое состояние нашего 
временного процесса, но не вызывает никакого механизма сигнализации. И хотя процесс 
прерывания по своей сути асинхронен, действия, которые необходимо выполнить в 
прерванном процессе, синхронны.  
</p>

<p>
Если мы вместо этого переплетаем понятие прерывания процесса с сигнализацией, 
мы получаем то, что некоторые системы могут назвать "asynchronous signaling"(асинхронной
 сигнализацией), но что Common Lisp рассматривает как просто композицию двух 
ортогональных средств. Так, например, клавиатурное прерывание процесса может 
быть выполнено следующим образом: 
</p>

<pre class="code"> (define-condition keyboard-interrupt ()
   ((character :initarg :character :reader kbd-char))
   (:report (lambda (condition stream)   
              (format t "The character ~@:C was typed."
                      (kbd-char condition)))))

 (defun keyboard-interrupt (process character)
   (mp:process-interrupt process
      #'(lambda ()
          ;; Offer the process a chance to handle the condition.
          ;; If the condition is not handled, the call to SIGNAL returns
          ;; and the interrupt is completed.  Normal process execution
          ;; then continues.
          (signal 'keyboard-interrupt :character character))))
</pre>

<p>
Используя такое средство, процесс клавиатуры (сам по себе является 
синхронной деятельностью) может асинхронно прерывать другой процесс 
(предположительно, окно, выбранное в точке, где виден символьный
знак прерывания). 
</p>

<pre class="code">(defvar *selected-window* nil)

(defun keyboard-process (raw-keyboard-stream)
  (loop (let ((char (read-char raw-keyboard-stream)))
          (when *selected-window*
            (if (is-interrupt-character? char)
                (keyboard-interrupt (window-process *selected-window*)
                                    char)
                ;; otherwise...
                (add-to-input-buffer *selected-window* char))))))
</pre>

<p>
Хотя показанный здесь <code>KEYBOARD-PROCESS</code> прервет оконный процесс, 
понимание того, что происходит в этот момент, не требует каких-либо специальных 
знаний об асинхронности. Это просто требует наблюдения, что во время прерывания 
другой процесс собирался выполнить какое-то выражение <code>(exp)</code> и 
теперь будет выполняться вместо 
</p>

<pre class="code">(progn (funcall <i>interrupt-function</i>) (exp))
</pre>

<p>
Такой структурированный подход устраняет большую часть таинственности и 
непредсказуемости, обычно связанных с асинхронными прерываниями в 
других системах, где описание эффекта часто вовсе не лингвистическое, а 
имеет дело с чрезмерно конкретными терминами битов и регистров таким образом, 
что только профессиональные специалисты можно надеяться сориентироваться. 
Сообщество Common Lisp считает, что правильная концептуальная трактовка 
этих проблем делает такие возможности чем-то, что «простые смертные» могут 
безопасно и удобно использовать в своем программировании. 
</p>

<h2>Открытые вопросы</h2>

<p>
Язык Dylan по образцу системы условий Common Lisp, но внес некоторые интересные 
изменения. Мне, вероятно, не хватает соответствующего опыта и, конечно же, 
соответствующей объективности, чтобы сделать вывод о том, являются ли их 
изменения явным улучшением подходов Common Lisp. Но очевидно, что, приняв 
в некоторых местах различные решения, сообщество Dylan определило определенные 
области проектирования Common Lisp как «спорные». 
</p>

<h3>Перезапуски против обработчиков</h3>

<p>
Common Lisp предоставляет параллельные, но не связанные между собой операторы, 
такие как <code>HANDLER-BIND</code> и <code>HANDLER-CASE</code> для работы с 
обработчиками, и <code>RESTART-BIND</code> и <code>RESTART-CASE</code> для 
работы с перезапусками. Считалось, что это ортогональные операции, требующие 
несвязанного потока данных, которые на самом деле не должны были смешиваться. 
Сообщество Dylan стремилось объединить их, превратив перезапуски в своего рода 
условие и устранив для них особые формы связывания. 
</p>

<h3>"Брандмауэр условий"(Condition Firewall)</h3>

<p>
Вероятно, наиболее спорным семантическим компонентом системы условий 
Common Lisp является то, что стало называться "condition firewall"(брандмауэром 
условий). Идея, лежащая в основе брандмауэра условий, заключается в том, 
что данный обработчик должен выполняться в среде, которая не «видит» 
промежуточные обработчики, которые могли быть установлены с момента 
его создания.
</p>

<p>
Так, например, рассмотрим этот код: 
</p>

<pre class="code"> (handler-case 
     (handler-bind ((error 
                      #'(lambda (condition)
                          (declare (ignore condition)) 
                          (error 'unbound-variable :name 'fred))))
        (handler-case ;; Signal an arbitrary error:
                      (error "Not an UNBOUND-VARIABLE error.")
          (unbound-variable (c) (list 'inner c))))
   (unbound-variable (c) (list 'outer c)))
</pre>

<p>
Этот код устанавливает два обработчика для условий класса <code>UNBOUND-VARIABLE</code>, 
один вне области действия универсального обработчика для условий класса 
<code>ERROR</code>, а другой - внутри его области. В то время, когда сигнализируется 
"произвольная" ошибка, действуют оба обработчика. Это означает, что если бы 
сообщаемая ошибка была класса <code>UNBOUND-VARIABLE</code>, она была бы обнаружена 
внутренним <code>HANDLER-CASE</code> для <code>UNBOUND-VARIABLE</code>. Однако 
по мере того, как поиск обработчика продолжается вовне, проверенные обработчики 
выполняются в контексте, в котором внутренние обработчики больше не видны. 
Таким образом, приведенный выше пример дает 
</p>

<pre class="code"> (OUTER #&lt;ERROR UNBOUND-VARIABLE 12A39B87&gt;)
</pre>

<p>
Напротив, следующий код: 
</p>

<pre class="code"> (handler-case 
     (handler-bind ((error #'(lambda (condition)
                               (declare (ignore condition)) 
                               (error 'unbound-variable :name 'fred))))
       (handler-case (error 'unbound-variable :name 'marvin)
         (unbound-variable (c) (list 'inner c))))
   (unbound-variable (c) (list 'outer c)))
</pre>

<p>
yields 
</p>

<pre class="code"> (INNER #&lt;ERROR UNBOUND-VARIABLE 12A39B87&gt;)
</pre>

<p>
Интересно отметить в качестве отступления, что "resignaling trick"(трюк 
с изменением сигнала), использованный ранее при обсуждении обработки по умолчанию, 
неявно полагается на брандмауэр условий(condition firewall), чтобы избежать 
бесконечной рекурсии. Без брандмауэра условий необходим другой механизм для 
реализации обработки по умолчанию.
</p>

<p>
Разработчики языка Дилана решили исключить условный брандмауэр, возможно, 
по необходимости, поскольку наиболее полезные перезапуски почти всегда происходят 
в динамическом пространстве рядом с точкой сигнала, а обработчики обычно 
происходят дальше. Если бы обработчики могли видеть перезапуски только дальше, 
чем там где они были установлены, они не увидели бы наиболее полезных перезапусков. 
(Я лично сомневаюсь в этом аргументе и более склонен полагать, что именно поэтому 
перезапуски не должны были превращаться в своего рода условия в Дилане, 
но я могу ошибаться, и время покажет.)
</p>

<p>
Нотация Дилана во многом отличается от Common Lisp, но код, примерно 
эквивалентный <emph>обоим</emph> приведенным выше примерам, как я полагаю, вернет 
</p>

<pre class="code"> (INNER #&lt;ERROR UNBOUND-VARIABLE 12A39B87&gt;)
</pre>

<p>Отступление <br>
	Берни Гринберг, просматривая этот документ, отмечает следующее, 
	что не казалось подходящим для этого документа, но 
	я не хотел терять:
</p> 

<p>
Говоря о брандмауэрах, система условий Multics использовала «any_other» 
(обрабатывать любое условие, не названное иначе) каждый раз, когда новая 
командная оболочка помещалась в стек (скажем) из-за ошибки (часто в одном 
процессе в стеке было несколько уровней команд. ). Это помешало бы более 
ранней командной среде обрабатывать невостребованную ошибку в более поздней. 
</p>

<p>
Исключение было сделано для условия «program_interrupt», которое обычно 
использовалось для восстановления управления ранее прерванного командной 
средой. 
</p>

<p>
Также обратите внимание, что для условий, вызванных аппаратным обеспечением 
(например, ошибка деления, исключение сегментации страниц), данные условия, 
переданные signal_, включали образ состояния машины, подлежащий как проверке, 
так и изменению, которое должно было быть подтверждено системой безопасности 
при перезапуске. 
</p>

-->

<h2>Резюме</h2>

<p>
Языковые особенности не возникают спонтанно из ниоткуда. Мы рассмотрели 
некоторые из истоков Common Lisp Condition System, чтобы продемонстрировать, 
как предыдущий опыт, как хороший, так и плохой, повлиял на нынешний проект. 
И это еще не конец истории. Идеи Common Lisp оказали некоторое влияние на 
другие языки и, я надеюсь, продолжат это делать, поскольку есть ряд вещей, 
которые Common Lisp упрощает посредством своей системы условий, чего не 
делают другие языки.
</p>

<p>
Мы также убедились, что хорошая терминология важна как для спецификации 
языка программирования, так и для признания его сообществом. 

Программирование - это занятие не только техническое, но и социальное. 
Так много жизней уходит на программирование, поэтому очень важно, чтобы у нас 
была хорошая терминология, выходящая за рамки самого языка, для того, чтобы 
разговаривать друг с другом о том, что мы делаем в этом языке.
</p>

<p>
И мы рассмотрели некоторые ключевые особенности, которые отличают систему 
условий Common Lisp от систем, предлагаемых другими языками, и выделили 
некоторые открытые проблемы, ответы на которые Common Lisp на определенные 
проблемы уже столкнулись с трудностями. 
</p>

<h3><a name="footnote">Личная сноска</a></h3>

<p>
Во время разработки Common Lisp я возглавлял комитет, который занимался 
разработкой системы условий. В то время было много вопросов и сомнений по 
поводу проектирования: были ли принятые решения правильными? Были ли изучены 
все альтернативы, или есть лучшие способы, которые мы могли бы позже попробовать? 
Были ли проблемы, скрывающиеся под поверхностью, ожидающие, чтобы кого-нибудь 
укусить, когда их использовали в более тяжелых условиях? 
</p>

<p>
Дело не в том, что люди сомневались в компетентности нашего комитета, 
а скорее в том, что многим потенциальным рецензентам не хватало соответствующего 
опыта для критического анализа наших предложений. Тем не менее, проект 
казался мне в основном правильным, и меня больше беспокоило то, что, если мы 
в какой-то момент не представим его сообществу пользователей, чтобы попробовать, 
мы вернемся к той же таблице проектирования через несколько лет с тем же самым 
вопросом и тем же отсутствием опыта в сообществе, чтобы на них ответить. 
Казалось, что для того, чтобы двигаться вперед, требовался прыжок веры. Итак, 
я и мой комитет кивнули нашим коллективным головам и сказали, что мы поддерживаем проект. 
Лично у меня были некоторые сомнения по поводу некоторых деталей, но я счел 
контрпродуктивным поднимать их, потому что я считал, что риск не попробовать эти 
вещи выше, чем риск попробовать их.
</p>

<p>
По моему опыту, большая часть языкового проекта похожа на это. Мы <i>думаем</i>, 
что знаем, чем все это закончится, но не всегда. Паттерны использования часто 
удивительны, поскольку человек узнает, достаточно ли он существует, чтобы 
разработать язык или два, а затем наблюдать, как ожидания разыгрываются в 
действительности в течение многих лет. Так что это авантюра. Но единственный 
способ не играть в азартные игры - не двигаться вперед. 
</p>

<p>
Однажды я увидел по телевидению интервью с дизайнером шрифтов из Bitstream Inc. 
о том, как он концептуализирует процесс дизайна шрифтов. «Речь идет не о разработке 
формы букв, - пояснил он, к моему первоначальному удивлению. Затем он объяснил, 
что на самом деле, дело в форме слов. Формы шрифта играют в этом роль, но сами 
по себе не являются конечной целью. Разработка языков программирования тоже похожа. 
Дело не в семантике отдельных операторов, а в том, как эти операторы сочетаются друг 
с другом для формирования предложений(высказываний) в программах.

</p>

<p>
В отличие от ситуации со шрифтами, когда целые книги можно мгновенно просматривать 
с новым шрифтом, чтобы увидеть, как работает дизайн, мы не знаем заранее, 
какие предложения будут составлены на языке программирования. Мы должны подождать 
и посмотреть, что люди предпочитают писать. Common Lisp сделал шаг вперед, и, 
хотя мы можем бесконечно спорить о правильности того или иного проектного решения, 
единственное проектное решение, которое, я уверен, было правильным, заключалось в том, 
чтобы предложить сообществу богатый набор возможностей, которые дадут им возможность 
не только писать программы, но также иметь долю в будущих проектах. Никогда больше 
я не буду бояться послать электронное письмо группе разработчиков с просьбой дать совет
о семантике <code>HANDLER-BIND</code> и обнаружить, что ни у кого нет мнения! 
Для меня такой прогресс, развитие понимания всего сообщества - лучший из всех 
видов прогресса. 
</p>

<h2>Благодарности</h2>

<p>
I would like to thank Keith Corbett, Christophe Dony,
Bernard Greenberg, and Erik Naggum for 
reviewing drafts of this text.  Any lingering errors after they got done 
looking at it are still my responsibility, but I'm quite sure the 
editorial, technical, and historical quality of this text was improved
measurably through their helpful scrutiny.
</p>

<h2>Bibliography</h2>

<dl>

<dt><a name="multicians-2000">[Multicians 2000]</a></dt>
<dd>Historical references to Multics can probably best be obtained from<br>
<a href="http://www.multicians.org/"><tt class="urlref">http://www.multicians.org/</tt></a>

</dd><dt><a name="pitman-1983">[Pitman 1983]</a></dt>
<dd>Kent M. Pitman, <i>The Revised Maclisp Manual</i>,
Technical Report 295, MIT Laboratory for Computer Science,
Cambridge, MA, May 1983.
</dd>

<dt><a name="pitman-1990">[Pitman 1990]</a></dt>
<dd>Kent M. Pitman, "Exceptional Situations in Lisp",
proceedings for the
First European Conference on the Practical Application of Lisp (EUROPAL'90),
Churchill College, Cambridge, UK, March 27-29, 1990.<br>
<a href="http://www.nhplace.com/kent/Papers/Exceptional-Situations-1990.html"><tt class="urlref">http://www.nhplace.com/kent/Papers/Exceptional-Situations-1990.html</tt></a>
</dd>

<dt><a name="smith-1982">[Smith 1982]</a></dt>
<dd>B.C. Smith, <i>Reflection and Semantics in a Procedural Language</i>,
Technical Report 272, MIT Laboratory for Computer Science,
Cambridge, MA, January 1982.
<!-- 
It appears that this should be available at
ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-272.ps.gz 
however it's missing.
-->
</dd>

<dt><a name="x3j13-1994">[X3J13 1994]</a></dt>
<dd><i>American National Standard for Information Systems--Programming Language--Common Lisp</i> (X3.226-1994)<br>
<a href="http://www.lispworks.com/documentation/HyperSpec/Front/"><font color="green"><tt class="urlref">http://www.lispworks.com/documentation/HyperSpec/Front/</tt></font></a>
</dd>

<dt><a name="weinreb-1981">[Weinreb 1983]</a></dt>
<dd>D.L. Weinreb and D.A. Moon, <i>Lisp Machine Manual</i>,
MIT Artificial Intelligence Laboratory, Cambridge, MA, July 1981. 
</dd>

</dl>

<hr>

<font color="green">

<p><a name="COPYRIGHT">
Original printed text document<br>
<b>Copyright 2001 by Kent M. Pitman. All Rights Reserved.</b>
</a></p>

<p>
HTML hypertext version of document<br>
<b>Copyright 2002, Kent M. Pitman.  All rights reserved.</b><br>
The following limited, non-exclusive, 
revokable licenses are granted:
</p>

<blockquote>

<p>
Browsing of this document (that is, transmission and display of a temporary
copy of this document for the ordinary purpose of direct viewing by a 
human being in the usual manner that hypertext browsers permit such
viewing) is expressly permitted, provided that no recopying, 
redistribution, redisplay, or retransmission is made of any such copy.
</p>

<p>
Bookmarking of this document (that is, recording only the document's title and 
Uniform Resource Locator, or URL, but not its content,
for the purpose of remembering an association between the document's title
and the URL, and/or for the purpose of making a subsequent request 
for a fresh copy of the content named by that URL)
is also expressly permitted.
</p>

</blockquote>

<p>
All other uses require negotiated permission.
</p>

</font>

<hr>

<p align="center">
<a href="http://www.nhplace.com/kent/Papers/index.html"><i>Click here for an index 
of other titles by Kent Pitman.</i></a>
</p>

</body></html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>from-md: process</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">from-md
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">process </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
 <h2>title: Потоки/нити(Threads) </h2>
<p><a class="anchor" id="intro"></a></p>
<h2>Вступление</h2>
<p>Под <em>threads</em>(потоками) мы подразумеваем отдельные нити выполнения в одном процессе Lisp, совместно использующие одно и то же адресное пространство. Как правило, выполнение автоматически переключается между этими нитями системой (либо ядром lisp, либо операционной системой), так что кажется, что задачи выполняются параллельно (асинхронно). На этой странице обсуждается создание потоков и управление ими, а также некоторые аспекты взаимодействия между ними. Для получения информации о взаимодействии между lisp и другими процессами см. <a href="os.html">Взаимодействие с вашей ОС</a>.</p>
<p>Моментальная ловушка для неосторожных людей заключается в том, что большинство реализаций ссылаются (в номенклатуре) на потоки как на <em>processes</em> (процессы)</p><ul>
<li>это историческая особенность языка, который существует гораздо дольше, чем термин <em>thread</em> (поток). Если хотите, назовите эту зрелость признаком стабильных реализаций.</li>
</ul>
<p>В стандарте ANSI Common Lisp эта тема не упоминается. Мы представим здесь переносимую библиотеку <a href="https://github.com/sionescu/bordeaux-threads">bordeaux-threads</a>, пример реализации через потоки SBCL - <a href="http://www.sbcl.org/manual/#Threading">SBCL threads</a> из Руководства по SBCL - <a href="http://www.sbcl.org/manual/">SBCL Manual</a> и библиотеку <a href="https://lparallel.org">lparallel</a>.</p>
<p>Bordeaux-thread - это де-факто стандартная переносимая библиотека, которая предоставляет довольно низкоуровневые примитивы. Lparallel основывается на нем и имеет следующие особенности:</p>
<ul>
<li>простая модель подчиненной задачи с очередью приема</li>
<li>конструкции для выражения мелкозернистого параллелизма</li>
<li><b>асинхронная обработка условий</b> через границы потоков</li>
<li><b>параллельные версии map, reduce, sort, remove</b> и многие другие</li>
<li><b>promises</b>(обещания), futures(будущее) и конструкции отложенного выполнения</li>
<li>деревья вычислений для распараллеливания взаимосвязанных задач</li>
<li>ограниченные и неограниченные очереди - <b>queues</b> FIFO</li>
<li>каналы - <b>channels</b></li>
<li>задачи с высоким и низким приоритетом</li>
<li>убийство задач по категориям</li>
<li>интегрированные таймауты</li>
</ul>
<p>Дополнительные библиотеки по параллелизму и concurrency(одновременности) см. В <a href="https://github.com/CodyReichert/awesome-cl#parallelism-and-concurrency">Awesome CL list</a>, и <a href="http://quickdocs.org/">Quickdocs</a> таких как quickdocks о <a href="https://quickdocs.org/-/search?q=thread">thread</a> и <a href="https://quickdocs.org/-/search?q=concurrency">concurrency</a>.</p>
<p><a class="anchor" id="why_bother"></a></p>
<h3>Зачем возиться?</h3>
<p>Первый вопрос, который нужно решить: зачем возиться с потоками? Иногда ваш ответ будет заключаться в том, что ваше приложение настолько прямолинейно, что вам вообще не нужно беспокоиться о потоках. Но во многих других случаях трудно представить, как можно написать сложное приложение без многопоточности. Например:</p>
<ul>
<li>вы можете писать сервер, который должен иметь возможность отвечать более чем одному пользователю / соединению одновременно (например, веб-сервер) на странице сокетов);</li>
<li>вы можете захотеть выполнить некоторую фоновую активность, не останавливая при этом основное приложение;</li>
<li>вы можете захотеть, чтобы ваше приложение получало уведомление по истечении определенного времени;</li>
<li>вы можете захотеть оставить приложение работающим и активным, пока не станет доступен какой-либо системный ресурс;</li>
<li>вам может потребоваться взаимодействие с какой-либо другой системой, которая требует многопоточности (например, "windows" под Windows, которые обычно работают в своих собственных потоках);</li>
<li>вы можете захотеть связать разные контексты (например, разные динамические привязки) с разными частями приложения;</li>
<li>у вас может даже возникнуть простая потребность сделать две вещи одновременно.</li>
</ul>
<p><a class="anchor" id="emergency"></a></p>
<h3>Что такое одновременность(Concurrency)? Что такое параллелизм?</h3>
<p><em>Credit: The following was first written on <a href="https://z0ltan.wordpress.com/2016/09/02/basic-concurrency-and-parallelism-in-common-lisp-part-3-concurrency-using-bordeaux-and-sbcl-threads/">z0ltan.wordpress.com</a> by Timmy Jose.</em></p>
<p>Одновременность(Concurrency) - это способ одновременного выполнения различных, возможно связанных задач. Это означает, что даже на однопроцессорной машине вы можете моделировать одновременность, используя потоки (например) и переключая их контекст.</p>
<p>В случае системных (родных ОС) потоков планирование и переключение контекста в конечном итоге определяется ОС. Так обстоит дело с потоками Java и потоками Common Lisp.</p>
<p>В случае “green/зеленых” потоков, то есть потоков, полностью управляемых программой, планирование может полностью контролироваться самой программой. Erlang - отличный пример такого подхода.</p>
<p>Так в чем же разница между одновременностью и параллелизмом? Параллелизм обычно определяется в очень строгом смысле как означающий, что независимые задачи выполняются параллельно, одновременно, на разных процессорах или на разных ядрах. В этом узком смысле параллелизма на одноядерной однопроцессорной машине быть не может.</p>
<p>Это скорее помогает различать эти две взаимосвязанные концепции на более абстрактном уровне - одновременность в первую очередь имеет дело с созданием иллюзии одновременности для клиентов, чтобы система не казалась заблокированной, когда выполняется длительная операция. Системы с графическим интерфейсом - прекрасный пример такого рода систем. Следовательно, одновременность связана с обеспечением хорошего взаимодействия с пользователем и не обязательно связана с повышением производительности.</p>
<p>Набор инструментов Java Swing и JavaScript являются однопоточными, и все же они могут создавать впечатление одновременности из-за скрытого переключения контекста. Конечно, в большинстве случаев параллелизм реализуется с использованием нескольких потоков / процессов.</p>
<p>С другой стороны, параллелизм в основном связан с чистым увеличением производительности. Например, если нам дается задача найти квадраты всех четных чисел в заданном диапазоне, мы могли бы разделить диапазон на фрагменты, которые затем запускались параллельно на разных ядрах или разных процессорах, а затем результаты можно было сопоставить вместе, чтобы сформировать окончательный результат. Это пример Map-Reduce в действии.</p>
<p>Итак, теперь, когда мы отделили абстрактное значение одновременности от параллелизма, мы можем немного поговорить о реальном механизме, используемом для их реализации. Именно здесь у многих возникает большая путаница. Они склонны связывать абстрактные концепции с конкретными средствами их реализации. По сути, обе абстрактные концепции могут быть реализованы с использованием одних и тех же механизмов! Например, мы можем реализовать одновременные функции и параллельные функции, используя один и тот же базовый механизм потоков в Java. Только концептуальное переплетение или независимость задач на абстрактном уровне имеет значение для нас.</p>
<p>Например, если у нас есть задача, в которой часть работы может быть выполнена в другом потоке (возможно, на другом ядре / процессоре), но поток, который порождает этот поток, логически зависит от результатов порожденного потока (и как таковой должен join/присоединиться к этому потоку), это все еще одновременность!</p>
<p>Итак, суть в следующем: одновременность и параллелизм - это разные концепции, но их реализации могут выполняться с использованием одних и тех же механизмов</p><ul>
<li>потоков, процессов и т.Д.</li>
</ul>
<h2>Потоки Bordeaux</h2>
<p>Библиотека Bordeaux предоставляет независимый от платформы способ обработки базовых потоков в нескольких реализациях Common Lisp. Интересно то, что она сама по себе не создает никаких собственных потоков - для этого она полностью полагается на базовую реализацию.</p>
<p>С другой стороны, он предоставляет некоторые полезные дополнительные функциональности в своих собственных абстракциях над потоками нижнего уровня.</p>
<p>Кроме того, вы можете видеть из демонстрационных программ, что многие функции Bordeaux кажутся очень похожими на те, которые используются в SBCL. Не думаю, что это совпадение.</p>
<p>Вы можете обратиться к документации для получения более подробной информации (см. Раздел «Подведение итогов»).</p>
<h3>Установка потоков Bordeaux</h3>
<p>Сначала загрузим библиотеку Bordeaux с помощью Quicklisp:</p>
<div class="fragment"><div class="line">CL-USER&gt; (ql:quickload &quot;bt-semaphore&quot;)</div><div class="line">To load &quot;bt-semaphore&quot;:</div><div class="line">  Load 1 ASDF system:</div><div class="line">    bt-semaphore</div><div class="line">; Loading &quot;bt-semaphore&quot;</div><div class="line"></div><div class="line">(:BT-SEMAPHORE)</div></div><!-- fragment --><h3>Проверка поддержки потоков в Common Lisp</h3>
<p>Независимо от реализации Common Lisp существует стандартный способ проверить доступность поддержки потоков:</p>
<div class="fragment"><div class="line">CL-USER&gt; (member :thread-support *FEATURES*)</div><div class="line">(:THREAD-SUPPORT :SWANK :QUICKLISP :ASDF-PACKAGE-SYSTEM :ASDF3.1 :ASDF3 :ASDF2</div><div class="line"> :ASDF :OS-MACOSX :OS-UNIX :NON-BASE-CHARS-EXIST-P :ASDF-UNICODE :64-BIT</div><div class="line"> :64-BIT-REGISTERS :ALIEN-CALLBACKS :ANSI-CL :ASH-RIGHT-VOPS :BSD</div><div class="line"> :C-STACK-IS-CONTROL-STACK :COMMON-LISP :COMPARE-AND-SWAP-VOPS</div><div class="line"> :COMPLEX-FLOAT-VOPS :CYCLE-COUNTER :DARWIN :DARWIN9-OR-BETTER :FLOAT-EQL-VOPS</div><div class="line"> :FP-AND-PC-STANDARD-SAVE :GENCGC :IEEE-FLOATING-POINT :INLINE-CONSTANTS</div><div class="line"> :INODE64 :INTEGER-EQL-VOP :LINKAGE-TABLE :LITTLE-ENDIAN</div><div class="line"> :MACH-EXCEPTION-HANDLER :MACH-O :MEMORY-BARRIER-VOPS :MULTIPLY-HIGH-VOPS</div><div class="line"> :OS-PROVIDES-BLKSIZE-T :OS-PROVIDES-DLADDR :OS-PROVIDES-DLOPEN</div><div class="line"> :OS-PROVIDES-PUTWC :OS-PROVIDES-SUSECONDS-T :PACKAGE-LOCAL-NICKNAMES</div><div class="line"> :PRECISE-ARG-COUNT-ERROR :RAW-INSTANCE-INIT-VOPS :SB-DOC :SB-EVAL :SB-LDB</div><div class="line"> :SB-PACKAGE-LOCKS :SB-SIMD-PACK :SB-SOURCE-LOCATIONS :SB-TEST :SB-THREAD</div><div class="line"> :SB-UNICODE :SBCL :STACK-ALLOCATABLE-CLOSURES :STACK-ALLOCATABLE-FIXED-OBJECTS</div><div class="line"> :STACK-ALLOCATABLE-LISTS :STACK-ALLOCATABLE-VECTORS</div><div class="line"> :STACK-GROWS-DOWNWARD-NOT-UPWARD :SYMBOL-INFO-VOPS :UD2-BREAKPOINTS :UNIX</div><div class="line"> :UNWIND-TO-FRAME-AND-CALL-VOP :X86-64)</div></div><!-- fragment --><p>Если бы не было поддержки потока, в качестве значения выражения было бы показано “NIL”.</p>
<p>В зависимости от конкретной используемой библиотеки у нас также могут быть разные способы проверки поддержки одновременности(concurrency), которые могут использоваться вместо общей проверки, упомянутой выше.</p>
<p>Например, в нашем случае мы заинтересованы в использовании библиотеки Bordeaux. Чтобы проверить, есть ли поддержка потоков, использующих эту библиотеку, мы можем увидеть, установлено ли для глобальной переменной <em>supports-threads-p</em> значение NIL (нет поддержки) или T (поддержка доступна):</p>
<div class="fragment"><div class="line">CL-USER&gt; bt:*supports-threads-p*</div><div class="line">T</div></div><!-- fragment --><p>Хорошо, теперь, когда мы разобрались с этим, давайте протестируем как платформо-независимую библиотеку (Bordeaux), так и поддержку конкретной платформы (в данном случае SBCL).</p>
<p>Для этого давайте рассмотрим несколько простых примеров:</p>
<ul>
<li>Основа - перечислить текущий поток, перечислить все потоки, получить имя потока</li>
<li>Обновить глобальную переменную из потока</li>
<li>Распечатать сообщение на верхнем уровне с используя поток</li>
<li>Печатать сообщение на верхнем уровне - исправлено</li>
<li>Распечатать сообщение на верхнем уровне - лучшее</li>
<li>Изменять общий ресурс из нескольких потоков</li>
<li>Изменение общего ресурса из нескольких потоков - с помощью блокировок исправлено</li>
<li>Изменить общий ресурс из нескольких потоков - используя атомарные операции</li>
<li>Присоединение к потоку, уничтожение примера потока</li>
</ul>
<h3>Основы - перечислить текущий поток, перечислить все потоки, получить имя потока</h3>
<div class="fragment"><div class="line">;;; Print the current thread, all the threads, and the current thread&#39;s name</div><div class="line">(defun print-thread-info ()</div><div class="line">  (let* ((curr-thread (bt:current-thread))</div><div class="line">         (curr-thread-name (bt:thread-name curr-thread))</div><div class="line">         (all-threads (bt:all-threads)))</div><div class="line">    (format t &quot;Current thread: ~a~%~%&quot; curr-thread)</div><div class="line">    (format t &quot;Current thread name: ~a~%~%&quot; curr-thread-name)</div><div class="line">    (format t &quot;All threads:~% ~{~a~%~}~%&quot; all-threads))</div><div class="line">  nil)</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">CL-USER&gt; (print-thread-info)</div><div class="line">Current thread: #&lt;THREAD &quot;repl-thread&quot; RUNNING {10043B8003}&gt;</div><div class="line"></div><div class="line">Current thread name: repl-thread</div><div class="line"></div><div class="line">All threads:</div><div class="line"> #&lt;THREAD &quot;repl-thread&quot; RUNNING {10043B8003}&gt;</div><div class="line">#&lt;THREAD &quot;auto-flush-thread&quot; RUNNING {10043B7DA3}&gt;</div><div class="line">#&lt;THREAD &quot;swank-indentation-cache-thread&quot; waiting on: #&lt;WAITQUEUE  {1003A28103}&gt; {1003A201A3}&gt;</div><div class="line">#&lt;THREAD &quot;reader-thread&quot; RUNNING {1003A20063}&gt;</div><div class="line">#&lt;THREAD &quot;control-thread&quot; waiting on: #&lt;WAITQUEUE  {1003A19E53}&gt; {1003A18C83}&gt;</div><div class="line">#&lt;THREAD &quot;Swank Sentinel&quot; waiting on: #&lt;WAITQUEUE  {1003790043}&gt; {1003788023}&gt;</div><div class="line">#&lt;THREAD &quot;main thread&quot; RUNNING {1002991CE3}&gt;</div><div class="line"></div><div class="line">NIL</div></div><!-- fragment --><p>Обновите глобальную переменную из потока:</p>
<div class="fragment"><div class="line">(defparameter *counter* 0)</div><div class="line"></div><div class="line">(defun test-update-global-variable ()</div><div class="line">  (bt:make-thread</div><div class="line">   (lambda ()</div><div class="line">     (sleep 1)</div><div class="line">     (incf *counter*)))</div><div class="line">  *counter*)</div></div><!-- fragment --><p>Мы создаем новый поток, используя <code>bt:make-thread</code>, которая принимает в качестве параметра лямбда-абстракцию. Обратите внимание, что эта лямбда-абстракция не может принимать никаких параметров.</p>
<p>Еще один момент, который следует отметить, заключается в том, что в отличие от некоторых других языков (например, Java), нет разделения между созданием объекта потока и его запуском. В этом случае, как только поток создается, он сразу начинает выполнятся.</p>
<p>Вывод:</p>
<div class="fragment"><div class="line">CL-USER&gt; (test-update-global-variable)</div><div class="line"></div><div class="line">0</div><div class="line">CL-USER&gt; *counter*</div><div class="line">1</div></div><!-- fragment --><p>Как мы видим, поскольку основной поток вернулся немедленно, начальное значение <em>counter</em> равно 0, а примерно через секунду оно обновляется до 1 анонимным потоком.</p>
<h3>Создать поток: распечатывающий сообщение на верхнем уровне</h3>
<div class="fragment"><div class="line">;;; Print a message onto the top-level using a thread</div><div class="line">(defun print-message-top-level-wrong ()</div><div class="line">  (bt:make-thread</div><div class="line">   (lambda ()</div><div class="line">     (format *standard-output* &quot;Hello from thread!&quot;))</div><div class="line">   :name &quot;hello&quot;)</div><div class="line">  nil)</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">CL-USER&gt; (print-message-top-level-wrong)</div><div class="line">NIL</div></div><!-- fragment --><p>Так что же пошло не так? Проблема в привязке переменных. Теперь параметр ’t’ функции форматирования относится к верхнему уровню, который является термином Common Lisp для основного консольного потока, также на который ссылается глобальная переменная <code>*standard-output*</code>. Таким образом, мы могли ожидать, что вывод будет отображаться на главном экране консоли.</p>
<p>Тот же код работал бы нормально, если бы мы не запускали его в отдельном потоке. Что происходит, так это то, что каждый поток имеет свой собственный стек, в котором происходит повторное связывание переменных. В этом случае даже для <code>*standard-output*</code>, который является глобальной переменной, которая, как мы предполагаем, должна быть доступна для всех потоков, происходит пересвязывание внутри каждого потока! Это похоже на концепцию хранилища ThreadLocal в Java. Распечатать сообщение на верхнем уровне - исправлено:</p>
<p>Итак, как нам исправить проблему из предыдущего примера? Конечно, путем привязки верхнего уровня во время создания потока. На помощь приходит чистая лексическая область видимости!</p>
<div class="fragment"><div class="line">;;; Print a message onto the top-level using a thread â fixed</div><div class="line">(defun print-message-top-level-fixed ()</div><div class="line">  (let ((top-level *standard-output*))</div><div class="line">    (bt:make-thread</div><div class="line">     (lambda ()</div><div class="line">       (format top-level &quot;Hello from thread!&quot;))</div><div class="line">     :name &quot;hello&quot;)))</div><div class="line">  nil)</div></div><!-- fragment --><p>Которая производит:</p>
<div class="fragment"><div class="line">CL-USER&gt; (print-message-top-level-fixed)</div><div class="line">Hello from thread!</div><div class="line">NIL</div></div><!-- fragment --><p>Уф! Однако есть еще один способ получить тот же результат с использованием очень интересного макроса для чтения, как мы увидим дальше.</p>
<h3>Распечатать сообщение на верхнем уровне - вычислением макроса во время чтения</h3>
<p>Давайте сначала посмотрим на код:</p>
<div class="fragment"><div class="line">;;; Print a message onto the top-level using a thread - reader macro</div><div class="line"></div><div class="line">(eval-when (:compile-toplevel)</div><div class="line">  (defun print-message-top-level-reader-macro ()</div><div class="line">    (bt:make-thread</div><div class="line">     (lambda ()</div><div class="line">       (format #.*standard-output* &quot;Hello from thread!&quot;)))</div><div class="line">    nil))</div><div class="line"></div><div class="line">(print-message-top-level-reader-macro)</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">CL-USER&gt; (print-message-top-level-reader-macro)</div><div class="line">Hello from thread!</div><div class="line">NIL</div></div><!-- fragment --><p>Итак, это работает, но в чем дело с eval-when и что это за странный символ #. перед <code>*standard-output*</code>?</p>
<p>eval-when контролирует, когда происходит вычисление выражений Лиспа. У нас может быть три цели - :compile-toplevel, :load-toplevel и :execute.</p>
<p>символ <code>#.</code> - это то, что называется “макросом чтения“. Макрос чтения (или читатель) называется так, потому что он имеет особое значение для Считывателя(Reader) Common Lisp, который является компонентом, который отвечает за чтение выражений в Common Lisp и извлечение из них смысла. Этот конкретный макрос чтения гарантирует, что привязка <code>*standard-output*</code> выполняется во время чтения.</p>
<p>Связывание значения во время чтения гарантирует, что исходное значение <code>*standard-output*</code> сохраняется при запуске потока, а вывод отображается на правильном верхнем уровне.</p>
<p>Теперь в игру вступает eval-when. Оборачивая все определение функции внутри eval-when и обеспечивая выполнение вычисления во время компиляции, привязывается правильное значение <code>*standard-output*</code>. Если бы мы пропустили eval-when, то увидели бы следующую ошибку:</p>
<div class="fragment"><div class="line">  error:</div><div class="line">    don&#39;t know how to dump #&lt;SWANK/GRAY::SLIME-OUTPUT-STREAM {100439EEA3}&gt; (default MAKE-LOAD-FORM method called).</div><div class="line">    ==&gt;</div><div class="line">      #&lt;SWANK/GRAY::SLIME-OUTPUT-STREAM {100439EEA3}&gt;</div><div class="line"></div><div class="line">  note: The first argument never returns a value. </div><div class="line">  note:</div><div class="line">    deleting unreachable code</div><div class="line">    ==&gt;</div><div class="line">      &quot;Hello from thread!&quot;</div><div class="line"></div><div class="line">Compilation failed.</div></div><!-- fragment --><p>И это имеет смысл, потому что SBCL не может понять, что возвращает этот выходной поток, поскольку это поток, а не определенное значение (чего ожидает функция «format»). Поэтому мы видим ошибку «недостижимый код».</p>
<p>Обратите внимание, что если бы тот же код был запущен непосредственно в REPL, не было бы проблем, поскольку разрешение всех символов было бы выполнено правильно потоком REPL.</p>
<h3>Изменить общий ресурс из нескольких потоков</h3>
<p>Предположим, у нас есть следующая настройка с минимальным классом bank-account(банковского счета) (без проверки ошибок):</p>
<div class="fragment"><div class="line">;;; Modify a shared resource from multiple threads</div><div class="line"></div><div class="line">(defclass bank-account ()</div><div class="line">  ((id :initarg :id</div><div class="line">       :initform (error &quot;id required&quot;)</div><div class="line">       :accessor :id)</div><div class="line">   (name :initarg :name</div><div class="line">         :initform (error &quot;name required&quot;)</div><div class="line">         :accessor :name)</div><div class="line">   (balance :initarg :balance</div><div class="line">            :initform 0</div><div class="line">            :accessor :balance)))</div><div class="line"></div><div class="line">(defgeneric deposit (account amount)</div><div class="line">  (:documentation &quot;Deposit money into the account&quot;))</div><div class="line"></div><div class="line">(defgeneric withdraw (account amount)</div><div class="line">  (:documentation &quot;Withdraw amount from account&quot;))</div><div class="line"></div><div class="line">(defmethod deposit ((account bank-account) (amount real))</div><div class="line">  (incf (:balance account) amount))</div><div class="line"></div><div class="line">(defmethod withdraw ((account bank-account) (amount real))</div><div class="line">  (decf (:balance account) amount))</div></div><!-- fragment --><p>И у нас есть простой клиент, который явно не верит ни в какие формы синхронизации:</p>
<div class="fragment"><div class="line">(defparameter *rich*</div><div class="line">  (make-instance &#39;bank-account</div><div class="line">                 :id 1</div><div class="line">                 :name &quot;Rich&quot;</div><div class="line">                 :balance 0))</div><div class="line">; compiling (DEFPARAMETER *RICH* ...)</div><div class="line"></div><div class="line">(defun demo-race-condition ()</div><div class="line">  (loop repeat 100</div><div class="line">     do</div><div class="line">       (bt:make-thread</div><div class="line">        (lambda ()</div><div class="line">          (loop repeat 10000 do (deposit *rich* 100))</div><div class="line">          (loop repeat 10000 do (withdraw *rich* 100))))))</div></div><!-- fragment --><p>Это все, что мы делаем - создаем новый экземпляр банковского счета (balance 0), а затем создаем 100 потоков, каждый из которых просто вносит сумму 100 10000 раз, а затем снимает ту же сумму такое же количество раз. Итак, конечный результат должен быть таким же, как и начальный баланс, который равен 0, верно? Давай проверим и посмотрим.</p>
<p>При пробном запуске мы можем получить следующие результаты:</p>
<div class="fragment"><div class="line">CL-USER&gt; (:balance *rich*)</div><div class="line">0</div><div class="line">CL-USER&gt; (dotimes (i 5)</div><div class="line">           (demo-race-condition))</div><div class="line">NIL</div><div class="line">CL-USER&gt; (:balance *rich*)</div><div class="line">22844600</div></div><!-- fragment --><p>Ого! Причина этого несоответствия в том, что incf и decf не являются атомарными операциями - они состоят из нескольких подопераций, и порядок, в котором они выполняются, не находится под нашим контролем.</p>
<p>Это то, что называется “состоянием состязания/гонки“ - несколько потоков конкурируют за один и тот же общий ресурс, по крайней мере, с одним модифицирующим потоком, который, скорее всего, считывает неправильное значение объекта при его изменении. Как это исправить? Один из простых способов - использовать блокировки (мьютекс в этом случае, и может быть семафором для более сложных ситуаций).</p>
<h3>Изменение общего ресурса из нескольких потоков - исправлено с помощью блокировок</h3>
<p>Давайте сначала вернем баланс аккаунта в 0:</p>
<div class="fragment"><div class="line">CL-USER&gt; (setf (:balance *rich*) 0)</div><div class="line">0</div><div class="line">CL-USER&gt; (:balance *rich*)</div><div class="line">0</div></div><!-- fragment --><p>Теперь давайте изменим функцию demo-race-condition для доступа к общему ресурсу с помощью блокировок (созданных с помощью bt:make-lock и используемых, как показано):</p>
<div class="fragment"><div class="line">(defvar *lock* (bt:make-lock))</div><div class="line">; compiling (DEFVAR *LOCK* â¦)</div><div class="line"></div><div class="line">(defun demo-race-condition-locks ()</div><div class="line">  (loop repeat 100</div><div class="line">     do</div><div class="line">       (bt:make-thread</div><div class="line">        (lambda ()</div><div class="line">          (loop repeat 10000 do (bt:with-lock-held (*lock*)</div><div class="line">                                  (deposit *rich* 100)))</div><div class="line">          (loop repeat 10000 do (bt:with-lock-held (*lock*)</div><div class="line">                                  (withdraw *rich* 100)))))))</div><div class="line">; compiling (DEFUN DEMO-RACE-CONDITION-LOCKS ...)</div></div><!-- fragment --><p>И давайте на этот раз выполним более крупный прогон:</p>
<div class="fragment"><div class="line">CL-USER&gt; (dotimes (i 100)</div><div class="line">           (demo-race-condition-locks))</div><div class="line">NIL</div><div class="line">CL-USER&gt; (:balance *rich*)</div><div class="line">0</div></div><!-- fragment --><p>Превосходно! Теперь это лучше. Конечно, нужно помнить, что использование такого мьютекса обязательно повлияет на производительность. В некоторых случаях есть лучший способ - использовать атомарные операции, когда это возможно. Мы поговорим об этом позже.</p>
<h3>Измените общий ресурс из нескольких потоков - используя атомарные операции</h3>
<p>Атомарные операции - это операции, выполнение которых системой гарантируется внутри концептуальной транзакции, то есть все подоперации основной операции выполняются вместе без какого-либо вмешательства извне. Операция проходит полностью или полностью не выполняется. Нет золотой середины и нет противоречивого состояния.</p>
<p>Еще одно преимущество состоит в том, что производительность намного превосходит использование блокировок для защиты доступа к общему состоянию. Мы увидим эту разницу в реальном демонстрационном запуске.</p>
<p>Библиотека Bordeaux не обеспечивает реальной поддержки атомарности, поэтому нам придется полагаться на конкретную поддержку реализации для этого. В нашем случае это SBCL, поэтому нам придется отложить эту демонстрацию до раздела SBCL.</p>
<h3>Присоединение к потоку, уничтожение потока</h3>
<p>Чтобы присоединиться к потоку, мы используем функцию <code>bt:join-thread</code>, а для уничтожения потока (не рекомендуемая операция) мы можем использовать функцию <code>bt:destroy-thread</code>.</p>
<p>Простая демонстрация:</p>
<div class="fragment"><div class="line">(defmacro until (condition &amp;body body)</div><div class="line">  (let ((block-name (gensym)))</div><div class="line">    `(block ,block-name</div><div class="line">       (loop</div><div class="line">           (if ,condition</div><div class="line">               (return-from ,block-name nil)</div><div class="line">               (progn</div><div class="line">                   ,@body))))))</div><div class="line"></div><div class="line">(defun join-destroy-thread ()</div><div class="line">  (let* ((s *standard-output*)</div><div class="line">        (joiner-thread (bt:make-thread</div><div class="line">                        (lambda ()</div><div class="line">                          (loop for i from 1 to 10</div><div class="line">                             do</div><div class="line">                               (format s &quot;~%[Joiner Thread]  Working...&quot;)</div><div class="line">                               (sleep (* 0.01 (random 100)))))))</div><div class="line">        (destroyer-thread (bt:make-thread</div><div class="line">                           (lambda ()</div><div class="line">                             (loop for i from 1 to 1000000</div><div class="line">                                do</div><div class="line">                                  (format s &quot;~%[Destroyer Thread] Working...&quot;)</div><div class="line">                                  (sleep (* 0.01 (random 10000))))))))</div><div class="line">    (format t &quot;~%[Main Thread] Waiting on joiner thread...&quot;)</div><div class="line">    (bt:join-thread joiner-thread)</div><div class="line">    (format t &quot;~%[Main Thread] Done waiting on joiner thread&quot;)</div><div class="line">    (if (bt:thread-alive-p destroyer-thread)</div><div class="line">        (progn</div><div class="line">          (format t &quot;~%[Main Thread] Destroyer thread alive... killing it&quot;)</div><div class="line">          (bt:destroy-thread destroyer-thread))</div><div class="line">        (format t &quot;~%[Main Thread] Destroyer thread is already dead&quot;))</div><div class="line">    (until (bt:thread-alive-p destroyer-thread)</div><div class="line">           (format t &quot;[Main Thread] Waiting for destroyer thread to die...&quot;))</div><div class="line">    (format t &quot;~%[Main Thread] Destroyer thread dead&quot;)</div><div class="line">    (format t &quot;~%[Main Thread] Adios!~%&quot;)))</div></div><!-- fragment --><p>И вывод при запуске:</p>
<div class="fragment"><div class="line">CL-USER&gt; (join-destroy-thread)</div><div class="line"></div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Destroyer Thread] Working...</div><div class="line">[Main Thread] Waiting on joiner thread...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Main Thread] Done waiting on joiner thread</div><div class="line">[Main Thread] Destroyer thread alive... killing it</div><div class="line">[Main Thread] Destroyer thread dead</div><div class="line">[Main Thread] Adios!</div><div class="line">NIL</div></div><!-- fragment --><p>Макрос until просто выполняет цикл, пока условие не станет истинным. Остальная часть кода в значительной степени не требует пояснений - основной поток ожидает завершения присоединяемого потока, но он немедленно уничтожает поток-разрушитель.</p>
<p>Опять же, не рекомендуется использовать <code>bt:destroy-thread</code>. Любая мыслимая ситуация, которая требует этой функции, вероятно, может быть лучше решена с помощью другого подхода.</p>
<p>Теперь давайте перейдем к более подробным примерам, которые объединяют все концепции, обсужденные до сих пор.</p>
<h3>Полезные функции</h3>
<p>Вот сводка функций, макросов и глобальных переменных, которые использовались в демонстрационных примерах, а также некоторые дополнения. Они должны охватывать большинство основных сценариев программирования:</p>
<ul>
<li><code>bt:*supports-thread-p*</code> (для проверки базовой поддержки потоков)</li>
<li><code>bt:make-thread</code> (создать новый поток)</li>
<li><code>bt:current-thread</code> (вернуть объект текущего потока)</li>
<li><code>bt:all-threads</code> (вернуть список всех запущенных потоков)</li>
<li><code>bt:thread-alive-p</code> (проверяет, жив ли поток)</li>
<li><code>bt:thread-name</code> (вернуть имя потока)</li>
<li><code>bt:join-thread</code> (присоединиться к предоставленному потоку)</li>
<li><code>bt:interrupt-thread</code> (прервать данный поток)</li>
<li><code>bt:destroy-thread</code> (попытка прервать поток)</li>
<li><code>bt:make-lock</code> (создать мьютекс)</li>
<li><code>bt:with-lock-held</code> (используйте прилагаемый замок для защиты критического кода)</li>
</ul>
<h2>Потоки SBCL</h2>
<p><a href="http://www.sbcl.org/">SBCL</a> обеспечивает поддержку собственных потоков через свой пакет <a href="http://www.sbcl.org/manual/#Threading">sb-thread</a>. Это очень низкоуровневые функции, но мы можем создавать собственные абстракции на их основе, как показано в демонстрационных примерах.</p>
<p>Вы можете обратиться к документации для получения более подробной информации (см. Раздел «Wrap-up/Заключение»).</p>
<p>Из приведенных ниже примеров видно, что существует сильное соответствие между функциями Bordeaux и SBCL Thread. В большинстве случаев единственная разница заключается в изменении имени пакета с bt на sb-thread.</p>
<p>Очевидно, что библиотека потоков Bordeaux была более или менее основана на реализации SBCL. Таким образом, объяснение будет предоставлено только в тех случаях, когда есть существенные различия в синтаксисе или семантике.</p>
<h3>Основы - перечислить текущий поток, перечислить все потоки, получить имя потока</h3>
<p>Код:</p>
<div class="fragment"><div class="line">;;; Print the current thread, all the threads, and the current thread&#39;s name</div><div class="line"></div><div class="line">(defun print-thread-info ()</div><div class="line">  (let* ((curr-thread sb-thread:*current-thread*)</div><div class="line">         (curr-thread-name (sb-thread:thread-name curr-thread))</div><div class="line">         (all-threads (sb-thread:list-all-threads)))</div><div class="line">    (format t &quot;Current thread: ~a~%~%&quot; curr-thread)</div><div class="line">    (format t &quot;Current thread name: ~a~%~%&quot; curr-thread-name)</div><div class="line">    (format t &quot;All threads:~% ~{~a~%~}~%&quot; all-threads))</div><div class="line">  nil)</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">CL-USER&gt; (print-thread-info)</div><div class="line">Current thread: #&lt;THREAD &quot;repl-thread&quot; RUNNING {10043B8003}&gt;</div><div class="line"></div><div class="line">Current thread name: repl-thread</div><div class="line"></div><div class="line">All threads:</div><div class="line"> #&lt;THREAD &quot;repl-thread&quot; RUNNING {10043B8003}&gt;</div><div class="line">#&lt;THREAD &quot;auto-flush-thread&quot; RUNNING {10043B7DA3}&gt;</div><div class="line">#&lt;THREAD &quot;swank-indentation-cache-thread&quot; waiting on: #&lt;WAITQUEUE  {1003A28103}&gt; {1003A201A3}&gt;</div><div class="line">#&lt;THREAD &quot;reader-thread&quot; RUNNING {1003A20063}&gt;</div><div class="line">#&lt;THREAD &quot;control-thread&quot; waiting on: #&lt;WAITQUEUE  {1003A19E53}&gt; {1003A18C83}&gt;</div><div class="line">#&lt;THREAD &quot;Swank Sentinel&quot; waiting on: #&lt;WAITQUEUE  {1003790043}&gt; {1003788023}&gt;</div><div class="line">#&lt;THREAD &quot;main thread&quot; RUNNING {1002991CE3}&gt;</div><div class="line"></div><div class="line">NIL</div></div><!-- fragment --><h3>Обновить глобальную переменную из потока</h3>
<p>Код:</p>
<div class="fragment"><div class="line">;;; Update a global variable from a thread</div><div class="line"></div><div class="line">(defparameter *counter* 0)</div><div class="line"></div><div class="line">(defun test-update-global-variable ()</div><div class="line">  (sb-thread:make-thread</div><div class="line">   (lambda ()</div><div class="line">     (sleep 1)</div><div class="line">     (incf *counter*)))</div><div class="line">  *counter*)</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">CL-USER&gt; (test-update-global-variable)</div><div class="line">0</div></div><!-- fragment --><h3>Распечатать сообщение на верхнем уровне используя поток</h3>
<p>Код:</p>
<div class="fragment"><div class="line">;;; Print a message onto the top-level using a thread</div><div class="line"></div><div class="line">(defun print-message-top-level-wrong ()</div><div class="line">  (sb-thread:make-thread</div><div class="line">   (lambda ()</div><div class="line">     (format *standard-output* &quot;Hello from thread!&quot;)))</div><div class="line">  nil)</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">CL-USER&gt; (print-message-top-level-wrong)</div><div class="line">NIL</div></div><!-- fragment --><p>Распечатать сообщение на верхнем уровне - исправлено:</p>
<p>Код:</p>
<div class="fragment"><div class="line">;;; Print a message onto the top-level using a thread - fixed</div><div class="line"></div><div class="line">(defun print-message-top-level-fixed ()</div><div class="line">  (let ((top-level *standard-output*))</div><div class="line">    (sb-thread:make-thread</div><div class="line">     (lambda ()</div><div class="line">       (format top-level &quot;Hello from thread!&quot;))))</div><div class="line">  nil)</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">CL-USER&gt; (print-message-top-level-fixed)</div><div class="line">Hello from thread!</div><div class="line">NIL</div></div><!-- fragment --><h3>Распечатать сообщение на верхнем уровне - лучше</h3>
<p>Код:</p>
<div class="fragment"><div class="line">;;; Print a message onto the top-level using a thread - reader macro</div><div class="line"></div><div class="line">(eval-when (:compile-toplevel)</div><div class="line">  (defun print-message-top-level-reader-macro ()</div><div class="line">    (sb-thread:make-thread</div><div class="line">     (lambda ()</div><div class="line">       (format #.*standard-output* &quot;Hello from thread!&quot;)))</div><div class="line">    nil))</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">CL-USER&gt; (print-message-top-level-reader-macro)</div><div class="line">Hello from thread!</div><div class="line">NIL</div></div><!-- fragment --><h3>Изменить общий ресурс из нескольких потоков</h3>
<p>Код:</p>
<div class="fragment"><div class="line">;;; Modify a shared resource from multiple threads</div><div class="line"></div><div class="line">(defclass bank-account ()</div><div class="line">  ((id :initarg :id</div><div class="line">       :initform (error &quot;id required&quot;)</div><div class="line">       :accessor :id)</div><div class="line">   (name :initarg :name</div><div class="line">         :initform (error &quot;name required&quot;)</div><div class="line">         :accessor :name)</div><div class="line">   (balance :initarg :balance</div><div class="line">            :initform 0</div><div class="line">            :accessor :balance)))</div><div class="line"></div><div class="line">(defgeneric deposit (account amount)</div><div class="line">  (:documentation &quot;Deposit money into the account&quot;))</div><div class="line"></div><div class="line">(defgeneric withdraw (account amount)</div><div class="line">  (:documentation &quot;Withdraw amount from account&quot;))</div><div class="line"></div><div class="line">(defmethod deposit ((account bank-account) (amount real))</div><div class="line">  (incf (:balance account) amount))</div><div class="line"></div><div class="line">(defmethod withdraw ((account bank-account) (amount real))</div><div class="line">  (decf (:balance account) amount))</div><div class="line"></div><div class="line">(defparameter *rich*</div><div class="line">  (make-instance &#39;bank-account</div><div class="line">                 :id 1</div><div class="line">                 :name &quot;Rich&quot;</div><div class="line">                 :balance 0))</div><div class="line"></div><div class="line">(defun demo-race-condition ()</div><div class="line">  (loop repeat 100</div><div class="line">     do</div><div class="line">       (sb-thread:make-thread</div><div class="line">        (lambda ()</div><div class="line">          (loop repeat 10000 do (deposit *rich* 100))</div><div class="line">          (loop repeat 10000 do (withdraw *rich* 100))))))</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">CL-USER&gt; (:balance *rich*)</div><div class="line">0</div><div class="line">CL-USER&gt; (demo-race-condition)</div><div class="line">NIL</div><div class="line">CL-USER&gt; (:balance *rich*)</div><div class="line">3987400</div></div><!-- fragment --><h3>Изменение общего ресурса из нескольких потоков - исправлено с помощью блокировок</h3>
<p>Код:</p>
<div class="fragment"><div class="line">(defvar *lock* (sb-thread:make-mutex))</div><div class="line"></div><div class="line">(defun demo-race-condition-locks ()</div><div class="line">  (loop repeat 100</div><div class="line">     do</div><div class="line">       (sb-thread:make-thread</div><div class="line">        (lambda ()</div><div class="line">          (loop repeat 10000 do (sb-thread:with-mutex (*lock*)</div><div class="line">                                  (deposit *rich* 100)))</div><div class="line">          (loop repeat 10000 do (sb-thread:with-mutex (*lock*)</div><div class="line">                                  (withdraw *rich* 100)))))))</div></div><!-- fragment --><p>Единственная разница здесь в том, что вместо make-lock, как в Bordeaux, у нас есть make-mutex, который используется вместе с макросом with-mutex, как показано в примере.</p>
<p>И вывод:</p>
<div class="fragment"><div class="line">CL-USER&gt; (:balance *rich*)</div><div class="line">0</div><div class="line">CL-USER&gt; (demo-race-condition-locks)</div><div class="line">NIL</div><div class="line">CL-USER&gt; (:balance *rich*)</div><div class="line">0</div></div><!-- fragment --><h3>Измените общий ресурс из нескольких потоков - используя атомарные операции</h3>
<p>Первый, код:</p>
<div class="fragment"><div class="line">;;; Modify a shared resource from multiple threads - atomics</div><div class="line"></div><div class="line">(defgeneric atomic-deposit (account amount)</div><div class="line">  (:documentation &quot;Atomic version of the deposit method&quot;))</div><div class="line"></div><div class="line">(defgeneric atomic-withdraw (account amount)</div><div class="line">  (:documentation &quot;Atomic version of the withdraw method&quot;))</div><div class="line"></div><div class="line">(defmethod atomic-deposit ((account bank-account) (amount real))</div><div class="line">  (sb-ext:atomic-incf (car (cons (:balance account) nil)) amount))</div><div class="line"></div><div class="line">(defmethod atomic-withdraw ((account bank-account) (amount real))</div><div class="line">  (sb-ext:atomic-decf (car (cons (:balance account) nil)) amount))</div><div class="line"></div><div class="line">(defun demo-race-condition-atomics ()</div><div class="line">  (loop repeat 100</div><div class="line">     do (sb-thread:make-thread</div><div class="line">         (lambda ()</div><div class="line">           (loop repeat 10000 do (atomic-deposit *rich* 100))</div><div class="line">           (loop repeat 10000 do (atomic-withdraw *rich* 100))))))</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">CL-USER&gt; (dotimes (i 5)</div><div class="line">           (format t &quot;~%Opening: ~d&quot; (:balance *rich*))</div><div class="line">           (demo-race-condition-atomics)</div><div class="line">           (format t &quot;~%Closing: ~d~%&quot; (:balance *rich*)))</div><div class="line"></div><div class="line">Opening: 0</div><div class="line">Closing: 0</div><div class="line"></div><div class="line">Opening: 0</div><div class="line">Closing: 0</div><div class="line"></div><div class="line">Opening: 0</div><div class="line">Closing: 0</div><div class="line"></div><div class="line">Opening: 0</div><div class="line">Closing: 0</div><div class="line"></div><div class="line">Opening: 0</div><div class="line">Closing: 0</div><div class="line">NIL</div></div><!-- fragment --><p>Как видите, атомарные функции SBCL несколько необычны. Две используемые здесь функции: <code>sb-ext:incf</code> и <code>sb-ext:atomic-decf</code> имеют следующие сигнатуры: </p><pre class="fragment">Macro: atomic-incf [sb-ext] place &amp;optional diff
</pre><p>и </p><pre class="fragment">Macro: atomic-decf [sb-ext] place &amp;optional diff
</pre><p>Интересно то, что параметр «place/место» должен иметь одно из следующих значений (согласно документации):</p>
<ul>
<li>слот defstruct с объявленным типом (unsigned-byte 64) или aref из (simple-array (unsigned-byte 64) (*)) Для этих целей можно использовать тип <code>sb-ext:word</code>.</li>
<li>car или cdr (соответственно first или REST) для cons.</li>
<li>переменная, определенная с помощью defglobal с заявленным типом (proclaimed type) fixnum</li>
</ul>
<p>Это причина причудливой конструкции, используемой в методах <code>atomic-deposit</code> и <code>atomic-decf</code>.</p>
<p>Одним из основных стимулов максимально использовать атомарные операции является производительность. Давайте быстро запустим функции demo-race-condition-locks и demo-race-condition-atomics более 1000 раз и проверим разницу в производительности (если есть):</p>
<p>С блокировками:</p>
<div class="fragment"><div class="line">CL-USER&gt; (time</div><div class="line">                    (loop repeat 100</div><div class="line">                      do (demo-race-condition-locks)))</div><div class="line">Evaluation took:</div><div class="line">  57.711 seconds of real time</div><div class="line">  431.451639 seconds of total run time (408.014746 user, 23.436893 system)</div><div class="line">  747.61% CPU</div><div class="line">  126,674,011,941 processor cycles</div><div class="line">  3,329,504 bytes consed</div><div class="line"></div><div class="line">NIL</div></div><!-- fragment --><p>С атомарными операциями:</p>
<div class="fragment"><div class="line">CL-USER&gt; (time</div><div class="line">                    (loop repeat 100</div><div class="line">                     do (demo-race-condition-atomics)))</div><div class="line">Evaluation took:</div><div class="line">  2.495 seconds of real time</div><div class="line">  8.175454 seconds of total run time (6.124259 user, 2.051195 system)</div><div class="line">  [ Run times consist of 0.420 seconds GC time, and 7.756 seconds non-GC time. ]</div><div class="line">  327.66% CPU</div><div class="line">  5,477,039,706 processor cycles</div><div class="line">  3,201,582,368 bytes consed</div><div class="line"></div><div class="line">NIL</div></div><!-- fragment --><p>Результаты? Версия с блокировками заняла около 57 с, тогда как версия без блокировки с атомикой заняла всего 2 с! Это действительно огромная разница!</p>
<h3>Присоединение к потоку, уничтожение примера потока</h3>
<p>Код:</p>
<div class="fragment"><div class="line">;;; Joining on and destroying a thread</div><div class="line"></div><div class="line">(defmacro until (condition &amp;body body)</div><div class="line">  (let ((block-name (gensym)))</div><div class="line">    `(block ,block-name</div><div class="line">       (loop</div><div class="line">           (if ,condition</div><div class="line">               (return-from ,block-name nil)</div><div class="line">               (progn</div><div class="line">                   ,@body))))))</div><div class="line"></div><div class="line">(defun join-destroy-thread ()</div><div class="line">  (let* ((s *standard-output*)</div><div class="line">        (joiner-thread (sb-thread:make-thread</div><div class="line">                        (lambda ()</div><div class="line">                          (loop for i from 1 to 10</div><div class="line">                             do</div><div class="line">                               (format s &quot;~%[Joiner Thread]  Working...&quot;)</div><div class="line">                               (sleep (* 0.01 (random 100)))))))</div><div class="line">        (destroyer-thread (sb-thread:make-thread</div><div class="line">                           (lambda ()</div><div class="line">                             (loop for i from 1 to 1000000</div><div class="line">                                do</div><div class="line">                                  (format s &quot;~%[Destroyer Thread] Working...&quot;)</div><div class="line">                                  (sleep (* 0.01 (random 10000))))))))</div><div class="line">    (format t &quot;~%[Main Thread] Waiting on joiner thread...&quot;)</div><div class="line">    (bt:join-thread joiner-thread)</div><div class="line">    (format t &quot;~%[Main Thread] Done waiting on joiner thread&quot;)</div><div class="line">    (if (sb-thread:thread-alive-p destroyer-thread)</div><div class="line">        (progn</div><div class="line">          (format t &quot;~%[Main Thread] Destroyer thread alive... killing it&quot;)</div><div class="line">          (sb-thread:terminate-thread destroyer-thread))</div><div class="line">        (format t &quot;~%[Main Thread] Destroyer thread is already dead&quot;))</div><div class="line">    (until (sb-thread:thread-alive-p destroyer-thread)</div><div class="line">           (format t &quot;[Main Thread] Waiting for destroyer thread to die...&quot;))</div><div class="line">    (format t &quot;~%[Main Thread] Destroyer thread dead&quot;)</div><div class="line">    (format t &quot;~%[Main Thread] Adios!~%&quot;)))</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">CL-USER&gt; (join-destroy-thread)</div><div class="line"></div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Destroyer Thread] Working...</div><div class="line">[Main Thread] Waiting on joiner thread...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Joiner Thread]  Working...</div><div class="line">[Main Thread] Done waiting on joiner thread</div><div class="line">[Main Thread] Destroyer thread alive... killing it</div><div class="line">[Main Thread] Destroyer thread dead</div><div class="line">[Main Thread] Adios!</div><div class="line">NIL</div></div><!-- fragment --><h3>Полезные функции</h3>
<p>Вот краткий список функций, макросов и глобальных переменных, используемых в примерах, а также некоторые дополнения:</p>
<ul>
<li><code>(member :thread-support *features*)</code> (проверка поддержки потоков)</li>
<li><code>sb-thread:make-thread</code> (создать новый поток)</li>
<li><code>sb-thread:*current-thread*</code> (содержит объект текущего потока)</li>
<li><code>sb-thread:list-all-threads</code> (вернуть список всех запущенных потоков)</li>
<li><code>sb-thread:thread-alive-p</code> (проверяет, жив ли поток)</li>
<li><code>sb-thread:thread-name</code> (вернуть имя потока)</li>
<li><code>sb-thread:join-thread</code> (присоединиться к предоставленному потоку)</li>
<li><code>sb-thread:interrupt-thread</code> (прервать данный поток)</li>
<li><code>sb-thread:destroy-thread</code> (попытка уничтожить поток)</li>
<li><code>sb-thread:make-mutex</code> (создать мьютекс)</li>
<li><code>sb-thread:with-mutex</code> (используйте прилагаемую блокировку для защиты критического кода)</li>
</ul>
<h2>краткая сводка новостей</h2>
<p>Как видите, поддержка параллелизма в Common Lisp довольно примитивна, но в первую очередь это связано с явным отсутствием этой важной функции в спецификации ANSI Common Lisp. Это нисколько не умаляет ни поддержки, предоставляемой реализациями Common Lisp, ни замечательных библиотек, таких как библиотека Bordeaux.</p>
<p>Вам следует продолжить работу самостоятельно, прочитав еще много информации по этой теме. Я поделюсь некоторыми своими ссылками здесь:</p>
<ul>
<li><a href="http://weitz.de/cl-recipes/">Common Lisp Recipes</a></li>
<li><a href="https://trac.common-lisp.net/bordeaux-threads/wiki/ApiDocumentation">Bordeaux API Reference</a></li>
<li><a href="http://www.sbcl.org/manual/">SBCL Manual</a> on <a href="http://www.sbcl.org/manual/#Threading">Threading</a></li>
<li><a href="https://www.lispworks.com/documentation/HyperSpec/Front/">The Common Lisp Hyperspec</a></li>
</ul>
<p>Далее, последний пост в этой мини-серии: параллелизм в Common Lisp с использованием библиотеки <b>lparallel</b>.</p>
<h2>Параллельное программирование с lparallel</h2>
<p>Важно отметить, что lparallel также обеспечивает обширную поддержку асинхронного программирования и не является чисто параллельной библиотекой программирования. Как указывалось ранее, параллелизм - это просто абстрактное понятие, в котором задачи концептуально независимы друг от друга.</p>
<p>Библиотека lparallel построена на основе библиотеки потоков Bordeaux.</p>
<p>Как упоминалось ранее, параллелизм и одновременность могут быть (и обычно реализуются) с использованием одних и тех же средств</p><ul>
<li>потоков, процессов и т. Д. Разница между ними заключается в их концептуальных различиях.</li>
</ul>
<p>Обратите внимание, что не все примеры, показанные в этом посте, обязательно параллельны. Асинхронные конструкции, такие как Promises и Futures, в частности, больше подходят для параллельного программирования, чем для параллельного программирования.</p>
<p>Порядок работы(modus operandi) с библиотекой lparallel (для базового варианта использования) выглядит следующим образом:</p>
<ul>
<li>Создайте экземпляр того, что библиотека называет ядром(kernel), используя <code>lparallel:make-kernel</code>. Ядро - это компонент, который планирует и выполняет задачи.</li>
<li>Разработайте код в терминах будущего(futures), обещаний(promises) и других функциональных концепций более высокого уровня. С этой целью lparallel обеспечивает поддержку <b>channels</b>(каналов), <b>promises</b>(обещаний), <b>futures</b>(будущее) и <b>cognates</b>(родственных).</li>
<li>Выполняйте операции, используя то, что библиотека называет родственными(cognates) функциями, то есть просто функциями, имеющими эквиваленты в самом языке Common Lisp. Например, функция <code>lparallel:pmap</code> является параллельным эквивалентом функции <code>map</code> Common Lisp.</li>
<li>Наконец, закройте ядро, созданное на первом шаге, с помощью <code>lparallel:end-kernel</code>.</li>
</ul>
<p>Обратите внимание, что ответственность за логическую параллелизацию выполняемых задач и заботу обо всех изменяемых состояниях лежит на разработчике.</p>
<p><em>Credit: this article first appeared on <a href="https://z0ltan.wordpress.com/2016/09/09/basic-concurrency-and-parallelism-in-common-lisp-part-4a-parallelism-using-lparallel-fundamentals/">z0ltan.wordpress.com</a>.</em></p>
<h3>Установка</h3>
<p>Давайте проверим, доступен ли lparallel для загрузки с помощью Quicklisp:</p>
<div class="fragment"><div class="line">CL-USER&gt; (ql:system-apropos &quot;lparallel&quot;)</div><div class="line">#&lt;SYSTEM lparallel / lparallel-20160825-git / quicklisp 2016-08-25&gt;</div><div class="line">#&lt;SYSTEM lparallel-bench / lparallel-20160825-git / quicklisp 2016-08-25&gt;</div><div class="line">#&lt;SYSTEM lparallel-test / lparallel-20160825-git / quicklisp 2016-08-25&gt;</div><div class="line">; No value</div></div><!-- fragment --><p>Похоже, это так. Давайте продолжим и установим его:</p>
<div class="fragment"><div class="line">CL-USER&gt; (ql:quickload &quot;lparallel&quot;)</div><div class="line">To load &quot;lparallel&quot;:</div><div class="line">  Load 2 ASDF systems:</div><div class="line">    alexandria bordeaux-threads</div><div class="line">  Install 1 Quicklisp release:</div><div class="line">    lparallel</div><div class="line">; Fetching #&lt;URL &quot;http://beta.quicklisp.org/archive/lparallel/2016-08-25/lparallel-20160825-git.tgz&quot;&gt;</div><div class="line">; 76.71KB</div><div class="line">==================================================</div><div class="line">78,551 bytes in 0.62 seconds (124.33KB/sec)</div><div class="line">; Loading &quot;lparallel&quot;</div><div class="line">[package lparallel.util]..........................</div><div class="line">[package lparallel.thread-util]...................</div><div class="line">[package lparallel.raw-queue].....................</div><div class="line">[package lparallel.cons-queue]....................</div><div class="line">[package lparallel.vector-queue]..................</div><div class="line">[package lparallel.queue].........................</div><div class="line">[package lparallel.counter].......................</div><div class="line">[package lparallel.spin-queue]....................</div><div class="line">[package lparallel.kernel]........................</div><div class="line">[package lparallel.kernel-util]...................</div><div class="line">[package lparallel.promise].......................</div><div class="line">[package lparallel.ptree].........................</div><div class="line">[package lparallel.slet]..........................</div><div class="line">[package lparallel.defpun]........................</div><div class="line">[package lparallel.cognate].......................</div><div class="line">[package lparallel]</div><div class="line">(:LPARALLEL)</div></div><!-- fragment --><p>И это все, что нужно! Теперь посмотрим, как на самом деле работает эта библиотека.</p>
<h3>Преамбула - получить количество ядер</h3>
<p>Во-первых, давайте определим количество потоков, которые мы собираемся использовать для наших параллельных примеров. В идеале мы хотели бы иметь соответствие 1: 1 между количеством рабочих потоков и количеством доступных ядер(cores).</p>
<p>Для этого мы можем использовать замечательную библиотеку <b>Serapeum</b>, которая имеет функцию <code>count-cpus</code>, которая работает на всех основных платформах.</p>
<p>Установите её:</p>
<div class="fragment"><div class="line">CL-USER&gt; (ql:quickload &quot;serapeum&quot;)</div></div><!-- fragment --><p>и назови это:</p>
<div class="fragment"><div class="line">CL-USER&gt; (serapeum:count-cpus)</div><div class="line">8</div></div><!-- fragment --><p>и проверьте, что это правильно.</p>
<h3>Общая настройка</h3>
<p>В этом примере мы рассмотрим часть начальной настройки, а также покажем некоторую полезную информацию после завершения настройки.</p>
<p>Загрузите библиотеку:</p>
<div class="fragment"><div class="line">CL-USER&gt; (ql:quickload &quot;lparallel&quot;)</div><div class="line">To load &quot;lparallel&quot;:</div><div class="line">  Load 1 ASDF system:</div><div class="line">    lparallel</div><div class="line">; Loading &quot;lparallel&quot;</div><div class="line"></div><div class="line">(:LPARALLEL)</div></div><!-- fragment --><p>Инициализировать lparallel ядро:</p>
<div class="fragment"><div class="line">CL-USER&gt; (setf lparallel:*kernel* (lparallel:make-kernel 8 :name &quot;custom-kernel&quot;))</div><div class="line">#&lt;LPARALLEL.KERNEL:KERNEL :NAME &quot;custom-kernel&quot; :WORKER-COUNT 8 :USE-CALLER NIL :ALIVE T :SPIN-COUNT 2000 {1003141F03}&gt;</div></div><!-- fragment --><p>Обратите внимание, что глобальная переменная <code>*kernel*</code> может быть повторно связана - это позволяет нескольким ядрам сосуществовать во время одного запуска. Теперь немного полезной информации о ядре:</p>
<div class="fragment"><div class="line">CL-USER&gt; (defun show-kernel-info ()</div><div class="line">           (let ((name (lparallel:kernel-name))</div><div class="line">                 (count (lparallel:kernel-worker-count))</div><div class="line">                 (context (lparallel:kernel-context))</div><div class="line">                 (bindings (lparallel:kernel-bindings)))</div><div class="line">             (format t &quot;Kernel name = ~a~%&quot; name)</div><div class="line">             (format t &quot;Worker threads count = ~d~%&quot; count)</div><div class="line">             (format t &quot;Kernel context = ~a~%&quot; context)</div><div class="line">             (format t &quot;Kernel bindings = ~a~%&quot; bindings)))</div><div class="line"></div><div class="line">WARNING: redefining COMMON-LISP-USER::SHOW-KERNEL-INFO in DEFUN</div><div class="line">SHOW-KERNEL-INFO</div><div class="line"></div><div class="line">CL-USER&gt; (show-kernel-info)</div><div class="line">Kernel name = custom-kernel</div><div class="line">Worker threads count = 8</div><div class="line">Kernel context = #&lt;FUNCTION FUNCALL&gt;</div><div class="line">Kernel bindings = ((*STANDARD-OUTPUT* . #&lt;SLIME-OUTPUT-STREAM {10044EEEA3}&gt;)</div><div class="line">                   (*ERROR-OUTPUT* . #&lt;SLIME-OUTPUT-STREAM {10044EEEA3}&gt;))</div><div class="line">NIL</div></div><!-- fragment --><p>Завершения ядра (это важно, поскольку <code>*kernel*</code>(ядро) не собирает мусор, пока мы явно не завершим его):</p>
<div class="fragment"><div class="line">CL-USER&gt; (lparallel:end-kernel :wait t)</div><div class="line">(#&lt;SB-THREAD:THREAD &quot;custom--kernel&quot; FINISHED values: NIL {100723FA83}&gt;</div><div class="line"> #&lt;SB-THREAD:THREAD &quot;custom--kernel&quot; FINISHED values: NIL {100723FE23}&gt;</div><div class="line"> #&lt;SB-THREAD:THREAD &quot;custom--kernel&quot; FINISHED values: NIL {10072581E3}&gt;</div><div class="line"> #&lt;SB-THREAD:THREAD &quot;custom--kernel&quot; FINISHED values: NIL {1007258583}&gt;</div><div class="line"> #&lt;SB-THREAD:THREAD &quot;custom--kernel&quot; FINISHED values: NIL {1007258923}&gt;</div><div class="line"> #&lt;SB-THREAD:THREAD &quot;custom--kernel&quot; FINISHED values: NIL {1007258CC3}&gt;</div><div class="line"> #&lt;SB-THREAD:THREAD &quot;custom--kernel&quot; FINISHED values: NIL {1007259063}&gt;</div><div class="line"> #&lt;SB-THREAD:THREAD &quot;custom--kernel&quot; FINISHED values: NIL {1007259403}&gt;)</div></div><!-- fragment --><p>Давайте перейдем к еще нескольким примерам различных аспектов библиотеки lparallel.</p>
<p>Для этих демонстраций мы будем использовать следующую начальную настройку с точки зрения кодирования:</p>
<div class="fragment"><div class="line">(require ‘lparallel)</div><div class="line">(require ‘bt-semaphore)</div><div class="line"></div><div class="line">(defpackage :lparallel-user</div><div class="line">  (:use :cl :lparallel :lparallel.queue :bt-semaphore))</div><div class="line"></div><div class="line">(in-package :lparallel-user)</div><div class="line"></div><div class="line">;;; initialise the kernel</div><div class="line">(defun init ()</div><div class="line">  (setf *kernel* (make-kernel 8 :name &quot;channel-queue-kernel&quot;)))</div><div class="line"></div><div class="line">(init)</div></div><!-- fragment --><p>Таким образом, мы будем использовать ядро с 8 рабочими потоками (по одному на каждое ядро процессора на машине).</p>
<p>И как только мы закончим со всеми примерами, будет запущен следующий код, чтобы закрыть ядро и освободить все используемые системные ресурсы:</p>
<div class="fragment"><div class="line">;;; shut the kernel down</div><div class="line">(defun shutdown ()</div><div class="line">  (end-kernel :wait t))</div><div class="line"></div><div class="line">(shutdown)</div></div><!-- fragment --><h3>Использование каналов и очередей</h3>
<p>Сначала несколько определений.</p>
<p><b>task</b>(Задача) - это задание, которое передается ядру. Это просто объект функция вместе со своими аргументами.</p>
<p><b>channel</b>(Канал) в lparallel аналогичен той же концепции в Go. Канал - это просто средство связи с рабочим потоком. В нашем случае это один из способов отправки задач ядру.</p>
<p>Канал создается в lparallel с помощью <code>lparallel:make-channel</code>. Задача отправляется с помощью <code>lparallel:submit-task</code>, а результаты получаются с помощью <code>lparallel:receive-result</code>.</p>
<p>Например, мы можем вычислить квадрат числа как:</p>
<div class="fragment"><div class="line">(defun calculate-square (n)</div><div class="line">  (let* ((channel (lparallel:make-channel))</div><div class="line">         (res nil))</div><div class="line">    (lparallel:submit-task channel #&#39;(lambda (x)</div><div class="line">                                       (* x x))</div><div class="line">                           n)</div><div class="line">    (setf res (lparallel:receive-result channel))</div><div class="line">    (format t &quot;Square of ~d = ~d~%&quot; n res)))</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (calculate-square 100)</div><div class="line">Square of 100 = 10000</div><div class="line">NIL</div></div><!-- fragment --><p>Теперь давайте попробуем отправить несколько задач в один канал. В этом простом примере мы просто создаем три задачи, которые возводят в квадрат, по три и по четыре раза соответственно для предоставленных входных данных.</p>
<p>Обратите внимание, что в случае нескольких задач вывод будет в недетерминированном порядке:</p>
<div class="fragment"><div class="line">(defun test-basic-channel-multiple-tasks ()</div><div class="line">  (let ((channel (make-channel))</div><div class="line">        (res &#39;()))</div><div class="line">    (submit-task channel #&#39;(lambda (x)</div><div class="line">                             (* x x))</div><div class="line">                 10)</div><div class="line">    (submit-task channel #&#39;(lambda (y)</div><div class="line">                             (* y y y))</div><div class="line">                 10)</div><div class="line">    (submit-task channel #&#39;(lambda (z)</div><div class="line">                             (* z z z z))</div><div class="line">                 10)</div><div class="line">     (dotimes (i 3 res)</div><div class="line">       (push (receive-result channel) res))))</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (dotimes (i 3)</div><div class="line">                              (print (test-basic-channel-multiple-tasks)))</div><div class="line"></div><div class="line">(100 1000 10000)</div><div class="line">(100 1000 10000)</div><div class="line">(10000 1000 100)</div><div class="line">NIL</div></div><!-- fragment --><p>lparallel также обеспечивает поддержку для создания блокирующей очереди , чтобы разрешить передачу сообщений между рабочими потоками. Очередь создается с помощью <code>lparallel.queue:make-queue</code>.</p>
<p>Некоторые полезные функции для использования очередей:</p>
<ul>
<li><code>lparallel.queue:make-queue</code>: создает FIFO блокирующую очередь(blocking queue)</li>
<li><code>lparallel.queue:push-queue</code>: вставляет элемент в очередь</li>
<li><code>lparallel.queue:pop-queue</code>: извлекает элемент из очереди</li>
<li><code>lparallel.queue:peek-queue</code>: проверяет значение без его извлечения из очереди</li>
<li><code>lparallel.queue:queue-count</code>: количество записей в очереди</li>
<li><code>lparallel.queue:queue-full-p</code>: проверить, заполнена ли очередь</li>
<li><code>lparallel.queue:queue-empty-p</code>: проверить, пуста ли очередь</li>
<li><code>lparallel.queue:with-locked-queue</code>: заблокировать очередь во время доступа</li>
</ul>
<p>Базовая демонстрация, показывающая основные свойства очереди:</p>
<div class="fragment"><div class="line">(defun test-queue-properties ()</div><div class="line">  (let ((queue (make-queue :fixed-capacity 5)))</div><div class="line">    (loop</div><div class="line">       when (queue-full-p queue)</div><div class="line">       do (return)</div><div class="line">       do (push-queue (random 100) queue))</div><div class="line">     (print (queue-full-p queue))</div><div class="line">    (loop</div><div class="line">       when (queue-empty-p queue)</div><div class="line">       do (return)</div><div class="line">       do (print (pop-queue queue)))</div><div class="line">    (print (queue-empty-p queue)))</div><div class="line">  nil)</div></div><!-- fragment --><p>Что производит:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-queue-properties)</div><div class="line"></div><div class="line">T</div><div class="line">17</div><div class="line">51</div><div class="line">55</div><div class="line">42</div><div class="line">82</div><div class="line">T</div><div class="line">NIL</div></div><!-- fragment --><p>Примечание: <code>lparallel.queue:make-queue</code> - это обобщенный интерфейс, который фактически поддерживается разными типами очередей. Например, в предыдущем примере фактическим типом очереди является <code>lparallel.vector-queue</code>, поскольку мы указали, что она имеет фиксированный размер, используя аргумент ключевого слова <code>:fixed-capacity</code>.</p>
<p>В документации фактически не указано, какие ключевые аргументы мы можем передать в <code>lparallel.queue:make-queue</code>, поэтому давайте выясним это другим способом:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (describe &#39;lparallel.queue:make-queue)</div><div class="line">LPARALLEL.QUEUE:MAKE-QUEUE</div><div class="line">  [symbol]</div><div class="line"></div><div class="line">MAKE-QUEUE names a compiled function:</div><div class="line">  Lambda-list: (&amp;REST ARGS)</div><div class="line">  Derived type: FUNCTION</div><div class="line">  Documentation:</div><div class="line">    Create a queue.</div><div class="line"></div><div class="line">    The queue contents may be initialized with the keyword argument</div><div class="line">    `initial-contents&#39;.</div><div class="line"></div><div class="line">    By default there is no limit on the queue capacity. Passing a</div><div class="line">    `fixed-capacity&#39; keyword argument limits the capacity to the value</div><div class="line">    passed. `push-queue&#39; will block for a full fixed-capacity queue.</div><div class="line">  Source file: /Users/z0ltan/quicklisp/dists/quicklisp/software/lparallel-20160825-git/src/queue.lisp</div><div class="line"></div><div class="line">MAKE-QUEUE has a compiler-macro:</div><div class="line">  Source file: /Users/z0ltan/quicklisp/dists/quicklisp/software/lparallel-20160825-git/src/queue.lisp</div><div class="line">; No value</div></div><!-- fragment --><p>Итак, как мы видим, она поддерживает следующие аргументы ключевого слова: *:fixed-capacity* и <em>initial-contents</em>.</p>
<p>Теперь, если мы укажем: <code>:fixed-capacity</code>, тогда фактическим типом очереди будет <code>lparallel.vector-queue</code>, и если мы пропустим этот аргумент ключевого слова, очередь будет иметь тип <code>lparallel.cons-queue</code> (который является очередью неограниченного размера), как видно из вывода следующего фрагмента:</p>
<div class="fragment"><div class="line">(defun check-queue-types ()</div><div class="line">  (let ((queue-one (make-queue :fixed-capacity 5))</div><div class="line">        (queue-two (make-queue)))</div><div class="line">    (format t &quot;queue-one is of type: ~a~%&quot; (type-of queue-one))</div><div class="line">    (format t &quot;queue-two is of type: ~a~%&quot; (type-of queue-two))))</div><div class="line"></div><div class="line">LPARALLEL-USER&gt; (check-queue-types)</div><div class="line">queue-one is of type: VECTOR-QUEUE</div><div class="line">queue-two is of type: CONS-QUEUE</div><div class="line">NIL</div></div><!-- fragment --><p>Конечно, вы всегда можете создавать экземпляры определенных типов очередей самостоятельно, но всегда лучше, когда это возможно, придерживаться общего интерфейса и позволить библиотеке создать для вас правильный тип очереди.</p>
<p>А теперь давайте просто посмотрим, как работает очередь!</p>
<div class="fragment"><div class="line">(defun test-basic-queue ()</div><div class="line">  (let ((queue (make-queue))</div><div class="line">        (channel (make-channel))</div><div class="line">        (res &#39;()))</div><div class="line">    (submit-task channel #&#39;(lambda ()</div><div class="line">                     (loop for entry = (pop-queue queue)</div><div class="line">                        when (queue-empty-p queue)</div><div class="line">                        do (return)</div><div class="line">                        do (push (* entry entry) res))))</div><div class="line">    (dotimes (i 100)</div><div class="line">      (push-queue i queue))</div><div class="line">    (receive-result channel)</div><div class="line">    (format t &quot;~{~d ~}~%&quot; res)))</div></div><!-- fragment --><p>Здесь мы отправляем одну задачу, которая многократно сканирует очередь до тех пор, пока она не станет пустой, достает доступные значения и помещает их в список res.</p>
<p>И вывод:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-basic-queue)</div><div class="line">9604 9409 9216 9025 8836 8649 8464 8281 8100 7921 7744 7569 7396 7225 7056 6889 6724 6561 6400 6241 6084 5929 5776 5625 5476 5329 5184 5041 4900 4761 4624 4489 4356 4225 4096 3969 3844 3721 3600 3481 3364 3249 3136 3025 2916 2809 2704 2601 2500 2401 2304 2209 2116 2025 1936 1849 1764 1681 1600 1521 1444 1369 1296 1225 1156 1089 1024 961 900 841 784 729 676 625 576 529 484 441 400 361 324 289 256 225 196 169 144 121 100 81 64 49 36 25 16 9 4 1 0</div><div class="line">NIL</div></div><!-- fragment --><h3>Уничтожение задач</h3>
<p>Небольшая заметка, в которой упоминается функция <code>lparallel:kill-task</code>, была бы уместна на данном этапе. Эта функция полезна в тех случаях, когда задачи не отвечают. В документации lparallel четко указано, что это следует использовать только в крайнем случае.</p>
<p>Всем созданным задачам по умолчанию присваивается категория :default. Динамическое свойство <code>*task-category*</code> содержит это значение и может быть динамически привязано к различным значениям (как мы увидим).</p>
<div class="fragment"><div class="line">;;; kill default tasks</div><div class="line">(defun test-kill-all-tasks ()</div><div class="line">  (let ((channel (make-channel))</div><div class="line">        (stream *query-io*))</div><div class="line">    (dotimes (i 10)</div><div class="line">      (submit-task channel #&#39;(lambda (x)</div><div class="line">                               (sleep (random 10))</div><div class="line">                               (format stream &quot;~d~%&quot; (* x x))) (random 10)))</div><div class="line">    (sleep (random 2))</div><div class="line">    (kill-tasks :default)))</div></div><!-- fragment --><p>Пример запуска:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-kill-all-tasks)</div><div class="line">16</div><div class="line">1</div><div class="line">8</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div></div><!-- fragment --><p>Поскольку мы создали 10 задач, все 8 рабочих потоков ядра предположительно были заняты каждой задачей. Когда мы убивали задачи категории :default, все эти потоки также были убиты, и их нужно было регенерировать (что является дорогостоящей операцией). Это одна из причин, по которой следует избегать <code>lparallel:kill-tasks</code>.</p>
<p>Теперь, в приведенном выше примере, все запущенные задачи были убиты, поскольку все они принадлежали к категории :default. Предположим, мы хотим убить только определенные задачи, мы можем сделать это, привязав <code>*task-category*</code> при создании этих задач, а затем указав категорию при вызове <code>lparallel:kill-tasks</code>.</p>
<p>Например, предположим, что у нас есть две категории задач - задачи, которые возводят в квадрат свои аргументы, и задачи, которые возводят в куб свои. Давайте назначим им категории "squaring-tasks" и "cubing-tasks" соответственно. Затем давайте уберем задачи из случайно выбранной категории: squaring-tasks или cubing-tasks.</p>
<p>Вот код:</p>
<div class="fragment"><div class="line">;;; kill tasks of a randomly chosen category</div><div class="line">(defun test-kill-random-tasks ()</div><div class="line">  (let ((channel (make-channel))</div><div class="line">        (stream *query-io*))</div><div class="line">    (let ((*task-category* &#39;squaring-tasks))</div><div class="line">      (dotimes (i 5)</div><div class="line">        (submit-task channel #&#39;(lambda (x)</div><div class="line">                                 (sleep (random 5))</div><div class="line">                                 (format stream &quot;~%[Squaring] ~d = ~d&quot; x (* x x))) i)))</div><div class="line">    (let ((*task-category* &#39;cubing-tasks))</div><div class="line">      (dotimes (i 5)</div><div class="line">        (submit-task channel #&#39;(lambda (x)</div><div class="line">                                 (sleep (random 5))</div><div class="line">                                 (format stream &quot;~%[Cubing] ~d = ~d&quot; x (* x x x))) i)))</div><div class="line">    (sleep 1)</div><div class="line">    (if (evenp (random 10))</div><div class="line">        (progn</div><div class="line">          (print &quot;Killing squaring tasks&quot;)</div><div class="line">          (kill-tasks &#39;squaring-tasks))</div><div class="line">        (progn</div><div class="line">          (print &quot;Killing cubing tasks&quot;)</div><div class="line">          (kill-tasks &#39;cubing-tasks)))))</div></div><!-- fragment --><p>А вот пример запуска:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-kill-random-tasks)</div><div class="line"></div><div class="line">[Cubing] 2 = 8</div><div class="line">[Squaring] 4 = 16</div><div class="line">[Cubing] 4</div><div class="line"> = [Cubing] 643 = 27</div><div class="line">&quot;Killing squaring tasks&quot;</div><div class="line">4</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line"></div><div class="line">[Cubing] 1 = 1</div><div class="line">[Cubing] 0 = 0</div><div class="line"></div><div class="line">LPARALLEL-USER&gt; (test-kill-random-tasks)</div><div class="line"></div><div class="line">[Squaring] 1 = 1</div><div class="line">[Squaring] 3 = 9</div><div class="line">&quot;Killing cubing tasks&quot;</div><div class="line">5</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line"></div><div class="line">[Squaring] 2 = 4</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line">WARNING: lparallel: Replacing lost or dead worker.</div><div class="line"></div><div class="line">[Squaring] 0 = 0</div><div class="line">[Squaring] 4 = 16</div></div><!-- fragment --><h3>Использование обещаний и будущих</h3>
<p>Promises(обещения) и Futures(будущее) обеспечивают поддержку асинхронного программирования.</p>
<p>В lparallel-speak <code>lparallel:promise</code> является заполнителем для результата, который достигается путем предоставления ему значения. Сам объект promise(обещания) создается с помощью <code>lparallel:promise</code>, а обещанию присваивается значение с помощью макроса <code>lparallel:fulfill</code>.</p>
<p>Чтобы проверить, выполнено ли promise(обещание) или нет, мы можем использовать функцию предикат <code>lparallel:fulfilledp</code>. Наконец, функция <code>lparallel:force</code> используется для извлечения значения из обещания(promise). Обратите внимание, что эта функция блокируется до завершения операции.</p>
<p>Давайте сначала закрепим эти концепции на очень простом примере:</p>
<div class="fragment"><div class="line">(defun test-promise ()</div><div class="line">  (let ((p (promise)))</div><div class="line">    (loop</div><div class="line">       do (if (evenp (read))</div><div class="line">              (progn</div><div class="line">                (fulfill p &#39;even-received!)</div><div class="line">                (return))))</div><div class="line">    (force p)))</div></div><!-- fragment --><p>Что генерирует вывод :</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-promise)</div><div class="line">5</div><div class="line">1</div><div class="line">3</div><div class="line">10</div><div class="line">EVEN-RECEIVED!</div></div><!-- fragment --><p>Объяснение: В этом простом примере цикл продолжается бесконечно, пока не будет введено четное число. Обещание(promise) выполняется внутри цикла с помощью <code>lparallel:fulfill</code>, а затем значение возвращается из функции путем принудительного выполнения с помощью <code>lparallel:force</code>.</p>
<p>А теперь давайте рассмотрим более крупный пример. Предполагая, что мы не хотим, чтобы нам приходилось ждать выполнения обещания, а вместо этого чтобы текущий выполнял некоторую полезную работу, мы можем явно делегировать выполнение обещания внешнему, как показано в следующем примере.</p>
<p>Предположим, у нас есть функция, которая возводит в квадрат свой аргумент. И, ради аргумента, на это уходит много времени. Из нашего клиентского кода мы хотим вызвать его и подождать, пока не станет доступно значение в квадрате.</p>
<div class="fragment"><div class="line">(defun promise-with-threads ()</div><div class="line">  (let ((p (promise))</div><div class="line">        (stream *query-io*)</div><div class="line">        (n (progn</div><div class="line">             (princ &quot;Enter a number: &quot;)</div><div class="line">             (read))))</div><div class="line">    (format t &quot;In main function...~%&quot;)</div><div class="line">    (bt:make-thread</div><div class="line">     #&#39;(lambda ()</div><div class="line">         (sleep (random 10))</div><div class="line">         (format stream &quot;Inside thread... fulfilling promise~%&quot;)</div><div class="line">         (fulfill p (* n n))))</div><div class="line">    (bt:make-thread</div><div class="line">     #&#39;(lambda ()</div><div class="line">         (loop</div><div class="line">            when (fulfilledp p)</div><div class="line">            do (return)</div><div class="line">            do (progn</div><div class="line">                 (format stream &quot;~d~%&quot; (random 100))</div><div class="line">                 (sleep (* 0.01 (random 100)))))))</div><div class="line">    (format t &quot;Inside main function, received value: ~d~%&quot; (force p))))</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (promise-with-threads)</div><div class="line">Enter a number: 19</div><div class="line">In main function...</div><div class="line">44</div><div class="line">59</div><div class="line">90</div><div class="line">34</div><div class="line">30</div><div class="line">76</div><div class="line">Inside thread... fulfilling promise</div><div class="line">Inside main function, received value: 361</div><div class="line">NIL</div></div><!-- fragment --><p>Пояснение: В этом примере нет ничего особенного. Мы создаем объект обещания(promise) p и порождаем поток, который спит в течение некоторого случайного времени, а затем выполняет обещание, присваивая ему значение.</p>
<p>Между тем, в основном потоке мы порождаем другой поток, который продолжает проверять, выполнено ли обещание или нет. Если нет, он печатает какое-то случайное число и продолжает проверку. Как только обещание выполнено, мы можем извлечь значение с помощью <code>lparallel:force</code> в основном потоке, как показано.</p>
<p>Это показывает, что обещания могут выполняться разными потоками, в то время как код, создавший обещание, не должен ждать выполнения обещания. Это особенно важно, поскольку, как упоминалось ранее, <code>lparallel:force</code> является блокирующим вызовом. Мы хотим отложить принудительное выполнение обещания до тех пор, пока значение не станет доступным.</p>
<p>Еще один момент, на который следует обратить внимание при использовании обещаний, заключается в том, что после выполнения обещания применение силы к одному и тому же объекту всегда будет возвращать одно и то же значение. То есть обещание может быть успешно выполнено только один раз.</p>
<p>Например:</p>
<div class="fragment"><div class="line">(defun multiple-fulfilling ()</div><div class="line">  (let ((p (promise)))</div><div class="line">    (dotimes (i 10)</div><div class="line">      (fulfill p (random 100))</div><div class="line">      (format t &quot;~d~%&quot; (force p)))))</div></div><!-- fragment --><p>Которая выдает:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (multiple-fulfilling)</div><div class="line">15</div><div class="line">15</div><div class="line">15</div><div class="line">15</div><div class="line">15</div><div class="line">15</div><div class="line">15</div><div class="line">15</div><div class="line">15</div><div class="line">15</div><div class="line">NIL</div></div><!-- fragment --><p>Так чем же будущее(future) отличается от обещания(promise)?</p>
<p><code>lparallel:future</code> - это просто обещание, которое выполняется параллельно, и поэтому оно не блокирует основной поток, как при использовании <code>lparallel:promise</code> по умолчанию. Оно выполняется в собственном потоке (конечно, библиотекой lparallel).</p>
<p>Вот простой пример будущего(future):</p>
<div class="fragment"><div class="line">(defun test-future ()</div><div class="line">  (let ((f (future</div><div class="line">             (sleep (random 5))</div><div class="line">             (print &quot;Hello from future!&quot;))))</div><div class="line">    (loop</div><div class="line">       when (fulfilledp f)</div><div class="line">       do (return)</div><div class="line">       do (sleep (* 0.01 (random 100)))</div><div class="line">         (format t &quot;~d~%&quot; (random 100)))</div><div class="line">    (format t &quot;~d~%&quot; (force f))))</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-future)</div><div class="line">5</div><div class="line">19</div><div class="line">91</div><div class="line">11</div><div class="line">Hello from future!</div><div class="line">NIL</div></div><!-- fragment --><p>Объяснение: Это в точности похоже на пример с <code>promise-with-threads</code>. Однако обратите внимание на два отличия - во-первых, у макроса <code>lparallel:future</code> есть тело. Это позволяет будущему(future) реализоваться! Это означает, что как только тело future будет выполнено, <code>lparallel:fulfilledp</code> всегда будет возвращать true для объекта future.</p>
<p>Во-вторых, само будущее(future) порождается библиотекой в ​​отдельном потоке, поэтому он не мешает выполнению текущего потока, в отличие от promises(обещаний), как можно увидеть в примере с обещанием с потоками (которому требовался явный поток для исполняющего кода, чтобы избежать блокировки текущего потока).</p>
<p>Самым интересным моментом является то, что (даже с точки зрения фактической теории, предложенной Дэном Фридманом и другими), Future(будущее) концептуально является чем-то, что выполняет Promise(обещание). Иными словами, обещание - это контракт о том, что некоторое значение будет создана когда-нибудь в будущем, и будущее(future) - это именно то «нечто», что выполняет эту работу.</p>
<p>Это означает, что даже при использовании библиотеки lparallel основное использование future будет заключаться в выполнении обещания. Это означает, что пользователю не нужно делать такие хаки, как обещание с потоками (promise-with-threads).</p>
<p>Давайте рассмотрим небольшой пример, чтобы продемонстрировать это (должен признать, довольно надуманный пример!).</p>
<p>Вот сценарий: мы хотим прочитать число и вычислить его квадрат. Поэтому мы перекладываем эту работу на другую функцию и продолжаем свою работу. Когда результат будет готов, мы хотим, чтобы он был напечатан на консоли без нашего вмешательства.</p>
<p>Вот как выглядит код:</p>
<div class="fragment"><div class="line">;;; Callback example using promises and futures</div><div class="line">(defun callback-promise-future-demo ()</div><div class="line">  (let* ((p (promise))</div><div class="line">         (stream *query-io*)</div><div class="line">         (n (progn</div><div class="line">              (princ &quot;Enter a number: &quot;)</div><div class="line">              (read)))</div><div class="line">         (f (future</div><div class="line">              (sleep (random 10))</div><div class="line">              (fulfill p (* n n))</div><div class="line">              (force (future</div><div class="line">                       (format stream &quot;Square of ~d = ~d~%&quot; n (force p)))))))</div><div class="line">    (loop</div><div class="line">       when (fulfilledp f)</div><div class="line">       do (return)</div><div class="line">       do (sleep (* 0.01 (random 100))))))</div></div><!-- fragment --><p>И вывод:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (callback-promise-future-demo)</div><div class="line">Enter a number: 19</div><div class="line">Square of 19 = 361</div><div class="line">NIL</div></div><!-- fragment --><p>Объяснение: Хорошо, поэтому сначала мы создаем обещание для хранения квадрата значения, когда оно будет сгенерировано. Это объект p. Входное значение сохраняется в локальной переменной n.</p>
<p>Затем мы создаем объект будущее(future) f. Это future просто возводит в квадрат входное значение и выполняет обещание(promise) с этим значением. Наконец, поскольку мы хотим напечатать вывод в свое время, мы принудительно используем анонимный future, который просто печатает строку вывода, как показано.</p>
<p>Обратите внимание, что это очень похоже на ситуацию в такой среде, как Node, где мы передаем функции обратного вызова другим функциям с пониманием того, что обратный вызов будет вызываться, когда вызванная функция завершит свою работу.</p>
<p>Наконец, обратите внимание, что следующий фрагмент все еще в порядке (даже если он использует блокирующий вызов <code>lparallel:force</code>, потому что он находится в отдельном потоке):</p>
<div class="fragment"><div class="line">(force (future</div><div class="line">(format stream &quot;Square of ~d = ~d~%&quot; n (force p))))</div></div><!-- fragment --><p>Подводя итог, можно сказать, что общая идиома использования такова: <b>определять объекты, которые будут содержать результаты асинхронных вычислений в обещаниях, и использовать будущее(future) для выполнения этих обещаний</b>.</p>
<h3>Использование родственных(cognates) функций - параллельных эквивалентов двойников Common Lisp</h3>
<p>Возможно, родственные функции являются смыслом существования библиотеки lparallel. Эти конструкции действительно обеспечивают параллелизм в lparallel. Однако обратите внимание, что большинство (если не все) из этих конструкций построены на основе будущего(futures) и обещаний(promises).</p>
<p>Короче говоря, cognates(родственные) функции - это просто функции, которые должны быть параллельными эквивалентами своих аналогов в Common Lisp. Однако есть несколько дополнительных параллельных родственных функций, у которых нет эквивалентов Common Lisp.</p>
<p>На данном этапе важно знать, что родственные функции бывают двух основных видов:</p>
<ul>
<li>Конструкции для сильно-дробленого(fine-grained) параллелизма: <code>defpun</code>, <code>plet</code>, <code>plet-if</code>, и т. Д.</li>
<li>Явные функции и макросы для выполнения параллельных операций - <code>pmap</code>, <code>preduce</code>, <code>psort</code>, <code>pdotimes</code> и т. д.</li>
</ul>
<p>В первом случае у нас нет явного контроля над самими операциями. Мы в основном полагаемся на то, что сама библиотека будет оптимизировать и распараллеливать формы, насколько это возможно. В этом посте мы сосредоточимся на второй категории родственных функций.</p>
<p>Возьмем, к примеру, родственную функцию <code>lparallel:pmap</code> точно так же, как эквивалент Common Lisp, <code>map</code>, но она выполняется параллельно. Продемонстрируем это на примере.</p>
<p>Предположим, у нас есть список случайных строк длиной от 3 до 10, и мы хотим собрать их длины в векторе.</p>
<p>Давайте сначала настроим вспомогательные функции, которые будут генерировать случайные строки:</p>
<div class="fragment"><div class="line">(defvar *chars*</div><div class="line">  (remove-duplicates</div><div class="line">   (sort</div><div class="line">    (loop for c across &quot;The quick brown fox jumps over the lazy dog&quot;</div><div class="line">       when (alpha-char-p c)</div><div class="line">       collect (char-downcase c))</div><div class="line">    #&#39;char&lt;)))</div><div class="line"></div><div class="line">(defun get-random-strings (&amp;optional (count 100000))</div><div class="line">  &quot;generate random strings between lengths 3 and 10&quot;</div><div class="line">  (loop repeat count</div><div class="line">     collect</div><div class="line">       (concatenate &#39;string  (loop repeat (+ 3 (random 8))</div><div class="line">                           collect (nth (random 26) *chars*)))))</div></div><!-- fragment --><p>А вот как может выглядеть версия решения с map Common Lisp:</p>
<div class="fragment"><div class="line">;;; map demo</div><div class="line">(defun test-map ()</div><div class="line">  (map &#39;vector #&#39;length (get-random-strings 100)))</div></div><!-- fragment --><p>И давайте проведем тестовый запуск:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-map)</div><div class="line">#(7 5 10 8 7 5 3 4 4 10)</div></div><!-- fragment --><p>А вот эквивалент <code>lparallel:pmap</code>:</p>
<div class="fragment"><div class="line">;;;pmap demo</div><div class="line">(defun test-pmap ()</div><div class="line">  (pmap &#39;vector #&#39;length (get-random-strings 100)))</div></div><!-- fragment --><p>которая производит:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-pmap)</div><div class="line">#(8 7 6 7 6 4 5 6 5 7)</div><div class="line">LPARALLEL-USER&gt;</div></div><!-- fragment --><p>Как вы можете видеть из определений test-map и test-pmap, синтаксис функций <code>lparallel:map</code> и <code>lparallel:pmap</code> точно такой же (ну, почти - <code>lparallel:pmap</code> имеет еще несколько дополнительных аргументов).</p>
<p>Некоторые полезные родственные функции и макросы (все они являются функциями, если они не отмечены так явно. Обратите внимание, что родственных функций довольно много, и я выбрал несколько, чтобы попытаться представить каждую категорию на примере:</p>
<h4>lparallel:pmap: параллельная версия map.</h4>
<p>Обратите внимание, что все функции сопоставления/mapping (<code>lparallel:pmap</code>, <b>lparallel:pmapc</b>,<code>lparallel:pmapcar</code> и т. Д.) Принимают два специальных аргумента ключевого слова.</p><ul>
<li><code>:size</code>, определяющий количество элементов входной последовательности(ей) для обработки, и</li>
<li><code>:parts</code> указывающие количество параллельных частей, на которые нужно разделить последовательность(и).</li>
</ul>
<div class="fragment"><div class="line">;;; pmap - function</div><div class="line">(defun test-pmap ()</div><div class="line">  (let ((numbers (loop for i below 10</div><div class="line">                    collect i)))</div><div class="line">    (pmap &#39;vector #&#39;(lambda (x)</div><div class="line">                      (* x x))</div><div class="line">          :parts (length numbers)</div><div class="line">          numbers)))</div></div><!-- fragment --><p>Пробный прогон:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-pmap)</div><div class="line"></div><div class="line">#(0 1 4 9 16 25 36 49 64 81)</div></div><!-- fragment --><h4>lparallel:por: параллельная версия или.</h4>
<p>Поведение таково, что она возвращает первый элемент, отличный от nil, среди своих аргументов. Однако из-за параллельного характера этого макроса этот элемент меняется.</p>
<div class="fragment"><div class="line">;;; por - macro</div><div class="line">(defun test-por ()</div><div class="line">  (let ((a 100)</div><div class="line">        (b 200)</div><div class="line">        (c nil)</div><div class="line">        (d 300))</div><div class="line">    (por a b c d)))</div></div><!-- fragment --><p>Пробный прогон:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (dotimes (i 10)</div><div class="line">                  (print (test-por)))</div><div class="line"></div><div class="line">300</div><div class="line">300</div><div class="line">100</div><div class="line">100</div><div class="line">100</div><div class="line">300</div><div class="line">100</div><div class="line">100</div><div class="line">100</div><div class="line">100</div><div class="line">NIL</div></div><!-- fragment --><p>В случае обычного оператора or он всегда возвращал бы первый элемент, отличный от nil, а именно. 100.</p>
<h4>lparallel:pdotimes: параллельная версия dotimes.</h4>
<p>Обратите внимание, что этот макрос также принимает необязательный аргумент <code>:parts</code>.</p>
<div class="fragment"><div class="line">;;; pdotimes - macro</div><div class="line">(defun test-pdotimes ()</div><div class="line">  (pdotimes (i 5)</div><div class="line">    (declare (ignore i))</div><div class="line">    (print (random 100))))</div></div><!-- fragment --><p>Пробный прогон:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-pdotimes)</div><div class="line"></div><div class="line">39</div><div class="line">29</div><div class="line">81</div><div class="line">42</div><div class="line">56</div><div class="line">NIL</div></div><!-- fragment --><h4>lparallel:pfuncall: параллельная версия funcall.</h4>
<div class="fragment"><div class="line">;;; pfuncall - macro</div><div class="line">(defun test-pfuncall ()</div><div class="line">  (pfuncall #&#39;* 1 2 3 4 5))</div></div><!-- fragment --><p>Пробный прогон:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-pfuncall)</div><div class="line"></div><div class="line">120</div></div><!-- fragment --><h4>lparallel:preduce: параллельная версия reduce.</h4>
<p>Эта очень важная функция также принимает два необязательных аргумента ключевого слова: <code>:parts</code> (то же значение, что и объяснено) и <code>:recurse</code>. Если: <code>:recurse</code> не равен нулю, она рекурсивно применяет <code>lparallel:preduce</code> к своим аргументам, в противном случае по умолчанию используется reduce.</p>
<div class="fragment"><div class="line">;;; preduce - function</div><div class="line">(defun test-preduce ()</div><div class="line">  (let ((numbers (loop for i from 1 to 100</div><div class="line">                    collect i)))</div><div class="line">    (preduce #&#39;+</div><div class="line">             numbers</div><div class="line">             :parts (length numbers)</div><div class="line">             :recurse t)))</div></div><!-- fragment --><p>Пробный прогон:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-preduce)</div><div class="line"></div><div class="line">5050</div></div><!-- fragment --><h4>lparallel:premove-if-not: параллельная версия remove-if-not.</h4>
<p>По сути, это эквивалентно «filter/фильтру» на языке функционального программирования.</p>
<div class="fragment"><div class="line">;;; premove-if-not</div><div class="line">(defun test-premove-if-not ()</div><div class="line">  (let ((numbers (loop for i from 1 to 100</div><div class="line">                    collect i)))</div><div class="line">    (premove-if-not #&#39;evenp numbers)))</div></div><!-- fragment --><p>Пробный прогон:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-premove-if-not)</div><div class="line"></div><div class="line">(2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54</div><div class="line"> 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100)</div></div><!-- fragment --><h4>lparallel:pevery: параллельная версия every.</h4>
<div class="fragment"><div class="line">;;; pevery - function</div><div class="line">(defun test-pevery ()</div><div class="line">  (let ((numbers (loop for i from 1 to 100</div><div class="line">                    collect i)))</div><div class="line">    (list (pevery #&#39;evenp numbers)</div><div class="line">          (pevery #&#39;integerp numbers))))</div></div><!-- fragment --><p>Пробный прогон:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-pevery)</div><div class="line"></div><div class="line">(NIL T)</div></div><!-- fragment --><p>В этом примере мы выполняем две проверки: во-первых, все ли числа в диапазоне [1,100] четны, а во-вторых, все ли числа в одном диапазоне являются целыми числами.</p>
<h4>lparallel:count: параллельная версия count.</h4>
<div class="fragment"><div class="line">;;; pcount - function</div><div class="line">(defun test-pcount ()</div><div class="line">  (let ((chars &quot;The quick brown fox jumps over the lazy dog&quot;))</div><div class="line">    (pcount #\e chars)))</div></div><!-- fragment --><p>Пробный прогон:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-pcount)</div><div class="line"></div><div class="line">3</div></div><!-- fragment --><h4>lparallel:psort: параллельная версия sort.</h4>
<div class="fragment"><div class="line">;;; psort - function</div><div class="line">(defstruct person</div><div class="line">  name</div><div class="line">  age)</div><div class="line"></div><div class="line">(defun test-psort ()</div><div class="line">  (let* ((names (list &quot;Rich&quot; &quot;Peter&quot; &quot;Sybil&quot; &quot;Basil&quot; &quot;Candy&quot; &quot;Slava&quot; &quot;Olga&quot;))</div><div class="line">         (people (loop for name in names</div><div class="line">                    collect (make-person :name name :age (+ (random 20) 20)))))</div><div class="line">    (print &quot;Before sorting...&quot;)</div><div class="line">    (print people)</div><div class="line">    (fresh-line)</div><div class="line">    (print &quot;After sorting...&quot;)</div><div class="line">    (psort</div><div class="line">     people</div><div class="line">     #&#39;(lambda (x y)</div><div class="line">         (&lt; (person-age x)</div><div class="line">            (person-age y)))</div><div class="line">     :test #&#39;=)))</div></div><!-- fragment --><p>Пробный прогон:</p>
<div class="fragment"><div class="line">LPARALLEL-USER&gt; (test-psort)</div><div class="line"></div><div class="line">&quot;Before sorting...&quot;</div><div class="line">(#S(PERSON :NAME &quot;Rich&quot; :AGE 38) #S(PERSON :NAME &quot;Peter&quot; :AGE 24)</div><div class="line"> #S(PERSON :NAME &quot;Sybil&quot; :AGE 20) #S(PERSON :NAME &quot;Basil&quot; :AGE 22)</div><div class="line"> #S(PERSON :NAME &quot;Candy&quot; :AGE 23) #S(PERSON :NAME &quot;Slava&quot; :AGE 37)</div><div class="line"> #S(PERSON :NAME &quot;Olga&quot; :AGE 33))</div><div class="line"></div><div class="line">&quot;After sorting...&quot;</div><div class="line">(#S(PERSON :NAME &quot;Sybil&quot; :AGE 20) #S(PERSON :NAME &quot;Basil&quot; :AGE 22)</div><div class="line"> #S(PERSON :NAME &quot;Candy&quot; :AGE 23) #S(PERSON :NAME &quot;Peter&quot; :AGE 24)</div><div class="line"> #S(PERSON :NAME &quot;Olga&quot; :AGE 33) #S(PERSON :NAME &quot;Slava&quot; :AGE 37)</div><div class="line"> #S(PERSON :NAME &quot;Rich&quot; :AGE 38))</div></div><!-- fragment --><p>В этом примере мы сначала определяем структурный тип person для хранения информации о людях. Затем мы создаем список из 7 человек со случайным образом сгенерированным возрастом (от 20 до 39). Наконец, мы сортируем их по возрасту в неубывающем порядке.</p>
<h3>Обработка Ошибок</h3>
<p>Чтобы узнать, как lparallel обрабатывает ошибки (подсказка: с <code>lparallel:task-handler-bind</code>), прочтите <a href="https://z0ltan.wordpress.com/2016/09/10/basic-concurrency-and-parallelism-in-common-lisp-part-4b-parallelism-using-lparallel-error-handling/">https://z0ltan.wordpress.com/2016/09/10/basic-concurrency-and-parallelism-in-common-lisp-part-4b-parallelism-using-lparallel-error-handling/</a>.</p>
<h2>Мониторинг и управление потоками с помощью Slime</h2>
<p><b>M-x slime-list-threads</b> (вы также можете получить к нему доступ через <em>slime-selector</em>, ярлык <b>t</b>) будет перечислять запущенные потоки по их именам и их статусам.</p>
<p>Поток в текущей строке можно убить с помощью <b>k</b>, или, если нужно убить много потоков, можно выбрать несколько строк, и <b>k</b> уничтожит все потоки в выбранной области.</p>
<p><b>g</b> обновит список потоков, но когда у вас много запускаемых и останавливающихся потоков, может быть слишком громоздко всегда нажимать <b>g</b>, поэтому есть переменная <code>slime-threads-update-interval</code>, когда установлено число X, список потоков будет будут автоматически обновляться каждые X секунд, разумным значением будет 0.5.</p>
<p>Thanks to <a href="https://slime-tips.tumblr.com/">Slime tips</a>.</p>
<h2>Ссылки</h2>
<p>Конечно, существует гораздо больше функций, объектов и идиоматических способов выполнения параллельных вычислений с использованием библиотеки lparallel. Этот пост даже поверхностно об этом не говорит. Однако здесь подробно демонстрируется общий процесс работы, и для дальнейшего чтения вам могут быть полезны следующие ресурсы:</p>
<ul>
<li><a href="https://lparallel.org/">The official homepage of the lparallel library, including documentation</a></li>
<li><a href="https://www.lispworks.com/documentation/HyperSpec/Front/">The Common Lisp Hyperspec</a>, and, of course</li>
<li>Your Common Lisp implementationâs manual. <a href="http://www.sbcl.org/manual/">For SBCL, here is a link to the official manual</a></li>
<li><a href="http://weitz.de/cl-recipes/">Common Lisp recipes</a> by the venerable Edi Weitz.</li>
<li>more concurrency and threading libraries on the <a href="https://github.com/CodyReichert/awesome-cl#parallelism-and-concurrency">Awesome-cl#parallelism-and-concurrency</a> list. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

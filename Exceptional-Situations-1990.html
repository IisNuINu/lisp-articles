<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>``Исключительные ситуации в Лиспе'' by Kent Pitman (March, 1990)</title>
<meta http-equiv="Keywords" content="Conditions, Errors, Exceptions, Handling, Lisp, Signalling, Signaling">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta name="robots" content="index, nofollow">
</head>
<body vlink="#7700bb" text="#440077" link="#7700bb" bgcolor="#eeeeff" alink="#ff0000">

<font color="green">

<h1 align="CENTER">Исключительные ситуации в Лиспе</h1>

<p align="CENTER">
<b>This paper appears in the proceedings for the<br>
First European Conference on the Practical Application of Lisp (EUROPAL'90),<br>
Churchill College, Cambridge, UK, March 27-29, 1990.<br>
It won a "Best Paper" award (Tools &amp; Techniques category).
</b>
</p>

<p>
 The substance of the original text appears in normal fonting,
 though a small number of out-and-out typos were corrected.
 Oddities of spelling that were the custom of the time
 (either generally, or just for me) were left alone.
 Some formatting of headings and tables was adjusted slightly for HTML.
 Any new text that has been added appears
 bracketed and in color green; such text is intended to
 help clarify the historical context, since considerable time 
 passed between the time this paper was published and the time I 
 converted it to HTML.<br>
--<a href="http://www.nhplace.com/kent/contact-kent.html"><i>Kent Pitman</i></a>, 17-Oct-1998.
</p>

<p align="CENTER">
<a href="#ORIGINAL-START">Annotated original document follows.</a><br>
<a href="http://www.nhplace.com/kent/Papers/index.html"><i>Click here for an index 
of other titles by Kent Pitman.</i></a>
</p>

</font>

<hr>

<a name="ORIGINAL-START"><h1 align="CENTER">Исключительные ситуации в Лиспе</h1></a>

<p align="CENTER"><b>Kent M. Pitman</b></p>

<p align="CENTER">
<font size="2" color="green">[address at time of publication]</font><br>
Symbolics, Inc.<br>
8 New England Executive Park, East<br>
Burlington, MA  01803-5007  U.S.A.</p>

<h2 align="CENTER">Абстрактно</h2>

<p>
Полезно разделить описание поведения программы на две части - что происходит 
в нормальных ситуациях и что происходит в исключительных ситуациях. В этой 
статье рассматриваются вопросы, связанные с описанием поведения программы 
в исключительных ситуациях.
</p>

<p><b>Keywords:</b> 
Conditions, Errors, Exceptions, Handling, Lisp, Signalling.</p>

<p>Copyright Â© 1990, 1985 Kent M. Pitman.
   All Rights Reserved.
<font color="green">
   <br>
   [HTML document Copyright Â© 1999 Kent M. Pitman.
   All Rights Reserved.]
</font>
</p>

<hr width="50%" align="CENTER">

<h2>I. Введение</h2>

<p>Во время вычислений функции взаимодействуют друг с другом, передавая аргументы, 
возвращая значения и используя побочные эффекты для общих(Разделяемых) структур. 
Рассмотрим следующие определения: </p>

<table width="95%" align="CENTER">
<tbody><tr>
<td valign="TOP">
<tt>(+ <i>n1</i> <i>n2</i>)</tt>
</td>
<td valign="TOP">
возвращает сумму своих аргументов, <i>n1</i> и <i>n2</i>.
<p></p>

</td>
</tr>
<tr>
<td>&nbsp;</td><td>&nbsp;</td>
</tr>

<tr>
<td valign="TOP">

<p><tt>(READ-CHAR <i>instream</i>)</tt>
</p>

</td>
<td valign="TOP">
возвращает следующий символьный знак во входном потоке,  <i>instream</i>. 
Эта функция выполняет неявный побочный эффект с <i>instream</i>, обычно увеличивая 
некоторый внутренний указатель сканирования, чтобы гарантировать, что последующие 
попытки чтения из того же потока не будут пытаться повторно прочитать тот же символьный
знак.
<p></p>

</td>
</tr>

</tbody></table>

<p>
Приведенные выше описания <tt>+</tt> и <tt>READ-CHAR</tt> описывают 
их поведение в том, что мы будем называть <a name="normsit"><b>нормальной ситуацией</b></a>. 
Однако иногда возникает <a name="#excepsit"><b>exceptional situation(исключительная 
ситуация)</b></a>, которая не вписывается в обычное  описание функции. Например, 
<tt>+</tt> может получить аргумент, который не является числом, или <tt>READ-CHAR</tt> 
может получить поток, в котором больше нет доступных символьных знаков.
</p>

<p>В этой статье исследуются феномены исключительных ситуаций и 
методы программирования, которые можно использовать для работы 
с такими ситуациями. </p>

<h2>II. Природа исключительных ситуаций</h2>

<p>Важно понимать, что это различие между нормальными и исключительными 
ситуациями в некотором смысле надумано. Проведение этого различия не 
меняет поведения программ; оно просто меняет наши представления о 
программах - надеюсь, к лучшему.</p>

<p>
Обычно мы думаем о <tt>+</tt> как о функции, которая складывает два числа, 
но представьте на мгновение, что, когда она получает нечисловой аргумент, 
она просто возвращает false </p>

<a href="#FNOTE1">[1]</a>.  Мы могли бы определить, что это 
«нормально», когда <tt>+</tt> возвращает «либо сумму двух своих аргументов, 
если они числа, либо ложь, если это не так». Это не изменило бы того, что 
сделал <tt>+</tt>, а только то, как мы думали об этом. Вместо того, чтобы
быть просто функцией, возвращающей число, <tt>+</tt> стал бы функцией, 
возвращающей либо число, либо <tt>NIL</tt>. В общем, любая программа, 
которая потенциально может быть описана в терминах нормальных и исключительных 
ситуаций, также может быть описана только нормальным описанием, просто взяв 
некоторое объединение этих нормальных и исключительных описаний и 
объявив это объединение нормальным.


<p></p>

<p>Однако, если бы мы заявили, что было «нормально» использовать <tt>+</tt> с 
нечисловым аргументом, то мы должны были бы как нормальное использовать такое 
использование, как </p>

<center>
<pre align="">(+ 'A 'B)
</pre>
</center>

<p>где программист явно обозначил <tt>+</tt> нечисловой функцией, потому что 
он планировал воспользоваться тем фактом, что это приведет к ложному результату. 
(Возможно, программист не знает, что переменная NIL содержит ложный объект, 
и это выражение кодирует его желание произвести NIL в качестве значения.) 
Каким-то образом мы хотим отговорить программиста от использования 
<tt>+</tt> таким образом, и один из способов сделать это просто описать 
такое использование как «ненормальное».
</p>

<p>В оставшейся части этого раздела мы рассмотрим некоторые из конкретных 
преимуществ, которые дает это, по общему признанию, надуманное различие между 
нормальными и исключительными ситуациями. </p>

<h3><a name="simpl">Упрощение предположений</a></h3>

<p>Одна из причин различать нормальные и исключительные ситуации проявляется 
в использовании упрощающих допущений, которые обычно отличают прототип от 
программы производственного качества. Программист может ускорить разработку программы, 
предположив, что программа понадобится только для некоторых нормальных случаев. 
Например, токенизатор для парсера может быть изначально закодирован так, чтобы просто 
читать символы из потока до разрыва токена, без обработки исключительной ситуации, 
которая возникает в конце файла, когда нет следующего символа. Поступая так, 
программист избавляется от беспокойства об уровне детализации, который отвлекает 
только на этапе прототипирования. Позже, после того как было показано, что программа
удовлетворительно работает в нормальных ситуациях, программист может «подтянуть» 
программу для обработки исключительных ситуаций. Эта идея подробно исследована в   
<a href="#Rich-81">[Rich 81]</a> и <a href="#Lieberman-82">[Lieberman 82]</a>.</p>

<h3>Представление</h3>

<p>
Упрощение предположений также может быть важным после разработки программы - 
когда ее читает другой программист. Человек, читающий код, может захотеть 
сначала понять, что он делает в нормальной ситуации, а затем уточнить 
свое понимание этого кода, изучив его поведение в исключительных ситуациях. 
Если код для работы с нормальной ситуацией сильно перемежается с кодом, 
пытающимся распознать и справиться с исключительными ситуациями, способность 
читателя расшифровать намерение программы может быть значительно уменьшена.
</p>

<p>
С этой проблемой можно справиться как минимум двумя способами. Один из способов - 
создать в языке конструкции, которые поощряют разделение кода для работы с нормальными 
и исключительными ситуациями. Другой способ - предоставить технологию редактирования, 
которая позволяет скрыть код для исключительных ситуаций, в то время как нормальная 
ситуация исследуется сама по себе. Даже в случае использования технологии редактирования 
существенно помогает наличие поддержки на уровне языка для этого разделения, 
которое может служить руководством для инструментов редактирования. 
</p>

<h3><a name="modul">Модульность</a></h3>

<p>Идея о том, что язык должен поощрять разделение нормальных и исключительных 
ситуаций, привлекает еще по одной причине. Часто случается, что одна и та же 
исключительная ситуация может возникнуть во многих разных местах программы; 
и, во многих случаях, то, как с ней следует обращаться, одинаково во всей 
программе.</p>

<p>Например, рассмотрим программу, которая компилирует файл с удаленного 
компьютера. Если удаленная машина выйдет из строя, компиляция, вероятно, 
просто потерпит неудачу независимо от того, какая процедура выполнялась. 
Языки должны обеспечивать некоторый способ централизации информации о 
поведении программы в такой исключительной ситуации, чтобы ее не приходилось 
без необходимости повторять во всем коде программы.</p>

<p>
В языках, в которых нет встроенной поддержки обработки условий, информация 
должна передаваться обратно из каждой программы, чтобы указывать на успех 
или неудачу. Постоянная необходимость явно разбираться с кодами ошибок в 
лучшем случае утомительна и отвлекает, а в худшем - очень опасна. Некоторые 
программисты склонны небрежно проверять такие коды во всех случаях, когда 
они должны, и это может привести к ненадежной связи между программами. 
</p>

<h3><a name="effic">Эффективность</a></h3>

<p>
В некоторых случаях могут быть веские причины для рассмотрения некоторых случаев 
в качестве исключительных. Например, скомпилированный код для <tt>+</tt> будет 
менее эффективным, если он должен содержать явные проверки на то, что его аргументы 
не являются числами. В Maclisp <a href="#Pitman-83">[Pitman 83]</a> 
<a href="#FNOTE2">[2]</a>, например, интерпретируемая функция <tt>+</tt> будет 
"сигнализировать об ошибке", если вызывается с неверными аргументами, но
 скомпилированные вызовы <tt>+</tt> будут просто "делать неправильные вещи", 
если возникнет такая ситуация <a href="#FNOTE3">[3]</a>.</p>

<p>
Казалось бы, было бы полезно разрешить компилятору выполнять такого рода 
оптимизацию, но компилятору нельзя позволять жертвовать правильной семантикой 
ради эффективности.
</p>

<p>
Чтобы избежать любой вероятности того, что действия хорошего компилятора 
могут быть сочтены непредсказуемыми или иррациональными, мы должны поставить 
перед собой цель описывать функции таким образом, чтобы оптимизация компилятора 
не нарушала ожиданий программиста. Проводя различие между нормальными и 
исключительными ситуациями, мы можем достичь этой цели. Определение <tt>+</tt> 
потенциально скомпрометировано только в исключительной ситуации -- его семантика 
всегда будет сохраняться для нормальной ситуации, даже в высокооптимизированном коде. 
Если бы мы не сделали этого различия, нам пришлось бы либо заставить <tt>+</tt> 
выполнять дополнительную работу в скомпилированном коде, либо описать процесс 
компиляции <tt>+</tt> как "unreliable"(ненадежный).
</p>

<h2><a name="currprac">III. Работа в исключительных ситуациях</a></h2>

<p>Когда в программе возникает исключительная ситуация, можно предпринять 
ряд возможных действий.</p>

<h3><a name="ignor">Игнорирование исключительных ситуаций</a></h3>

<p>Наше описание исключительных ситуаций является достаточно общим, 
чтобы включить ситуации, которые не являются нормальными, но которые 
программа не распознает как таковые. Пример того, как скомпилированные 
вызовы <tt>+</tt> ведут себя в Maclisp, является примером такого 
поведения. Следовательно, один из возможных способов решения 
исключительных ситуаций в программах - неспособность их распознать.</p>

<p>Хотя такой сбой не может быть чем-то поощряемым как стиль 
программирования, важно понимать, что он действительно происходит - 
на самом деле, часто. Это может произойти в любое время, когда 
в коде делается какое-либо предположение, но оно не проверяется 
механически (либо во время компиляции, либо во время выполнения).</p>

<h3><a name="modretval">Измененные соглашения о возвращаемых значениях</a></h3>

<p>В некоторых ситуациях тип возвращаемого значения сильно ограничен. 
Например, поскольку мы знаем, что многие операции с числами дают только 
другие числа, мы могли бы использовать нечисловые возвращаемые значения 
из таких функций для передачи других видов информации. Наше более раннее 
предположение, что <tt>+</tt> может возвращать false при передаче нечисловых 
аргументов, является примером этой техники. Хотя этот метод не является 
полностью универсальным, он явно полезен в статистически(т.е досточно
часто встречаемых) интересных случаях.</p>

<p>Несколько более сложный вариант этой техники возникает с примитивом 
Maclisp <tt>ERRSET</tt>. <tt>ERRSET</tt> вычисляетт свой аргумент, 
"trapping"(улавливая) любые ошибки. Разработчики <tt>ERRSET</tt> хотели 
вернуть результат вычисления, если ошибки не было, но также иметь 
возможность определить, была ли ошибка или нет. Поскольку вычисление 
могло возвращать любой отдельный объект, их задача заключалась в том, 
чтобы разработать соглашение о возвращаемых значениях, которое однозначно 
выражало бы обе эти части информации. Их решение состояло в том, чтобы 
вернуть NIL, если произошла ошибка, или список, первый элемент которого 
был результатом вычисления, если ошибки не было. </p>

<pre>(ERRSET (OPEN "NOSUCHFILE.TXT"))
 -&gt; NIL

(ERRSET (OPEN "FILE.TXT"))
 -&gt; (#FILE-IN-|FILE.TXT|-70766)
</pre>

<h3><a name="nretvals">Множественные возвращаемые значения</a></h3>

<p>
Решение этой «проблемы <tt>ERRSET</tt>» в Zetalisp <a href="#Weinreb-81">[Weinreb 81]</a> 
несколько более изящно, потому что функция может просто возвращать несколько значений. 
Zetalisp предоставляет макрос <tt>IGNORE-ERRORS</tt>, который вычисляет свой аргумент 
и возвращает результат (или <tt>NIL</tt>, если возникает ошибка) в качестве своего 
«первого возвращаемого значения». Поскольку случай возврата <tt>NIL</tt> в этой позиции 
неоднозначен (форма могла сама вернуть <tt>NIL</tt> или всё же могла произойти ошибка), 
она также возвращает «второе возвращаемое значение», которым является <tt>NIL</tt>, 
если ошибки не было, или отличное от <tt>NIL</tt> в противном случае. 
</p>

<pre>(IGNORE-ERRORS (OPEN "NOSUCHFILE.TXT"))
 -&gt; NIL, T

(IGNORE-ERRORS (OPEN "FILE.TXT"))
 -&gt; #&lt;INPUT-STREAM "FILE.TXT" 3370754&gt;, NIL
</pre>

<h3><a name="transctrl">Множественные точки возврата (лексические)</a></h3>

<p>В частности, в Scheme <a href="#Steele-78">[Steele 78]</a> популярным способом 
работы с исключительными ситуациями является простая передача нескольких продолжений 
<a href="#Steele-76">[Steele 76]</a>.</p>

<p>Например, мы могли бы представить, что наш предыдущий случай <tt>READ-CHAR</tt> 
можно переформулировать, заставив <tt>READ-CHAR</tt> принимать дополнительные 
аргументы функций, которые должны быть вызваны в случае, если есть или нет 
«следующий символьный знак». Рассмотрим гипотетическое определение Scheme: 
</p>

<pre>(DEFINE (READ-CHAR STREAM SUCCESS FAIL)
  (IF (STREAM-EMPTY? STREAM)
      (FAIL)
      (SUCCESS (STREAM-FIRST STREAM)
               (STREAM-REST STREAM))))
</pre>

<p>что позволит в вызывающем коде написать: </p>

<pre>(DEFINE (VIEW-STREAM STREAM)
  (READ-CHAR STREAM
             (LAMBDA (FIRST-CHAR REST-OF-STREAM)
               (WRITE-CHAR FIRST-CHAR)
               (VIEW-STREAM REST-OF-STREAM))
             (LAMBDA () 'DONE)))
</pre>

<p>В этом случае нормальные и исключительные ситуации выделены в отдельные 
функции, чтобы их можно было изучать независимо.</p>

<h3>Множественные точки возврата (динамические)</h3>

<p>Иногда между группой программ может быть установлено соглашение, 
так что при обнаружении определенных исключительных ситуаций управление 
передается динамически установленной точке в цепочке вызовов. Такая 
нелокальная передача управления обычно выполняется примитивом <tt>THROW</tt> 
в Лиспе.</p>

<p>
Также в эту категорию входят механизмы, которые некоторые языки предоставляют 
для <b>aborting</b>(прерывания) и <b>restarting</b>(перезапуска) вычислений. 
Обычно это просто «синтаксический сахар» для того же вида нелокальной передачи 
управления, уже предусмотренной <tt>THROW</tt>. Например, функция Maclisp 
<tt>^G</tt> <a href="#FNOTE4">[4]</a> "throws"(перебрасывает) в точку, которая 
перезапускает цикл чтения-вычисления-печати(Read-Eval-Print loop) верхнего уровня.
</p>

<h2><a name="newterms">IV. Терминология</a></h2>

<p>
В современных диалектах Лиспа мы поощряем использование <tt>DEFSTRUCT</tt> 
и <tt>DEFCLASS</tt> и связанных с ними аксессоров и конструкторов, а не 
<tt>CAR</tt>, <tt>CDR</tt> и <tt>CONS</tt>, потому что они позволяют нам 
уйти от размышлений о том, как реализуются объекты, и позволяют нам говорить 
напрямую в терминах более абстрактных свойства объектов. Как мы видели, 
Lisp на примитивном уровне предоставляет множество способов реализации 
обработки исключительных ситуаций, но кажется не менее важным, чтобы мы 
разработали надлежащие абстракции для описания и рассуждения об исключениях. 
</p>

<h3>Signalling/Сигнализация
</h3>

<p>
Когда программа обнаруживает исключительную ситуацию, она обычно хочет 
"announce"(объявить) о наличии ситуации, позволяя запускать любой специальный код, 
настроенный для работы с этой ситуацией. Мы будем называть этот процесс объявления 
исключительной ситуации <b>signalling</b>(сигнализацией), а фрагмент кода, который 
объявляет ситуацию, <b>signaller</b>(сигнализатором).
</p>

<p>
Класс исключительных ситуаций, которые распознаются и сигнализируются, в 
дальнейшем будет называться <b>conditions</b>(условиями).</p>

<p>
Мы будем думать о сигнализации как о способе «остановки» программы и 
запросе совета о том, какой выбрать из нескольких способов "restart"(перезака). 
Эти возможные способы перезапуска будут называться <b>restart options</b>(опциями 
перезапуска) <a href="#FNOTE5">[5]</a>.
</p>

<h3>Handling/Обработка</h3>

<p>
Куски кода, которым предлагается выбрать вариант перезапуска, будут 
называться обработчиками. Если обработчик выполняет нелокальную передачу 
управления (за пределы точки сигнала), будет сказано, что он <b>handled</b>(обработал) 
ситуацию. В противном случае будет сказано, что он <b>declined</b>(отказался).</p>

<h3>Types of Situations/Типы ситуаций</h3>

<p>
Некоторые условия не фатальны в том смысле, что неспособность их обработать 
не повлияет на правильное поведение программы, если она просто продолжится. 
Некоторые распространенные примеры мест, где может потребоваться сигнализация 
нефатальных состояний: исключения "end of line"(конец строки) и 
"end of page"(конец страницы) на устройствах вывода, вход и выход из основных 
и второстепенных режимов в редакторе, успешное завершение подзадач. в 
многозадачном проекте или в ситуациях, if-needed(если необходимо) и 
if-used(если используется) в системе представления знаний. Эти нефатальные 
состояния иногда называют "hooks"(хуками/крючками), потому что существует 
четко определенное поведение, которое может произойти, если совет не 
предоставлен, но они предлагают место для "hang"(зависания/прикрепления) совета, 
которое будет дополнять или отменять поведение по умолчанию. 
</p>

<p>
Некоторые ситуации могут считаться <b>fatal</b>(фатальными) в том смысле, 
что код не должен перезапускаться после того момента, когда они сигнализируются, 
если условие не "corrected"(исправлено) какой-либо формой внешнего вмешательства. 
Мы будем называть такую фатальную ситуацию <b>error situation</b>(ситуацией ошибки)
или <b>error</b>(ошибкой).
</p>

<p>
Ситуации с ошибками, иногда называемые "bugs"(баги/ошибки), можно разделить
на два класса: ошибки, которые обнаруживаются и сигнализируются, которые мы 
будем называть <b>error conditions</b>(ошибочными условиями/состояниями);
и ошибки, которые остаются незамеченными (обычно только для того, чтобы 
вызвать путаницу при выполнении программы).
</p>

<p>

Common Lisp <a href="#Steele-84">[Steele 84]</a> тщательно проводит 
различие между двумя типами ошибочных ситуаций, используя терминологию 
"is an error"(является ошибкой), когда об ошибке может сообщаться 
(но это не гарантируется), и "signals an error"(сигнализирует об ошибке)
для обозначения ситуаций, когда гарантированно будет сообщено об ошибке. 
Эти термины прямо соответствуют нашим терминам "error
situation"(ситуация ошибки) и "error condition"(состояние ошибки). 
</p>

<h2>V. Signalling/Сигнализация</h2>

<p>
Теперь перейдем к вопросу о том, какая информация должна сопровождать сигнал. 
Здесь может быть полезно обратиться к довольно конкретному примеру.
</p>

<p>
Давайте представим ситуацию в программе управления для робота-дворецкого, 
который собирается положить еду на стол, когда робот замечает, что яйца, 
которые он собирается подать, зеленые. Можно представить, что код 
сигнализатора об этом будет выглядеть примерно так: 
</p>

<pre>To Serve a Tray-of-Food:
 For each Food in the Tray-of-Food,
   If the Food's Color is not
      the Food's Expected-Color,
     Signal a Bad-Food-Color condition
       specifying the Food,
                  its Color, and
                  its Expected-Color.
 Carry the Tray-of-Food to the Dining-Room.
 Place the Tray-of-Food on the Table.
</pre>

<p>
К сожалению, «код» не предоставляет достаточно информации для потенциального 
обработчика, чтобы посоветовать ему, как продолжить работу после того момента, 
когда сообщается об ошибке. Поскольку обработчик может не иметь доступа к 
структурам данных, необходимым для исправления проблемы, и поскольку сигнализатор 
не предоставил «код» для реализации каких-либо исправлений, множественные 
стратегии исправления, как правило, будут невозможны.
</p>

<p>
По этой причине, когда сигнализируется условие, мы должны помнить, 
что может потребоваться информация двух видов: описание условия и 
описание того, что, если что-то, сигнализатор готов сделать, чтобы 
перезапустить остановленное вычисление.
</p>

<p>
В случае, если перезапуск возможен, приведенного выше кода недостаточно. Что может понадобиться, может выглядеть примерно так: 
</p>

<pre>To Serve a Tray-of-Food:
 For each Food in the Tray-of-Food
   If the Food's Color is not
      the Food's Expected-Color,
     Signal a Bad-Food-Color condition
       specifying the Food,
                  its Color, and
                  its Expected-Color
       and heeding advice on which of
           the following ways to restart:
         To Add-Food-Coloring
              of a given Color:
           Put Food-Coloring
             of the given Color
             into the Food;
         To Serve-Food-Anyway:
           Continue;
         To Throw-Food-Away:
           Remove the Food
             from the Tray-of-Food.
 Carry the Tray-of-Food to the Dining-Room.
 Place the Tray-of-Food on the Table.
</pre>

<h2>VI. Handling/Обработка</h2>

<p>
Когда сигнализируется условие, могут существовать обработчики, 
которые потенциально могут обработать ошибку. Мы отложим на время 
вопрос о том, как расположены такие обработчики, а пока займемся 
вопросом, что эти обработчики захотят делать после того, как они 
будут обнаружены.
</p>

<p>
Неформально мы можем думать о обработчике как об аналоге мудрого совета. 
Но, как и любой совет, могут быть моменты, когда это уместно, а иногда - нет. 
Некоторые из этих случаев могут частично определяться вопросами scope(области действия), 
которые будут обсуждаться позже; другие будут определены путем изучения 
описания условия/состояния и доступных вариантов, предложенных сигнализатором. 
</p>

<p>
Необходимо будет предусмотреть некоторые соответствующие средства для 
проверки состояния. В Maclisp предоставляемые средства <a href="#FNOTE6">[6]</a> 
представляют собой функцию для проверки состояния условия в текущем 
(или заданном) кадре стека. Это затрудняло тестирование обработчиков условий 
вне контекста. Опыт работы с Zetalisp показывает, что объектно-ориентированный 
подход (когда обработчик получает аргумент, представляющий описание условия, 
и ему предоставляются средства проверки этого объекта) является более гибким.
</p>

<p>
После ознакомления с описанием обработчик может захотеть выполнить любое 
из нескольких действий. Например, чтобы продолжить наш предыдущий сценарий 
с роботом:
</p>

<ul>
<li>Он может указать на то, что в любом случае можно подавать еду.</li>
<li>Он может указать, что еду не подают.</li>
<li>Он может указать на изменение цвета еды.</li>
<li>Он может предложить заменить еду другой едой.</li>
<li>Он может предложить заменить еду «лучшей» едой того же типа. </li>
</ul>

<p>
Эти пункты включают в себя советы о том, как <b>restart</b>(перезапустить). 
Чтобы дать такой совет, обработчик должен убедиться, что конкретный вариант 
перезапуска, который он предлагает, приемлем для сигнализатора.
</p>

<p>
Независимо от ситуации сигнализатора, обработчик всегда может 
<b>decline</b>(отказаться) обработать условие.
</p>

<ul>
<li>Он может сказать, что у него нет предложений о том, как перезапустить. </li>
</ul>

<p>Также, независимо от ситуации, обработчик всегда может справиться 
с ситуацией, полностью ее обойдя. Например:</p>

<ul>
<li>Он может взорвать здание(строение).
</li>
</ul>

<p>
Снос здания, содержащего нашу гипотетическую проблему с продуктами питания, 
аналогичен тому, что происходит во время нелокальной передачи управления из 
кадра стека, который сигнализирует об ошибке. Ситуация разрешается, стирая 
некоторый внешний контекст, в котором ситуация возникла в первую очередь. 
</p>

<h3>Provisional Handling/(Предварительная/Временная обработка)
</h3>

<p>
Возможно, потребуется дать некоторые рекомендации в предварительном порядке. 
Например, обработчик может захотеть сказать: "Если вы не можете найти ничего лучшего, 
чтобы направило вас, у меня есть несколько советов. Тем не менее, я бы предпочел, 
чтобы вы сначала спросили у других совета и вернулись ко мне только в крайнем случае".
</p>

<p>
В Zetalisp макрос  <tt>CONDITION-BIND-DEFAULT</tt> решает эту проблему, 
но заставляет принимать решение о том, должен ли совет быть предварительным 
или нет, во время кодирования (когда пользователь должен выбрать между 
<tt>CONDITION-BIND</tt> и <tt>CONDITION-BIND-DEFAULT</tt>), а не позволяет 
пользователю отложить это решение до выполнения.
</p>

<p>
В любой системе, где могут быть установлены обработчики по умолчанию, 
возникает вопрос, как разрешить ситуацию, когда были заявлены два 
значения по умолчанию. В Zetalisp, когда сигнал не обрабатывается обычными 
связанными обработчиками (настроенными с помощью <tt>CONDITION-BIND</tt>), 
обработчики по умолчанию (настроенные с помощью <tt>CONDITION-BIND-DEFAULT</tt>) 
ищутся изнутри (вдоль динамической цепочки вызовов), пока не будет найден 
обработчик. <a href="#FNOTE7">[7]</a>.
</p>

<p>
Формирующийся стандарт ANSI Common Lisp позволяет программисту сигнализировать 
о состоянии из обработчика. Эта способность позволяет достичь мощности Zetalisp 
<tt>CONDITION-BIND-DEFAULT</tt>, используя форму, подобную <a href="#FNOTE8">[8]</a>:
</p>

<pre>(HANDLER-BIND ((type1
                 #'(LAMBDA (C)
                     (SIGNAL C)
                     ... default advice ...
                     )))
  form1 form2 ...)
</pre>

<p>
В приведенном выше сценарии использование <tt>SIGNAL</tt> эффективно защищает 
рекомендацию по умолчанию: возникает рекурсивный сигнал о условии. Если 
рекурсивный сигнал обрабатывается, то рекомендация по умолчанию никогда не 
будет достигнута. Если рекурсивный сигнал не обрабатывается, вызов <tt>SIGNAL</tt> 
возвращается и выполняется рекомендация по умолчанию. В отличие от подхода Zetalisp, 
новый подход Common Lisp позволит принимать решение о том, является ли совет 
"по умолчанию" динамически во время выполнения программы, а не статически во 
время написания программы.
</p>

<h3>Classifying Conditions/Условия классификации</h3>

<p>
Когда обработчик условий пытается определить, применимы ли его рекомендации 
в данной ситуации, ему может значительно помочь доступность иерархии классов 
для типов условий. Например, общий совет, подходящий для ошибки «файл», может 
быть признан подходящим для более конкретной ошибки «файл не найден» с 
использованием такого механизма.
</p>

<p>
Опыт работы с системой условий Zetalisp показал, что это ситуация, 
когда доступность нескольких суперклассов для типов условий почти необходима. 
Некоторые ошибки не укладываются в строгую иерархию; например, если из функции 
READ поступает сигнал об ошибке «конец файла», является ли это ошибкой 
«синтаксического анализа» или ошибкой «потока»? Если тип условия может иметь 
несколько суперклассов, ошибка «конца файла» может быть унаследована от обоих 
ошибок более общих типов «синтаксического анализа» и «потока»  . Эта функция дает 
операторам большую гибкость при принятии решения о том, какие условия они готовы 
посоветовать. 
</p>

<h3>Classifying Restart Options/Классификация вариантов перезапуска</h3>

<p>
Некоторые советы могут быть более конкретными, чем другие. Например, предположим, 
что обработчик нашего условия <tt>Bad-Food-Color</tt>(Плохой-пищевой-краситель)
хочет предложить изменить пищевой краситель, и сигнализатор готов к 
<tt>Add-Food-Coloring</tt>(Добавить-пищевой-краситель»). Возможно, потребуется 
некоторое понятие иерархии классов для параметров перезапуска, чтобы 
<tt>Add-Food-Coloring</tt> распознавался как подходящая замена для 
<tt>Change-Color</tt> <a href="#FNOTE9">[9]</a>.
</p>

<h2>VII. Connecting Signallers with Handlers/Связь сигнализаторов с обработчиками</h2>

<p>
Когда сигнализируется условие, возникают некоторые вопросы о том, как должен 
быть расположен соответствующий обработчик. 
</p>

<h3>Scope of Handlers(Область видимости/действия обработчиков)</h3>

<p>
Первое, что нужно сделать, - это определить должны ли обработчики условий быть 
"globally assigned"(глобально назначенными) или "locally bound"(локально привязанными).
</p>

<p>
Тенденция в программировании явно направлена на отказ от любого понятия 
«глобального» присваивания в пользу операторов, которые связывают вещи. 
Следовательно, недавние диалекты Lisp с большей вероятностью будут 
предоставлять операторы с именами вроде <tt>CONDITION-BIND</tt>, которые 
предоставляют обработчики для условий в определенной области действия/видимости
<a href="#FNOTE10">[10]</a>, чем операторы с именами вроде <tt>CONDITION-SET</tt>, 
которые имеют побочный эффект некоторого «глобального» обработчика по умолчанию.
</p>

<p>
В Zetalisp, например, макрос <tt>CONDITION-BIND</tt> делает набор 
обработчиков доступным в динамическом контексте выполнения своего тела. 
Он также выполняет дополнительную услугу по разделению применимости 
обработчиков в соответствии с типом условия. Например, форма 
</p>

<pre>(CONDITION-BIND ((type1 handler1)
                 (type2 handler2) ...)
  form1 form2 ...)
</pre>

<p>
будет пытаться использовать данный обработчик для сигналов, сгенерированных 
в его теле, только если эти сигналы имеют связанный тип (или некоторый 
подкласс этого типа).
</p>

<p>
Если бы обработчики не были разделены по типам, каждый обработчик должен 
был бы динамически определять, какие из них применимы. На практике это, 
вероятно, привело бы к излишне раздутому и очень идиоматическому использованию 
кода, например: 
</p>

<pre>(HYPOTHETICAL-CONDITION-BIND
        (#'(LAMBDA (CONDITION)
             (COND   ((TYPEP CONDITION 'type1)
                      (FUNCALL handler1 
                               CONDITION))
                     (T (DECLINE CONDITION))))
         #'(LAMBDA (CONDITION)
             (COND   ((TYPEP CONDITION 'type2)
                      (FUNCALL handler2 
                               CONDITION))
                     (T (DECLINE CONDITION))))
         ...)
  form1 form2 ...)
</pre>

<h3>Global Handling/Глобальная Обработка</h3>

<p>
Можно представить себе возможность связывания вновь определенного типа условия 
с <b>global handler</b>(глобальным обработчиком) для условий этого типа. В диалектах 
Лиспа, предоставляющих некую универсальную функцию или средство передачи сообщений, 
это может быть реализовано как метод для объектов этого типа условия, который вызывается 
только в том случае, если связанный обработчик не найден. Помимо прочего, эту идею 
глобального обработчика можно использовать, чтобы гарантировать, что какое-то 
действие (например, вход в отладчик) всегда будет происходить, если определенный 
тип условия останется необработанным.
</p>

<p>
Zetalisp запускает каждый связанный обработчик в среде, где он больше не виден, поэтому, если при запуске обработчика с ошибками возникает ошибка, этот обработчик не будет использоваться для попытки обработать ошибку. Ключевая проблема с идеей глобальных обработчиков заключается в том, что сложнее разработать механизм (особенно в многозадачной среде с общей памятью, такой как Zetalisp) для временного отключения глобального обработчика (таким образом, чтобы не мешать работе прочие «процессы»). 
</p>

<h3>The Synchronous Nature of Conditions/Синхронная природа условий</h3>

<p>
«Системы условий», представленные в существующем Lisps <font color="green">[1990]</font>, 
в основном <b>synchronous</b>(синхронны). То есть акт сигнализации условия из кода 
заставляет этот код блокировать ожидающие рекомендации от обработчиков, которые затем 
запускаются синхронно в том же процессе.
</p>

<p>
Любое обсуждение <b>asynchronous conditions</b>(асинхронных условий) 
потребует новой терминологии, чтобы определить, что означает прерывание 
запущенного процесса, и выходит за рамки данной статьи. X3J13 также решил 
оставить этот вопрос открытым. 
</p>

<h2>VIII. Резюме</h2>

<p>
Описание программ можно разделить на две части, которые по отдельности описывают 
их поведение в <a href="#normsit"><b>normal situations</b></a>(обычных ситуациях) 
и их поведение в <a href="#excepsit"><b>exceptional situations</b></a>(исключительных 
ситуациях).
</p>

<p>
Это различие важно при разработке программ, поскольку оно позволяет 
программистам делать <a href="#simpl"><b>simplifying assumptions</b></a>(упрощающие 
предположения) о природе программ. Это также может иметь важные последствия для 
представления кода программы за счет визуального разделения кода, обрабатывающего 
нормальные и исключительные ситуации. Решение сделать это различие также может 
повлиять на аспекты <a href="#modul"><b>modularity</b></a>(модульности) и 
<a href="#effic"><b>efficiency</b></a>(эффективности) программ. 
</p>

<p>
Большинство языков уже предоставляют адекватный механизм управления для работы 
в исключительных ситуациях, включая <a href="#ignor"><b>игнорирование</b></a>
таких ситуаций, изменение <a href="#modretval"><b>соглашений о возвращаемых значениях</b></a>,
изменение <a href="#nretvals"><b>количества возвращаемых значений</b></a> и 
разрешение программам завершиться через <a href="#transctrl"><b>нелокальную передачу 
управления</b></a>, такую как <tt>THROW</tt>.
</p>

<p>
К сожалению, хотя эти механизмы достаточно мощны для реализации соответствующих 
видов управляющих структур, они недостаточно абстрактны, чтобы использовать их 
в качестве языка для описания и рассуждения об исключительных ситуациях. Необходимо 
развивать новый словарный запас, чтобы более абстрактно представить существующие 
функциональные возможности.
</p>

<p>
В этой статье мы рассмотрели различные аспекты <a href="#currprac">существующих 
систем условий</a> <font color="green">[1990]</font> для Лиспа и установили 
<a href="#newterms">терминологию</a>, которая может использоваться для абстрактного 
описания их поведения. 
</p>

<hr width="50%" align="CENTER">

<h2 align="CENTER">Примечания</h2>

<p>
Более ранняя версия этой статьи <a href="#Pitman-85">[Pitman 85]</a> была доступна 
в качестве рабочего документа 268 в Лаборатории искусственного интеллекта 
Массачусетского технологического института, но так и не была официально опубликована. 
Несмотря на это, исходный документ действительно послужил основой для разработки 
системы условий, которая является частью стандарта Common Lisp, который сейчас 
<font color="green">[1990]</font> дорабатывается подкомитетом X3J13 Американского 
национального института стандартов (ANSI) в США. Концепции, изложенные в предыдущей статье, актуальны сегодня, как и пять лет назад. Документ был обновлен в основном с целью включения незначительных изменений в терминологию и «систему отсчета» после публикации 1985 года.
</p>

<p>
Многие идеи в этой статье были вдохновлены «Новой системой ошибок» для 
компьютеров Symbolics [Weinreb 83]. Другие идеи возникли в результате обсуждений 
с Юджином Чиккарелли, Дэвидом Муном и Даниэлем Вайнребом. 
</p>

<p>
Любая ссылка на «появляющийся стандарт ANSI Common Lisp» относится к работе, 
проводимой подкомитетом X3J13 Американского национального института стандартов 
(ANSI) в США. На момент написания этой статьи (декабрь 1989 г.) X3J13 не 
выпустил никаких общедоступных документов, таких как стандарт или даже проект стандарта. 
Таким образом, ссылки на то, как стандарт ANSI может или не может выглядеть, 
на самом деле являются всего лишь снимками незавершенной работы и, следовательно,
 могут быть изменены без предварительного уведомления. Упоминание ANSI и его 
текущих процессов приводится только в целях иллюстрации - идеи, выраженные здесь, 
принадлежат автору и еще официально не поддержаны ANSI.
</p>

<font color="green">

<p>
[Со времени написания этой статьи, конечно, ANSI опубликовал X3.226 / 1994,
неофициально называемый ANSI Common Lisp. Официальная копия доступна только 
в печатном виде, но производная работа, эквивалентная по содержанию, 
доступна как  <a href="http://www.lispworks.com/documentation/HyperSpec/Front/index.htm">Common Lisp HyperSpec</a>.<br>--<i>KMP</i> 04-Apr-1999]
</p>

</font>

<p>
Некоторые термины, используемые в этой статье, также встречаются в документации 
для Zetalisp (например, [Weinreb 83]) и в появляющемся стандарте ANSI Common Lisp. 
Использование в этой статье было выбрано таким образом, чтобы оно было по 
существу совместимым. 
</p>

<hr width="50%" align="CENTER">

<h2 align="CENTER">Ссылки</h2>

<table>
<tbody><tr><td valign="TOP"><a name="Conway-75">[Conway 75]</a></td><td valign="TOP">R.W. <b>Conway</b> and D. <b>Gries</b>, An Introduction to Programming: A Structured Approach Using PL/I and PL/C-7, Winthrop Publishers, Inc., Cambridge, MA, 1975.<br>
<font color="green">
[The purpose of this reference here is probably confused.
 I had wanted to cite a reference to PL/1, from which many of the ideas
 in Weinreb's work descended.  However, I think it may be only Honeywell 
 Multics PL/1 that had the relevant features and this referenced item
 doesn't specifically document that dialect.  Oh well.  Can't change history.
 If someone does have a citation for Honeywell Multics PL/1, they should
 tell me and I'll update this document.<br>--<i>KMP</i> 04-Apr-1999]
</font></td></tr>

<tr><td valign="TOP"><a name="Lieberman-82">[Lieberman 82]</a></td><td valign="TOP">H. <b>Lieberman</b>, "Seeing What Your Programs Are Doing," Memo 656, MIT Artificial Intelligence Laboratory, Cambridge, MA, February 1982.</td></tr>

<tr><td valign="TOP"><a name="Liskov-79">[Liskov 79]</a></td><td valign="TOP">B. <b>Liskov</b>, et al, CLU Reference Manual, Technical Report 225, MIT Laboratory for Computer Science, Cambridge, MA, October 1979.</td></tr>

<tr><td valign="TOP"><a name="Pitman-83">[Pitman 83]</a></td><td valign="TOP">K. <b>Pitman</b>,
 The Revised Maclisp Manual (Saturday Evening Edition), Technical Report
 295, MIT Laboratory for Computer Science, Cambridge, MA, May 1983.</td></tr>

<tr><td valign="TOP"><a name="Pitman-85">[Pitman 85]</a></td><td valign="TOP">K. <b>Pitman</b>, "Exceptional Situations In Lisp," Working Paper 268, MIT Artificial Intelligence Laboratory, Cambridge, MA, February 1985.</td></tr>

<tr><td valign="TOP"><a name="Rich-81">[Rich 81]</a></td><td valign="TOP">C. <b>Rich</b> and R.C. <b>Waters</b>,
 "The Disciplined Use of Simplifying Assumptions," Working Paper 220, 
MIT Artificial Intelligence Laboratory, Cambridge, MA, December 1981.</td></tr>

<tr><td valign="TOP"><a name="Steele-76">[Steele 76]</a></td><td valign="TOP">G.L. <b>Steele</b>, Jr., and G.J. <b>Sussman</b>, "LAMBDA, The Ultimate Imperative," Memo 353, MIT Artificial Intelligence Laboratory, Cambridge, MA, March 1976.</td></tr>

<tr><td valign="TOP"><a name="Steele-78">[Steele 78]</a></td><td valign="TOP">G.L. <b>Steele</b>, Jr., and G.J. <b>Sussman</b>,
 "The Revised Report on SCHEME: A Dialect of LISP," Memo 452, MIT 
Artificial Intelligence Laboratory, Cambridge, MA, January 1978.</td></tr>

<tr><td valign="TOP"><a name="Steele-84">[Steele 84]</a></td>
<td valign="TOP">G.L. <b>Steele</b>, Jr., Common Lisp: The Language, Digital Press, Burlington, MA, 1984.<br>
<font color="green">[Subsequent to publication of this paper, Steele published
the Second Edition which incorporates the first; 
<a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html">
this second edition is available on the web</a>.
--KMP 04-Apr-1999]
</font></td></tr>

<tr><td valign="TOP"><a name="Weinreb-81">[Weinreb 81]</a></td><td valign="TOP">D.L. <b>Weinreb</b> and D.A. <b>Moon</b>, Lisp Machine Manual (Fourth Edition), MIT Artificial Intelligence Laboratory, Cambridge, MA, July 1981.</td></tr>

<tr><td valign="TOP"><a name="Weinreb-83">[Weinreb 83]</a></td><td valign="TOP">D.L. <b>Weinreb</b>, Signalling and Handling Conditions, Document #990097, Symbolics, Inc., Cambridge, MA, 1983.</td></tr>

</tbody></table>

<hr width="50%" align="CENTER">

<h2 align="CENTER">Footnotes</h2>

<table>

<tbody><tr><td valign="TOP"><a name="FNOTE1">1</a></td><td valign="TOP">

<p>At least one commercially available dialect of Lisp does exactly this.</p>

</td></tr>

<tr><td valign="TOP"><a name="FNOTE2">2</a></td><td valign="TOP">

<p>Maclisp is a dialect of Lisp for DEC PDP-10 and Honeywell Multics 
machines.  It reached peak popularity in the 1970's and had a strong 
influence on Common Lisp. </p>

</td></tr>

<tr><td valign="TOP"><a name="FNOTE3">3</a></td><td valign="TOP">

<p>Specifically, it will ignore the type information of the arguments, 
interpreting the bit patterns as if they represented fixnums. The result
 may be mystifying to novice programmers.</p>

</td></tr>

<tr><td valign="TOP"><a name="FNOTE4">4</a></td><td valign="TOP">

<p>The Maclisp function <tt>^G</tt> is so named because it simulates the effect of the Maclisp abort character, Control-G.</p>

</td></tr>

<tr><td valign="TOP"><a name="FNOTE5">5</a></td><td valign="TOP">

<p>The concept which was originally introduced in Symbolics Zetalisp as a
 "proceed option" is called a "restart" by X3J13.  This paper uses X3J13
 terminology where possible.</p>

</td></tr>

<tr><td valign="TOP"><a name="FNOTE6">6</a></td><td valign="TOP">

<p>Actually, Maclisp has only an error system, not a condition system, but we will assume that the same principles apply.</p>

</td></tr>

<tr><td valign="TOP"><a name="FNOTE7">7</a></td><td valign="TOP">

<p>The best direction of search is a subject of debate.  For example, the author contends that <tt>CONDITION-BIND-DEFAULT</tt>
 should search from outside in.  However, few systems have ever reached 
the necessary complexity for this situation to have occurred at all.  In
 time, as systems grow larger and need more fine tuning, better data 
will be available about what programmers really want and need, and 
subjective questions like this will be more readily answered.</p>

</td></tr>

<tr><td valign="TOP"><a name="FNOTE8">8</a></td><td valign="TOP">

<p>The emerging ANSI Common Lisp specification uses 
the term <tt>HANDLER-BIND</tt> for what Zetalisp
calls <tt>CONDITION-BIND</tt>.</p>

</td></tr>

<tr><td valign="TOP"><a name="FNOTE9">9</a></td><td valign="TOP">

<p>The author is not aware of condition systems for any existing 
languages that support the notion of a class hierarchy for restart 
options.<br>
<font color="green">
[This paper was written before 
<a href="http://en.wikipedia.org/wiki/Dylan_programming_language">Dylan</a> came along.
Dylan unifies the notion of conditions and restarts, and in the process
provides type hierarchy support for restarts.  --KMP 04-Apr-1999]</font></p>

<font color="green">
</font></td></tr>

<tr><td valign="TOP"><a name="FNOTE10">10</a></td><td valign="TOP">

<p>The scope could in principle be either dynamic or lexical, though in 
practice dynamic scope or some very close variant always seems to be 
preferred in existing systems.</p>

</td></tr>

</tbody></table>

<hr>

<font color="green">

<p>
Original printed text document<br>
<b>Copyright 1985, 1990 Kent M. Pitman. All Rights Reserved.</b>
</p>

<p>
HTML hypertext version of document<br>
<b>Copyright 1999, Kent M. Pitman.  All rights reserved.</b><br>
The following limited, non-exclusive, 
revokable licenses are granted:
</p>

<blockquote>

<p>
Browsing of this document (that is, transmission and display of a temporary
copy of this document for the ordinary purpose of direct viewing by a 
human being in the usual manner that hypertext browsers permit such
viewing) is expressly permitted, provided that no recopying, 
redistribution, redisplay, or retransmission is made of any such copy.
</p>

<p>
Bookmarking of this document (that is, recording only the document's title and 
Uniform Resource Locator, or URL, but not its content,
for the purpose of remembering an association between the document's title
and the URL, and/or for the purpose of making a subsequent request 
for a fresh copy of the content named by that URL)
is also expressly permitted.
</p>

</blockquote>

<p>
All other uses require negotiated permission.
</p>

</font>

<hr>

<p align="CENTER">
<a href="http://www.nhplace.com/kent/Papers/index.html"><i>Click here for an index 
of other titles by Kent Pitman.</i></a>
</p>

</body></html>
#
# NuINu <don't@send.my>, 2022.
#
#. extracted from in_ed/Condition-Handling-2001.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-28 10:15+0300\n"
"PO-Revision-Date: 2022-01-03 13:08+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in_ed/Condition-Handling-2001.html:10
msgid ""
"<html><head>\n"
"<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">\n"
"<title>``Condition Handling in the Lisp Language Family'' \n"
"c       by Kent Pitman (2001)</title>\n"
"<meta http-equiv=\"Keywords\" content=\"Conditions, Errors, Exceptions, "
"Handling, Lisp, Signaling\">\n"
"<meta http-equiv=\"Author\" content=\"Kent M. Pitman\">\n"
"<meta name=\"ROBOTS\" content=\"INDEX, NOFOLLOW\">\n"
"</head>\n"
"<body vlink=\"#7700bb\" text=\"#440077\" link=\"#7700bb\" bgcolor=\"#eeeeff"
"\" alink=\"#ff0000\">"
msgstr ""

#: in_ed/Condition-Handling-2001.html:12
msgctxt "in_ed/Condition-Handling-2001.html:12"
msgid "<font color=\"green\">"
msgstr ""

#: in_ed/Condition-Handling-2001.html:14
msgid ""
"<h1 align=\"center\">Condition Handling in the Lisp Language Family</h1>"
msgstr "<h1 align=\"center\">Обработка условий в семействе языков Lisp </h1>"

#: in_ed/Condition-Handling-2001.html:24
msgid ""
"<p align=\"center\">\n"
"<b>This paper appears in<br>\n"
"<a href=\"http://www.springer.de/cgi-bin/bag_generate.pl?"
"ISBN=3-540-41952-7\"><i>Advances in Exception Handling Techniques</i></a>,"
"<br>\n"
"edited by A. Romanovsky, C. Dony, J.L. Knudsen, and A. Tripathi.<br>\n"
"This book, published in 2001, is part of \n"
"<a href=\"http://www.springer.de/cgi-bin/search_book.pl?series=558\">Lecture "
"Notes in Computer Science, Volume 2022</a>,<br>\n"
"published by <a href=\"http://www.springer.de/\">Springer</a>.\n"
"</b>\n"
"</p>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:37
msgid ""
"<p>\n"
" This paper was originally written as an HTML document, exactly as shown\n"
" below.  Any final reformatting that was done for hardcopy publication \n"
" in LaTeX may have been lost in this version.  \n"
" Any new text that has been added for this annotated version\n"
" appears bracketed and in color green; such text is intended to\n"
" help clarify the historical context as time passes.<br>\n"
"--<a href=\"http://www.nhplace.com/kent/contact-kent.html\"><i>Kent Pitman</"
"i></a>, 28-Feb-2002.\n"
"</p>"
msgstr ""
"<p>\n"
" This paper was originally written as an HTML document, exactly as shown\n"
" below.  Any final reformatting that was done for hardcopy publication \n"
" in LaTeX may have been lost in this version.  \n"
" Any new text that has been added for this annotated version\n"
" appears bracketed and in color green; such text is intended to\n"
" help clarify the historical context as time passes.<br>\n"
"--<a href=\"http://www.nhplace.com/kent/contact-kent.html\"><i>Kent Pitman</"
"i></a>, 28-Feb-2002.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:45
msgid ""
"<p align=\"center\">\n"
"<a href=\"#ORIGINAL-START\">Annotated original document follows.</a><br>\n"
"<a href=\"http://www.nhplace.com/kent/Papers/index.html\"><i>Click here for "
"an index \n"
"of other titles by Kent Pitman.</i></a>\n"
"</p>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:49
msgctxt "in_ed/Condition-Handling-2001.html:49"
msgid "</font>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:52
msgctxt "in_ed/Condition-Handling-2001.html:52"
msgid "<hr>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:54
msgid "<div align=\"center\">"
msgstr ""

#: in_ed/Condition-Handling-2001.html:56
msgid ""
"<a name=\"ORIGINAL-START\"><h1>Condition Handling in the Lisp Language "
"Family</h1></a>"
msgstr ""
"<a name=\"ORIGINAL-START\"><h1>Обработка условий в семействе языков Lisp </"
"h1></a>"

#: in_ed/Condition-Handling-2001.html:61
msgid ""
"<p>\n"
"<b><font color=\"green\">by <a href=\"http://www.nhplace.com/kent/contact-"
"kent.html\">Kent M. Pitman</a></font></b>\n"
"</p>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:69
msgid ""
"<p>\n"
"<a href=\"#COPYRIGHT\">Copyright Â© 2001, Kent M. Pitman.\n"
"                     All Rights Reserved.</a>\n"
"</p>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:77
msgid ""
"<p>\n"
"<a href=\"#COPYRIGHT\"><font color=\"green\">[ Web version Copyright Â© "
"2002, Kent M. Pitman.\n"
"                     All Rights Reserved. ]</font></a>\n"
"</p>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:82
msgid "</div>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:85
msgid "<h2>Introduction</h2>"
msgstr "<h2>Введение</h2>"

#: in_ed/Condition-Handling-2001.html:94
msgid ""
"<p>\n"
"The Lisp family of languages has long been a rich source of ideas and\n"
"inspiration in the area of error handling.  Here we will survey\n"
"some of the abstract concepts and terminology, as well as some\n"
"specific language\n"
"constructs that Lisp has contributed.\n"
"</p>"
msgstr ""
"<p>\n"
"Семейство языков Lisp уже давно является богатым источником идей и \n"
"вдохновения в области обработки ошибок. Здесь мы рассмотрим некоторые \n"
"абстрактные концепции и терминологию, а также некоторые конкретные \n"
"языковые конструкции, внесенные Lisp.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:104
msgid ""
"<p>\n"
"Although there are numerous dialects of Lisp, several of which offer\n"
"the modern concepts and capabilities described herein, we will focus \n"
"specifically on Common Lisp as described in the ANSI standard, X3.226-1994\n"
"<a href=\"#x3j13-1994\">[X3J13 1994]</a>.\n"
"</p>"
msgstr ""
"<p>\n"
"Хотя существует множество диалектов Лиспа, некоторые из которых предлагают \n"
"современные концепции и возможности, описанные здесь, мы сосредоточимся \n"
"конкретно на Common Lisp, как описано в стандарте ANSI, X3.226-1994\n"
"<a href=\"#x3j13-1994\">[X3J13 1994]</a>.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:108
msgid "<h3>Condition Systems vs Error Systems</h3>"
msgstr "<h3>Системы условий и системы ошибок</h3>"

#: in_ed/Condition-Handling-2001.html:117
msgid ""
"<p>\n"
"The Common Lisp community typically prefers to speak about its\n"
"<b class=\"newterm\">condition system</b> rather than its\n"
"<b class=\"newterm\">error system</b> to emphasize that there are\n"
"not just fatal but also non-fatal situations in which\n"
"the capabilities provided by this system are useful.\n"
"</p>"
msgstr ""
"<p>\n"
"Сообщество Common Lisp обычно предпочитает говорить о своей \n"
"<b class=\"newterm\">condition system/системе условий</b>, а не о своей \n"
"<b class=\"newterm\">error system/системе ошибок</b>, чтобы подчеркнуть, \n"
"что существуют не только фатальные, но и нефатальные ситуации, в \n"
"которых возможности, предоставляемые этой системой, полезны.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:129
msgid ""
"<p>\n"
"Not all <b class=\"newterm\">exceptional situations</b>\n"
"are represented, or sometimes even detected.\n"
"A situation that <emph>is</emph>\n"
"represented within the language is referred to in Common Lisp as a \n"
"<b class=\"newterm\">condition</b>; an object\n"
"of class <code>CONDITION</code> is used to represent such a situation.\n"
"</p>"
msgstr ""
"<p>\n"
"Не все <b class=\"newterm\">exceptional situations(исключительные ситуации)</"
"b> \n"
"представлены или иногда даже обнаруживаются. Ситуация, представленная в "
"языке, \n"
"называется в Common Lisp <b class=\"newterm\">condition(условием)</b>; "
"объект класса \n"
"<code>CONDITION</code> используется для представления такой ситуации. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:140
msgid ""
"<p>\n"
"A <b class=\"newterm\">condition</b> is said to be the generalization\n"
"of an <b class=\"newterm\">error</b>.  Correspondingly, within the language\n"
"the class <code>CONDITION</code> is a superclass of \n"
"another class <code>ERROR</code>, which represents situations that\n"
"would be fatal if not appropriately managed.\n"
"</p>"
msgstr ""
"<p>\n"
"<b class=\"newterm\">Условие(condition)</b> называется обобщением \n"
"<b class=\"newterm\">ошибки(error)</b>. Соответственно, внутри языка \n"
"класс <code>CONDITION</code> является суперклассом другого класса \n"
"<code>ERROR</code>, который представляет ситуации, которые были бы \n"
"фатальными, если бы не управлялись должным образом.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:153
msgid ""
"<p>\n"
"So the set of all situations involving conditions\n"
"includes not only descriptions of outright erroneous situations\n"
"but also descriptions of situations that are merely unusual or "
"questionable.\n"
"Even in the case of non-error conditions, the programmer may, \n"
"as a matter of expressive freedom,\n"
"choose to use the same capabilities and protocols\n"
"as would be used for \"real\" error handling.\n"
"</p>"
msgstr ""
"<p>\n"
"Таким образом, набор всех ситуаций, включающих условия, включает не \n"
"только описания явно ошибочных ситуаций, но и описания ситуаций, которые \n"
"просто необычны или сомнительны. Даже в случае отсутствия ошибок \n"
"программист может, исходя из свободы выражения, выбрать использование тех "
"же \n"
"возможностей и протоколов, которые использовались бы для обработки \n"
"«реальных» ошибок. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:157
msgid "<h3>Condition Handling Is Primarily a Protocol Matter</h3>"
msgstr ""
"<h3>Обработка условий - в первую очередь важен Протокол\n"
"</h3>"

#: in_ed/Condition-Handling-2001.html:169
msgid ""
"<p>\n"
"To properly understand condition handling, it is critical to understand \n"
"that it is primarily about <b class=\"newterm\">protocol</b>, rather than\n"
"mere computational ability.\n"
"The establishment of protocols is\n"
"a sort of before-the-fact hedge against the \"prisoner's dilemma\"; that "
"is,\n"
"it creates an obvious way for two people who are not directly communicating\n"
"to structure independently developed code so that it works in a manner\n"
"that remains coherent when such code is later combined.\n"
"</p>"
msgstr ""
"<p>\n"
"Чтобы правильно понять обработку условий, важно понимать, что в первую "
"очередь \n"
"речь идет о <b class=\"newterm\">протоколе(protocol)</b>, а не просто о \n"
"вычислительных возможностях. Установление протоколов - это своего рода "
"преграда \n"
"от «дилеммы заключенного»; то есть он создает очевидный способ для двух "
"людей, \n"
"которые не общаются напрямую, структурировать независимо разработанный код "
"так, \n"
"чтобы он работал таким образом, который оставался бы согласованным при \n"
"последующем объединении такого кода.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:178
msgid ""
"<p>\n"
"For example, if we want to write a program that searches a list for an\n"
"object, returning true if the object is present and false otherwise, we\n"
"could write the following, but would ordinarily not:\n"
"</p>"
msgstr ""
"<p>\n"
"Например, если мы хотим написать программу, которая ищет в списке объект, \n"
"возвращая истину, если объект присутствует, и ложь в противном случае, мы \n"
"могли бы написать следующее, но обычно этого не делали бы: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:193
msgid ""
"<pre class=\"code\"> (defun search-list (goal-item list-to-search)\n"
"   (handler-case \n"
"       ;; Main body\n"
"       (progn (dolist (item list-to-search) \n"
"                (when (eq item goal-item)\n"
"                  (return-from search-list t)))\n"
"              ;; Search has failed, signal an error.\n"
"              (error 'search-failure \n"
"                     :item goal-item))\n"
"     ;; Upon error, just return false.\n"
"     (error () nil)))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:203
msgid ""
"<p>\n"
"The reason not to write this is not that it will not work, but that it \n"
"involves undue amounts of unneeded mechanism.  The language already \n"
"contains simpler ways of expressing transfer of control from point A\n"
"to point B in a program where the same programmer, acting in the same\n"
"role, controls the code at both points.  For example, the following\n"
"would suffice:\n"
"</p>"
msgstr ""
"<p>\n"
"Причина не писать об этом заключается не в том, что это не сработает, а в "
"том, \n"
"что это связано с чрезмерным количеством ненужного механизма. Язык уже "
"содержит \n"
"более простые способы выражения передачи управления от точки A к точке B в "
"программе, \n"
"где один и тот же программист, действуя в той же роли, контролирует код в "
"обеих точках. \n"
"Например, достаточно следующего: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:212
msgid ""
"<pre class=\"code\"> (defun search-list (goal-item list-to-search)\n"
"   (dolist (item list-to-search) \n"
"     (when (eq item goal-item)\n"
"       (return-from search-list t)))\n"
"   nil)\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:224
msgid ""
"<p>\n"
"<emph>However<emph>, if the intended action in the case of a failing\n"
"search were not specified, and was to be provided by the caller, the\n"
"use of condition handling mechanisms might be appropriate.  For example,\n"
"in the following code, only the signaling is occurring, and the handling is\n"
"being left to the caller.  Because of this, the use of condition handling\n"
"facilities is appropriate because those facilities will provide \n"
"matchmaking and data transport services between the signaler and the\n"
"handler.\n"
"</emph></emph></p>"
msgstr ""
"<p>\n"
"<emph>Однако<emph>, если предполагаемое действие в случае неудачного "
"поиска \n"
"не было указано и должно было быть выполнено вызывающей стороной, \n"
"использование механизмов обработки условий могло бы быть целесообразным. \n"
"Например, в следующем коде происходит только сигнализация, а обработка \n"
"предоставляется вызывающей стороне. Из-за этого использование средств \n"
"обработки условий является целесообразным, поскольку эти средства будут \n"
"обеспечивать службы согласования и передачи данных между сигнализатором \n"
"и обработчиком. \n"
"</emph></emph></p>"

#: in_ed/Condition-Handling-2001.html:233
msgid ""
"<pre class=\"code\"> (defun search-list (goal-item list-to-search)\n"
"   (dolist (item list-to-search) \n"
"     (when (eq item goal-item)\n"
"       (return-from search-list t)))\n"
"   (error 'search-failure :item goal-item))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:242
msgid ""
"<p>\n"
"Protocol is simply not needed when communicating lexically among parts of\n"
"a program that were written as a unit and that are not called\n"
"by other programs that are either logically separated or, at minimum, \n"
"logically separable.  The distinction is subjective, but it is nevertheless\n"
"important.\n"
"</p>"
msgstr ""
"<p>\n"
"Протокол просто не нужен при лексическом взаимодействии между частями \n"
"программы, которые были написаны как единое целое и которые не вызываются \n"
"другими программами, которые либо логически разделены, либо, как минимум, "
"логически разделены. Различие субъективно, но, тем не менее, важно.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:246
msgid "<h2>Historical Influences</h2>"
msgstr "<h2>Исторические влияния</h2>"

#: in_ed/Condition-Handling-2001.html:258
msgid ""
"<p>\n"
"Before beginning to look in detail at the features of Common Lisp's\n"
"condition system, it's useful to observe that computer languages, like\n"
"human languages, evolve over time both to accommodate current needs and\n"
"to repair problems observed in past experience.\n"
"The interesting features of the Common Lisp condition\n"
"system were not suddenly designed one day as a spontaneous creative act,\n"
"but rather grew from many years of prior experience in other languages and \n"
"systems.\n"
"</p>"
msgstr ""
"<p>\n"
"Прежде чем начать подробно рассматривать особенности системы условий Common "
"Lisp, \n"
"полезно заметить, что компьютерные языки, как и человеческие языки, со "
"временем \n"
"развиваются как для удовлетворения текущих потребностей, так и для "
"устранения проблем, \n"
"наблюдаемых в прошлом опыте. Интересные особенности системы условий Common "
"Lisp \n"
"не возникли внезапно в один прекрасный день как спонтанный творческий акт, \n"
"а скорее выросли из многолетнего предыдущего опыта работы с другими "
"языками \n"
"и системами. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:262
msgid "<h3>Influence of Multics PL/I on Symbolics Zetalisp</h3>"
msgstr "<h3>Влияние Multics PL/I на Symbolics Zetalisp</h3>"

#: in_ed/Condition-Handling-2001.html:272
msgid ""
"<p>\n"
"The PL/I language, designed at IBM in the early 1960's, included\n"
"an extensive condition mechanism which had an extensible set of\n"
"named signals and dynamic handlers running in the dynamic\n"
"context of the signal.  Since PL/I included \"downward\" lexical closures\n"
"these handlers had access to the erring environment, and sometimes to\n"
"the details of the error.\n"
"</p>"
msgstr ""
"<p>\n"
"Язык PL/I, разработанный в IBM в начале 1960-х годов, включал обширный \n"
"механизм условий, который имел расширяемый набор именованных сигналов \n"
"и динамических обработчиков, работающих в динамическом контексте сигнала. \n"
"Поскольку PL/I включал «нисходящие» лексические замыкания, эти обработчики \n"
"имели доступ к среде с ошибками, а иногда и к деталям ошибки.\n"
"\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:284
msgid ""
"<p>\n"
"Multics, whose official language was PL/I, adapted and extended\n"
"this, including the addition of <code>any_other</code>, \n"
"<code>cleanup</code>, and <code>unclaimed_signal</code>,\n"
"the passing of machine conditions and other arbitrary data,\n"
"cross-protection-domain signals, and the use of this mechanism\n"
"to manage multiple suspended environments on one stack.\n"
"</p>"
msgstr ""
"<p>\n"
"Multics, официальным языком которой был PL/I, адаптировал и расширил это, \n"
"включая добавление <code>any_other</code>, <code>cleanup</code> и \n"
"<code>unclaimed_signal</code>, передачу условий машины и других \n"
"произвольных данных, сигналов домена перекрестной защиты и использование \n"
"этого механизма для управления несколькими приостановленными средами \n"
"в одном стеке. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:296
msgid ""
"<p>\n"
"For security reasons, Multics had an elaborate and rigidly enforced\n"
"separation of various kinds of code into protected \"rings\".\n"
"The Multics operating system relied on their expanded signaling \n"
"system for several critical system functions, mostly in the user ring,\n"
"although cross-ring signals were possible in certain cases involving\n"
"paging or memory errors.\n"
"</p>"
msgstr ""
"<p>\n"
"По соображениям безопасности в Multics было тщательно разработано и \n"
"строго соблюдено разделение различных типов кода на защищенные «кольца». \n"
"Операционная система Multics полагалась на свою расширенную систему \n"
"сигнализации для нескольких важных системных функций, в основном в кольце \n"
"пользователя, хотя в некоторых случаях возможны перекрестные сигналы "
"вызова, \n"
"связанные с  с ошибками подкачки или памяти.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:307
msgid ""
"<p>\n"
"Historically, Multics was an \"early\" environment, but it was not,\n"
"by any analysis, a toy.  Its condition system\n"
"was carefully designed, heavily tested,\n"
"and had many important characteristics that influenced the later\n"
"design of Lisp:\n"
"</p>"
msgstr ""
"<p>\n"
"Исторически Multics была «ранней» средой, но, судя по любому анализу, \n"
"не была игрушкой. Его система условий была тщательно спроектирована, \n"
"тщательно протестирована и обладала многими важными характеристиками, \n"
"которые повлияли на более позднее проектирование Lisp: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:313
msgid ""
"<ul>\n"
"<li>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:319
msgid ""
"<p>\n"
"It separated\n"
"the notion of <b class=\"newterm\">condition signaling</b> from \n"
"<b class=\"newterm\">condition handling</b>.\n"
"</p>"
msgstr ""
"<p>\n"
"Она отделяет понятие <b class=\"newterm\">condition signaling(сигнализации "
"условия)</b> \n"
"от <b class=\"newterm\">condition handling(обработки условия)</b>.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:322
msgctxt "in_ed/Condition-Handling-2001.html:322"
msgid "</li>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:324
msgctxt "in_ed/Condition-Handling-2001.html:324"
msgid "<li>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:330
msgid ""
"<p>\n"
"It offered the possibility, through <code>program_interrupt</code>\n"
"conditions, of resuming an erring computation, presumably after \n"
"correcting the offending situation.\n"
"</p>"
msgstr ""
"<p>\n"
"Она давала возможность через условия <code>program_interrupt</code> "
"возобновить \n"
"ошибочные вычисления, предположительно после исправления \n"
"проблемной ситуации.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:333
msgctxt "in_ed/Condition-Handling-2001.html:333"
msgid "</li>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:335
msgctxt "in_ed/Condition-Handling-2001.html:335"
msgid "<li>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:346
msgid ""
"<p>\n"
"It began to deal with the\n"
"mediation of signaling and handling through not only a \n"
"<b class=\"newterm\">condition type</b> but also a set of associated data\n"
"appropriate to that type:  By using a system-defined operator called\n"
"\"<code>signal_</code>\" instead of the normal PL/I \"<code>signal</code>"
"\",\n"
"a data block could be associated with the condition being signaled,\n"
"a crude precursor to the idea of object-oriented\n"
"condition descriptions that followed later in Lisp.\n"
"</p>"
msgstr ""
"<p>\n"
"Она начала заниматься посредничеством сигнализации и обработки \n"
"не только с помощью <b class=\"newterm\">condition type</b>(типа условия), \n"
"но и с помощью набора связанных(ассоциированных) данных, соответствующих \n"
"этому типу: с помощью определенного системой оператора, называемого \n"
"\"<code>signal_</code>\", ​​вместо обычного PL/I \"<code>signal</code>\" ,\n"
"блок данных может быть связан с сигнализируемым условием, что является \n"
"грубым предшественником идеи объектно-ориентированных описаний условий, \n"
"которая позже возникла в Лиспе.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:349
msgctxt "in_ed/Condition-Handling-2001.html:349"
msgid "</li>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:351
msgctxt "in_ed/Condition-Handling-2001.html:351"
msgid "<li>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:356
msgid ""
"<p>\n"
"It began to deal with the notion of default handling, through the use of \n"
"the <code>unclaimed_signal</code> pseudocondition.\n"
"</p>"
msgstr ""
"<p>\n"
"Она начала работать с понятием обработки по умолчанию с помощью \n"
"псевдоусловия <code>unclaimed_signal</code>.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:360
msgctxt "in_ed/Condition-Handling-2001.html:360"
msgid ""
"</li>\n"
"</ul>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:370
msgid ""
"<p>\n"
"In the early 1980's, some former users of the Multics system,\n"
"including Daniel L. Weinreb, Bernard Greenberg and David Moon,\n"
"harvested the good ideas of the Multics PL/I condition system\n"
"and recast them into Zetalisp, a dialect running on the\n"
"Symbolics Lisp Machines.  This redesign was called simply the\n"
"\"New Error System\" (or sometimes just \"NES\").\n"
"</p>"
msgstr ""
"<p>\n"
"В начале 1980-х некоторые бывшие пользователи системы Multics, \n"
"в том числе Дэниел Л. Вайнреб, Бернард Гринберг и Дэвид Мун, собрали\n"
" хорошие идеи системы условий Multics PL/I и переработали их в Zetalisp, \n"
"диалекте, работающем на Symbolics Lisp Машины. Этот редизайн назывался \n"
"просто \"New Error System\"(Новая система ошибок) (или иногда просто "
"«NES»). \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:374
msgid "<h3>Influence of Symbolics Zetalisp on Common Lisp</h3>"
msgstr "<h3>Влияние Symbolics Zetalisp на Common Lisp</h3>"

#: in_ed/Condition-Handling-2001.html:380
msgid ""
"<p>\n"
"Key elements of the New Error System (NES) in Symbolics Zetalisp\n"
"were:\n"
"</p>"
msgstr ""
"<p>\n"
"Ключевыми элементами Новой системы ошибок (New Error System - NES) в "
"Symbolics Zetalisp были:\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:384
msgid ""
"<ul>\n"
"<li>\n"
"<p>NES had an object-oriented nature.</p>"
msgstr ""
"<ul>\n"
"<li>\n"
"<p> NES имела объектно-ориентированный характер.</p>"

#: in_ed/Condition-Handling-2001.html:389
msgid ""
"</li>\n"
"<li>\n"
"<p>NES clearly separated the treatment of exceptional situations into\n"
"    three logically distinct programming activities:</p>"
msgstr ""
"</li>\n"
"<li>\n"
"<p>В NES обработка исключительных ситуаций четко разделена на \n"
"три логически различных программных действия:</p>"

#: in_ed/Condition-Handling-2001.html:396
msgid ""
"<ul>\n"
"<li>Establishing handlers.</li>\n"
"<li>Managing \"proceed types\" (what Common Lisp later called \"restarts\")."
"</li>\n"
"<li>Detecting exceptional situations and signaling appropriate conditions.</"
"li>\n"
"</ul>"
msgstr ""
"<ul>\n"
"<li>Установление обработчиков.</li>\n"
"<li>Управление \"proceed types\"(типами продолжений) (то, что Common Lisp "
"позже называл \"restarts\"(перезапусками)).</li>\n"
"<li>Обнаружение исключительных ситуаций и сигнализация соответствующих "
"условий.</li>\n"
"</ul>"

#: in_ed/Condition-Handling-2001.html:398
msgid "<p></p>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:401
msgctxt "in_ed/Condition-Handling-2001.html:401"
msgid "</li>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:408
msgid ""
"<li>\n"
"<p>NES provided for erring programs to be resumed either interactively\n"
"or non-interactively, separating information about\n"
"prompting for replacement data from the conduits that would carry such data\n"
"so that programs wishing to do mechanical recovery could bypass the "
"prompting\n"
"but use the rest of the recovery pipeline.</p>"
msgstr ""
"<li>\n"
"<p>NES обеспечивала возобновление работы ошибочных программ в "
"интерактивном \n"
"или неинтерактивном режиме, отделяя информацию о запросе на замену данных "
"от \n"
"каналов, которые будут передавать такие данные, чтобы программы, желающие \n"
"выполнить механическое восстановление, могли обойти запрос, но "
"использовать \n"
"остальную часть конвейера восстановления. </p>"

#: in_ed/Condition-Handling-2001.html:411
msgctxt "in_ed/Condition-Handling-2001.html:411"
msgid ""
"</li>\n"
"</ul>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:424
msgid ""
"<p>\n"
"NES directly and strongly influenced the design of the Common Lisp\n"
"condition system.  In fact, one initial concern voiced by a number of\n"
"vendors was that they were fearful that somehow the ideas of the \n"
"condition system, being taken from the Lisp Machine environment, would\n"
"not perform well on standard hardware.  It took several months of \n"
"discussion, and the availability of a free public implementation of the\n"
"ideas, before these fears were calmed and the Common Lisp community was\n"
"able to adopt them.  Even so, numerous small changes and a few major \n"
"changes were made in the process.\n"
"</p>"
msgstr ""
"<p>\n"
"NES напрямую и сильно повлияла на разработку системы условий Common Lisp. \n"
"Фактически, одна из первых проблем, высказанных рядом поставщиков, \n"
"заключалась в том, что они опасались, что каким-то образом идеи \n"
"системы условий, взятые из среды Lisp Machine, не будут хорошо работать \n"
"на стандартном оборудовании. Потребовалось несколько месяцев обсуждения \n"
"и доступности бесплатной публичной реализации идей, прежде чем эти \n"
"опасения улеглись и сообщество Common Lisp смогло принять их. Тем не "
"менее, \n"
"в процессе было внесено множество мелких изменений и несколько \n"
"серьезных изменений.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:437
msgid ""
"<p>\n"
"In both Zetalisp and Common Lisp, handlers are functions that are called in\n"
"the dynamic context of the signaling operation.  No stack unwinding has \n"
"yet occurred when the handlers are called.  Potential handlers are tried \n"
"in order until one decides to handle the condition.\n"
"Probably the most conspicuous change between NES and the Common Lisp "
"Condition\n"
"System was the choice of how a handler function communicated its decision\n"
"to elect a specific mode of recovery for the condition being signaled.\n"
"</p>"
msgstr ""
"<p>\n"
"И в Zetalisp, и в Common Lisp обработчики - это функции, которые "
"вызываются \n"
"в динамическом контексте операции сигнализации. При вызове обработчиков \n"
"раскрутки стека еще не произошло. Потенциальные обработчики проверяются \n"
"по порядку, пока один из них не решит обработать условие. Вероятно, \n"
"наиболее заметным изменением между NES и Common Lisp Condition System \n"
"был выбор того, как функция-обработчик сообщает о своем решении выбрать \n"
"конкретный режим восстановления для сигнализируемого условия. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:451
msgid ""
"<p>\n"
"NES used a <b class=\"newterm\">passive</b> recovery mechanism.  That is, "
"in \n"
"all cases, the handler would return one or more values.  The nature of\n"
"the return values would determine which recovery mode (called a \n"
"\"proceed type\" in Zetalisp) was to be used.  If <code>NIL</code> was "
"returned,\n"
"the handler had elected no proceed type, and the next handler was tried.\n"
"Otherwise, the handler must return at least one value, a keyword "
"designating \n"
"the proceed type, and, optionally, additional values which were data\n"
"appropriate to that manner of proceeding.\n"
"</p>"
msgstr ""
"<p>\n"
"NES использовала <b class=\"newterm\">passive</b>(пассивный) механизм "
"восстановления. \n"
"То есть во всех случаях обработчик вернет одно или несколько значений. \n"
"Природа возвращаемых значений будет определять, какой режим восстановления \n"
"(в Zetalisp он называется \"proceed type\"(тип продолжения)) должен "
"использоваться. \n"
"Если был возвращен <code>NIL</code>, обработчик не выбрал тип продолжения, \n"
"и был испробован следующий обработчик. В противном случае обработчик "
"должен \n"
"вернуть по крайней мере одно значение, ключевое слово, обозначающее тип "
"обработки, \n"
"и, необязательно, дополнительные значения, которые были данными, "
"соответствующими \n"
"этому способу обработки.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:464
msgid ""
"<p>\n"
"Common Lisp uses an <b class=\"newterm\">active</b> recovery mechanism.  \n"
"That is, any handler that wishes to designate a recovery mechanism \n"
"(called a \"restart\" in Common Lisp) must imperatively transfer control\n"
"to that restart.  If the handler does not transfer control, that is,\n"
"if the handler returns normally, any returned values are ignored and\n"
"the handler is said to have \"declined\" (<i>i.e.,</i>  elected no "
"restart),\n"
"and the next handler is tried.\n"
"</p>"
msgstr ""
"<p>\n"
"Common Lisp использует <b class=\"newterm\">active</b>(активный) механизм "
"восстановления. \n"
"То есть любой обработчик, который желает назначить механизм восстановления \n"
"(называемый \"restart\"(перезапуском) в Common Lisp), должен обязательно \n"
"передать управление этому перезапуску. Если обработчик не передает "
"управление, \n"
"то есть, если обработчик нормально возвращается, любые возвращаемые "
"значения \n"
"игнорируются, и говорят, что обработчик \"restart\"(отклонил) (то есть не "
"выбрал перезапуск), \n"
"и пробуется следующий обработчик. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:468
msgid "<h3>The Maclisp Experience</h3>"
msgstr "<h3>Опыт Maclisp</h3>"

#: in_ed/Condition-Handling-2001.html:481
msgid ""
"<p>\n"
"I am commonly credited with the \"creation\" of the Common Lisp Condition\n"
"System, although I hope to show through this paper that my role in\n"
"the design was largely to take the ideas of others and carefully\n"
"transplant them to Common Lisp.  In doing this, I relied on my\n"
"personal experiences to guide me, and many of my formative experiences\n"
"came from my work with Maclisp <a href=\"#pitman-1983\">[Pitman 1983]</a>,\n"
"which originated at MIT's Project MAC (later renamed to be\n"
"the Laboratory for Computer Science), and which ran on the Digital "
"Equipment\n"
"Corporation (DEC) PDP10, DEC TOPS20 and Honeywell Multics systems.\n"
"</p>"
msgstr ""
"<p>\n"
"Мне обычно приписывают «создание» Common Lisp Condition System, хотя \n"
"я надеюсь показать в этой статье, что моя роль в разработке заключалась \n"
"в основном в том, чтобы брать идеи других и аккуратно переносить их в \n"
"Common Lisp. При этом я полагался на свой личный опыт, который руководил "
"мной, \n"
"и многие из моих формирующих опытов пришли из моей работы с Маклиспом \n"
"<a href=\"#pitman-1983\">[Pitman 1983]</a>, \n"
"которая зародилась в проекте MAC Массачусетского технологического "
"института \n"
"(позже переименованном в Лабораторию компьютерных наук), и который работал "
"н\n"
"а системах Digital Equipment Corporation (DEC) PDP10, DEC TOPS20 и Honeywell "
"Multics.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:494
msgid ""
"<p>\n"
"Maclisp, \n"
"had a relatively primitive error system, which I had\n"
"used extensively.  At the time I came to the Lisp Machine's NES, I did\n"
"not know what I was looking for in an error system, but I knew, based\n"
"on my experience with Maclisp, what I was <i>not</i> looking for.  So\n"
"what impressed me initially about NES was that it had fixed many of\n"
"the design misfeatures that I had seen in Maclisp.\n"
"</p>"
msgstr ""
"<p>\n"
"Маклисп имел относительно примитивную систему ошибок, которую я широко \n"
"использовал. В то время, когда я пришел к NES Лисп-машины, я не знал, \n"
"что я ищу в системе ошибок, но я знал, основываясь на моем опыте работы \n"
"с Maclisp, то, что я не искал. Итак, что меня сначала впечатлило в NES, \n"
"так это то, что в ней были исправлены многие ошибки проектирования, \n"
"которые я видел в Maclisp.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:509
msgid ""
"<p>\n"
"One important bit of background on Maclisp, at least on the PDP10 \n"
"implementation that I used, was that it had no <code>STRING</code>\n"
"datatype.  In almost all cases where one might expect strings to be\n"
"used, interned symbols were used instead.  Symbols containing characters \n"
"that might otherwise confuse the tokenizer were bounded on either end\n"
"by a vertical bar (<tt>|</tt>).  Also, since symbols would normally name\n"
"variables, they generally had to be quoted with a leading single quote \n"
"(<tt>'</tt>) to protect them from the Lisp evaluation mechanism and allow "
"them\n"
"to be used as pseudostrings.\n"
"</p>"
msgstr ""
"<p>\n"
"Одним из важных моментов в истории Maclisp, по крайней мере, о реализации "
"PDP10, \n"
"которую я использовал, было то, что у него не было типа данных STRING. Почти "
"во \n"
"всех случаях, когда можно было ожидать использования строк, вместо них \n"
"использовались интернированные символы. Символы, содержащие символы, "
"которые \n"
"в противном случае могли бы сбить с толку токенизатор, были ограничены с "
"обоих \n"
"концов вертикальной чертой (<tt>|</tt>). Кроме того, поскольку символы "
"обычно \n"
"именуют переменные, их обычно приходилось заключать в кавычки с ведущей "
"одинарной \n"
"кавычкой (<tt>'</tt>), чтобы защитить их от механизма оценки Lisp и "
"позволить \n"
"использовать их как псевдостроки. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:514
msgid ""
"<pre class=\"code\"> '|This is a quoted Maclisp symbol.|\n"
"</pre>"
msgstr ""
"<pre class=\"code\"> '|This is a quoted Maclisp symbol.|\n"
"</pre>"

#: in_ed/Condition-Handling-2001.html:516
msgid "<h4>Poor Separation of Signaling and Handling in Maclisp</h4>"
msgstr "<h4>Плохое разделение сигнализации и обработки в Maclisp</h4>"

#: in_ed/Condition-Handling-2001.html:526
msgid ""
"<p>\n"
"Maclisp had two forms of the function <code>ERROR</code>.  In the simple\n"
"and most widely used form, one merely called <code>ERROR</code> with one "
"argument, a\n"
"description of the error.  Such errors would stop program execution with\n"
"no chance of recovery other than to transfer to the innermost \n"
"<code>ERRSET</code>, the approximate Maclisp equivalent of Common Lisp's\n"
"<code>IGNORE-ERRORS</code>.\n"
"</p>"
msgstr ""
"<p>\n"
"Маклисп имел две формы функции <code>ERROR</code>. В простой и наиболее "
"широко \n"
"используемой форме можно просто вызвать <code>ERROR</code> с одним "
"аргументом, \n"
"описанием ошибки. Такие ошибки остановят выполнение программы без "
"возможности \n"
"восстановления, кроме передачи на самый внутренний <code>ERRSET</code>, \n"
"приблизительный Maclisp-эквивалент <code>IGNORE-ERRORS</code> в Common "
"Lisp. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:531
msgid ""
"<pre class=\"code\"> (error '|YOU LOSE|)\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:538
msgid ""
"<p>\n"
"It was possible, however, in a limited way, to specify the particular kind\n"
"of error.  There were about a dozen predefined kinds of errors that one "
"could\n"
"identify that did allow recovery.  For example,\n"
"</p>"
msgstr ""
"<p>\n"
"Однако можно было ограниченным образом указать конкретный вид ошибки. Было "
"около \n"
"дюжины предопределенных типов ошибок, которые можно было идентифицировать и "
"которые \n"
"действительно позволяли исправить ситуацию. Например, \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:543
msgid ""
"<pre class=\"code\"> (error '|VARIABLE HAS NO VALUE| 'A 'UNBND-VRBL)\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:554
msgid ""
"<p>\n"
"The \"keyword\" <code>UNBND-VRBL</code> was a system-defined name that "
"indicated\n"
"to the system that this was an error of kind \"unbound variable\".  A "
"specific\n"
"recovery strategy was permitted in this case.  One could, either "
"interactively\n"
"in a breakpoint or through the dynamic establishment of a handler for such \n"
"errors, provide a value for the variable. If that happened, the call to \n"
"<code>ERROR</code> would then return a list of that value and the caller of\n"
"<code>ERROR</code> was expected to pick up that value and use it.\n"
"</p>"
msgstr ""
"<p>\n"
"«Ключевое слово» <code>UNBND-VRBL</code> было системным именем, которое \n"
"указывало системе, что это была ошибка типа \"unbound variable\"(несвязанная "
"переменная). \n"
"В этом случае была разрешена конкретная стратегия восстановления. Можно либо "
"интерактивно \n"
"в точке останова, либо путем динамического установления обработчика таких "
"ошибок указать \n"
"значение для переменной. Если это произойдет, вызов <code>ERROR</code> затем "
"вернет список \n"
"этого значения, и ожидается, что вызывающий <code>ERROR</code> получит это "
"значение и \n"
"использует его.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:569
msgid ""
"<p>\n"
"This worked fine for the case where the programmer knew the kind of error\n"
"and was prepared to recover from it.  But a strange situation occurred when "
"one\n"
"knew the kind of error but was not prepared to recover.  Sometimes one knew\n"
"one had an unbound variable, and wanted to call <code>ERROR</code>,\n"
"but was not prepared\n"
"to recover.  In this case, the programmer was forced to lie and to say that\n"
"it was an error of arbitrary type, using just the short form, to avoid\n"
"the misperception on the part of potential handlers that returning a "
"recovery\n"
"value would be useful.\n"
"</p>"
msgstr ""
"<p>\n"
"Это прекрасно работало в случае, когда программист знал тип ошибки и был "
"готов \n"
"исправить ее. Но произошла странная ситуация, когда человек знал, что за "
"ошибка,\n"
" но не был готов к исправлению. Иногда кто-то знал, что у него есть "
"несвязанная \n"
"переменная, и хотел вызвать <code>ERROR</code>, но не был готов к "
"восстановлению. \n"
"В этом случае программист был вынужден солгать и сказать, что это была "
"ошибка \n"
"произвольного типа, используя только краткую форму, чтобы избежать "
"неправильного \n"
"восприятия со стороны потенциальных обработчиков, что возврат значения "
"восстановления \n"
"был бы полезен. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:574
msgid ""
"<pre class=\"code\"> (error '|VARIABLE HAS NO VALUE| 'A)\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:582
msgid ""
"<p>\n"
"One feature of the NES, which I personally found very attractive, was the\n"
"notion that I could freely specify the class of error without regard to\n"
"whether I was prepared to handle it in some particular way.  The issue of\n"
"how to handle the error was specified orthogonally.\n"
"</p>"
msgstr ""
"<p>\n"
"Одна из особенностей NES, которая лично мне показалась очень "
"привлекательной, \n"
"заключалась в том, что я мог свободно указывать класс ошибки, независимо от "
"того, \n"
"готов ли я справиться с ней каким-либо определенным образом. Вопрос о том, "
"как \n"
"обрабатывать ошибку, был задан ортогонально.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:586
msgid "<h4>Error Message Identity In Maclisp</h4>"
msgstr "<h4>Идентификация сообщения об ошибке в Maclisp</h4>"

#: in_ed/Condition-Handling-2001.html:597
msgid ""
"<p>\n"
"In PDP10 Maclisp, error messages were historically all uppercase,\n"
"since the system's primitive error messages were that way and many\n"
"users found it aesthetically unpleasant to have some messages in mixed\n"
"case while others were entirely uppercase.  At some point, however,\n"
"there was pressure to provide mixed case error messages.  The decision\n"
"made by the Maclisp maintainers of the time was not to yield to such\n"
"pressure.\n"
"</p>"
msgstr ""
"<p>\n"
"В PDP10 Maclisp сообщения об ошибках всегда были в верхнем регистре, \n"
"поскольку в системе были примитивные сообщения об ошибках, и многие \n"
"пользователи находили эстетически неприятным иметь некоторые сообщения \n"
"в смешанном регистре, в то время как другие были полностью в верхнем "
"регистре. \n"
"Однако в какой-то момент возникла необходимость предоставлять сообщения \n"
"об ошибках со смешанным регистром. Сторонники Maclisp того времени решили\n"
"не поддаваться такому давлению.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:605
msgid ""
"<p>\n"
"The problem was that many programs faced with an error message were testing\n"
"it for object identity.  For example:\n"
"</p>"
msgstr ""
"<p>\n"
"Проблема заключалась в том, что многие программы, столкнувшиеся с сообщением "
"об ошибке, \n"
"проверяли его на идентичность объекта. Например: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:610
msgid ""
"<pre class=\"code\"> (eq msg '|UNBOUND VARIABLE|)\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:618
msgid ""
"<p>\n"
"Had we changed the case of all of the error messages in the Maclisp system\n"
"to any other case, lower or mixed, these tests would have immediately begun\n"
"to fail, breaking a lot of installed code and costing a lot of money to "
"fix.\n"
"The change would have been seen to be gratuitous.\n"
"</p>"
msgstr ""
"<p>\n"
"Если бы мы изменили регистр всех сообщений об ошибках в системе Maclisp \n"
"на любой другой, более низкий или смешанный, эти тесты немедленно начали \n"
"бы давать сбои, ломая много установленного кода и требуя больших денег для \n"
"исправления. Это изменение было бы беспричинным.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:633
msgid ""
"<p>\n"
"The lesson from this for all of us in the Maclisp community, which became\n"
"magnified later when we confronted the broader community of international\n"
"users, was that the identity of an error should not be its name.  That is,\n"
"had we to do it over again, we would not have used \n"
"<code>|unbound variable|</code> nor <code>|Unbound Variable|</code> \n"
"as the identity of the error, but rather would have created objects \n"
"whose slots or methods were responsible for yielding the presented string,\n"
"but whose identity and nature was controlled orthogonally.  This was \n"
"another thing that NES offered that drew me immediately to it.\n"
"</p>"
msgstr ""
"<p>\n"
"Урок из этого для всех нас в сообществе Maclisp, который стал более заметным "
"позже, \n"
"когда мы столкнулись с более широким сообществом международных "
"пользователей, \n"
"заключался в том, что идентичность ошибки не должна быть ее именем. То "
"есть, \n"
"если бы мы сделали это снова, мы бы не использовали <code>|unbound variable|"
"</code> \n"
"ни <code>|Unbound Variable|</code> как идентификатор ошибки, а скорее "
"создавали \n"
"бы объекты, чьи слоты или методы отвечали за выдачу представленной строки, \n"
"но чьи идентичность и природа контролировались ортогонально. Это была еще \n"
"одна вещь, которую предложила NES, которая сразу же привлекла меня к ней. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:637
msgid "<h3>Terminological Influences</h3>"
msgstr "<h3>Терминологические влияния</h3>"

#: in_ed/Condition-Handling-2001.html:650
msgid ""
"<p>\n"
"At the time of the Common Lisp design, Scheme did not have an error system,\n"
"and so its contribution to the dialog on condition systems was not that of\n"
"contributing an operator or behavior.\n"
"However, it still did have something to contribute: the useful term\n"
"<b class=\"newterm\">continuation</b>.  \n"
"For our purposes here, it is sufficient to see a continuation\n"
"as an actual or conceptual function \n"
"that represents, in essence, one of possibly several \"future worlds\",\n"
"any of which can be entered by electing to call its associated "
"continuation.\n"
"</p>"
msgstr ""
"<p>\n"
"Во время разработки Common Lisp в Scheme не было системы ошибок, и поэтому \n"
"ее вклад в диалог по системам условий не был вкладом оператора или "
"поведения. \n"
"Однако ему все же было что внести: полезный термин <b class=\"newterm"
"\">continuation</b>(продолжение).\n"
"Для наших целей здесь достаточно рассматривать продолжение как актуальную "
"или \n"
"концептуальную функцию, которая представляет, по сути, один из, возможно, \n"
"нескольких «будущих миров», в любой из которых можно войти, выбрав вызов "
"связанного \n"
"с ним продолжения. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:666
msgid ""
"<p>\n"
"This metaphor was of tremendous value to me socially in my efforts to gain\n"
"acceptance of the condition system, because it allowed a convenient, terse\n"
"explanation of what \"restarts\" were about in Common Lisp.\n"
"Although Scheme continuations are, by tradition, typically passed by "
"explicit\n"
"data flow, this is not a requirement.\n"
"And so I have often found myself thankful\n"
"for the availability of a concept so that I could talk about the \n"
"establishment of named restart points as \"taking a continuation, labeling \n"
"it with a tag, and storing it away on a shelf somewhere for possible \n"
"later use.\"\n"
"</p>"
msgstr ""
"<p>\n"
"Эта метафора имела для меня огромную социальную ценность в моих усилиях по \n"
"принятию системы условий, потому что она позволяла удобное и краткое "
"объяснение \n"
"того, что означает \"restarts\"(перезапуск) в Common Lisp. Хотя по "
"традиции \n"
"продолжения Scheme обычно передаются явным потоком данных, это не является \n"
"обязательным требованием. И поэтому я часто обнаруживал, что благодарен за \n"
"доступность концепции, так что я мог говорить об установлении именованных \n"
"точек перезапуска как «взятие продолжения, маркировка его тегом и хранение \n"
"его где-нибудь на полке для возможного дальнейшего использования. . \"\n"
"\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:682
msgid ""
"<p>\n"
"Likewise, I found it useful in some circles to refer to some of the\n"
"concepts of reflective Lisps, such as Brian Smith's \"3Lisp\" \n"
"<a href=\"#smith-1982\">[Smith 1982]</a>, and later work inspired by it.  I "
"feel that the condition\n"
"system's ability to introspect (through operators such as\n"
"<code>FIND-RESTART</code>) about what possible actions are pending,\n"
"without actually invoking those pending actions, is an important\n"
"reflective capability.  Even though Common Lisp does not offer\n"
"general-purpose reflection, the ability to use this metaphor for\n"
"speaking about those aspects of the language that are usefully\n"
"described by it simplifies conversations.\n"
"</p>"
msgstr ""
"<p>\n"
"Точно так же я счел полезным в некоторых кругах сослаться на некоторые \n"
"концепции рефлексивных Лиспов, такие как «3Lisp» Брайана Смита \n"
"<a href=\"#smith-1982\">[Smith 1982]</a>, и более поздние работы, "
"вдохновленные им. \n"
"Я считаю, что способность системы условий анализировать (с помощью таких "
"операторов, \n"
"как <code>FIND-RESTART</code>), какие возможные действия ожидают "
"выполнения, \n"
"без фактического вызова этих ожидающих действий, является важной "
"отражающей \n"
"способностью. Несмотря на то, что Common Lisp не предлагает универсального \n"
"отражения, возможность использовать эту метафору для обсуждения тех "
"аспектов \n"
"языка, которые с его помощью описываются с пользой, упрощает общение. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:686
msgid "<h2>Abstract Concepts</h2>"
msgstr "<h2>Абстрактные концепции</h2>"

#: in_ed/Condition-Handling-2001.html:696
msgid ""
"<p>\n"
"Having now hopefully firmly established that the formative ideas in \n"
"the Common Lisp Condition System did not all spring into existence with\n"
"the language itself, and are really the legacy of the community using the\n"
"continuum of languages of which Common Lisp is a part, we can now turn our\n"
"attention to a survey of some of the important features that Common Lisp\n"
"provides.\n"
"</p>"
msgstr ""
"<p>\n"
"Теперь, когда мы надеемся, что твердо установили, что формирующие идеи \n"
"в Common Lisp Condition System не все возникли вместе с самим языком и \n"
"действительно являются наследием сообщества, использующего континуум "
"языков, \n"
"частью которых является Common Lisp, мы можем теперь обратить внимание на \n"
"обзор некоторых важных функциональностей, которые предоставляет Common "
"Lisp.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:700
msgid "<h3>Separating Signaling and Handling</h3>"
msgstr "<h3>Разделение сигнализации и обработки</h3>"

#: in_ed/Condition-Handling-2001.html:708
msgid ""
"<p>\n"
"Traditionally, \"error handling\" has been largely a process of programs \n"
"stopping and the only real question has been \"how much of the program stops?"
"\"\n"
"or \"how far out do I throw?\"  It is against that backdrop that modern\n"
"condition handling can be best understood.\n"
"</p>"
msgstr ""
"<p>\n"
"Традиционно \"error handling\"(обработка ошибок) в основном представляла "
"собой \n"
"процесс остановки программ, и единственный реальный вопрос заключался в "
"том, \n"
"«какая часть программы останавливается?» или \"как далеко мне throw(бросить "
"исключение)?\" \n"
"Именно на этом фоне можно лучше всего понять современную обработку условий.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:715
msgid ""
"<p>\n"
"The proper way to think about condition handling is this:\n"
"</p>"
msgstr ""
"<p>\n"
"Правильный способ думать об обработке условий - это:\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:727
msgid ""
"<p>\n"
"The process of programming is about saying what to do in every "
"circumstance.\n"
"In that regard, a computer has been sometimes characterized as a\n"
"\"relentless judge of incompleteness\".\n"
"When a program reaches a place where there are several possible next steps\n"
"and the program is unwilling or incapable of choosing among them, \n"
"the program has detected an <b class=\"newterm\">exceptional situation</b>.\n"
"</p>"
msgstr ""
"<p>\n"
"Процесс программирования заключается в том, чтобы говорить, что делать в \n"
"любых обстоятельствах. В этом отношении компьютер иногда характеризовали \n"
"как «беспощадный судья незавершенности». Когда программа достигает места, \n"
"где есть несколько возможных следующих шагов, и программа не желает или \n"
"неспособна выбрать среди них, программа обнаружила исключительную "
"ситуацию(<b class=\"newterm\">exceptional situation</b>).\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:735
msgid ""
"<p>\n"
"The possible next steps are called <b class=\"newterm\">restarts</b>.\n"
"Restarts are, effectively, named continuations.\n"
"</p>"
msgstr ""
"<p>\n"
"Возможные следующие шаги называются перезапусками(<b class=\"newterm"
"\">restarts</b>). \n"
"Фактически перезапуски называются продолжениями(continuations).\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:743
msgid ""
"<p>\n"
"The process of asking for help in resolving the problem of selecting among\n"
"the possible next steps is called <b class=\"newterm\">signaling</b>.\n"
"</p>"
msgstr ""
"<p>\n"
"Процесс обращения за помощью в решении проблемы выбора среди возможных "
"следующих \n"
"шагов называется сигнализацией(<b class=\"newterm\">signaling</b>).\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:758
msgid ""
"<p>\n"
"The independently contributed pieces of code which are consulted during \n"
"the signaling process are called <b class=\"newterm\">handlers</b>.  In\n"
"Common Lisp, these are functions contributed by the dynamic call chain \n"
"that are tried in order from innermost\n"
"(<i>i.e.,</i> most specific) to outermost (<i>i.e.,</i> most general).\n"
"Each handler is called with an argument\n"
"that is a description of the problem situation.  The handler will transfer\n"
"control (by <code>GO</code>, <code>RETURN</code> or <code>THROW</code>)\n"
"if it chooses to handle the problem described by its argument.\n"
"</p>"
msgstr ""
"<p>\n"
"Независимые фрагменты кода, которые используются в процессе сигнализации, \n"
"называются обработчиками(<b class=\"newterm\">handlers</b>). В Common Lisp \n"
"это функции, вносимые динамической цепочкой вызовов, которые "
"проверяются(пробуются/tried) \n"
"в порядке от самой внутренней  (то есть, наиболее специфичной/специальной) \n"
"к самой внешней(то есть, наиболее общей). Каждый обработчик(функция) "
"вызывается \n"
"с аргументом, который является описанием проблемной ситуации. Обработчик \n"
"передаст управление (с помощью <code>GO</code>, <code>RETURN</code> или \n"
"<code>THROW</code>), если он решит решить проблему, описанную его "
"аргументом.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:766
msgid ""
"<p>\n"
"In describing condition handling, I tell the following story to help \n"
"people visualize the need for its various parts:\n"
"</p>"
msgstr ""
"<p>\n"
"Описывая обработку условий, я рассказываю следующую историю, чтобы помочь \n"
"людям визуализировать потребность в ее различных частях:\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:770
msgctxt "in_ed/Condition-Handling-2001.html:770"
msgid "<blockquote>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:782
msgid ""
"<p>\n"
"Think of the process of signaling and handling as analogous to finding a\n"
"fork in a road that you do not commonly travel.  You don't know which way \n"
"to go, so you make known your dilemma, that is, you signal a condition.\n"
"Various sources of wisdom (handlers) present themselves, and you consult\n"
"each, placing your trust in them because you have no special knowledge \n"
"yourself of what to do.  Not all sources of wisdom are experts on every\n"
"topics, so some may decline to help before you find one that is confident\n"
"of its advice.  When an appropriately confident source of wisdom is found,\n"
"it will act on your behalf.  The situation has been handled.\n"
"</p>"
msgstr ""
"<p>\n"
"Думайте о процессе сигнализации и обработке как о поиске развилки на "
"дороге, \n"
"по которой вы обычно не путешествуете. Вы не знаете, куда идти, поэтому вы \n"
"заявляете о своей дилемме, то есть вы сигнализируете о условии(состоянии). \n"
"Представляются различные источники мудрости (обработчики), и вы "
"консультируетесь \n"
"с каждым, полагаясь на них, потому что у вас нет специальных знаний о том, \n"
"что делать. Не все источники мудрости являются экспертами по всем темам, \n"
"поэтому некоторые могут отказаться от помощи вам, прежде чем вы найдете "
"того, \n"
"кто уверен в их советах. Когда будет найден достаточно надежный источник "
"мудрости, \n"
"он будет действовать от вашего имени. Ситуация разрешена(обработана). \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:785
msgctxt "in_ed/Condition-Handling-2001.html:785"
msgid "</blockquote>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:807
msgid ""
"<p>\n"
"In the case that the situation is not handled, the next action depends on\n"
"which operator was used to signal.  The function <code>signal</code> will\n"
"just return normally when a condition goes unhandled.  The function \n"
"<code>error</code> is like signal, but rather than return, it enters \n"
"the <b class=\"newterm\">debugger</b>.  The Common Lisp debugger might "
"allow\n"
"access to low-level debugging features such as examination of individual\n"
"storage locations, but it is not required to.  Its <emph>primary</emph>\n"
"role is to be an <b class=\"newterm\">interactive handler</b>; that is, to\n"
"present the human user interactively with various options about how\n"
"computation might be resumed.\n"
"Conceptually, this is the same as if it were acting as \n"
"the human user's proxy in being\n"
"the element on the list of handlers, so that the human user is\n"
"the source of wisdom\n"
"whose choice will determine how to proceed.  Other capabilities that the\n"
"debugger might offer in support of that human's decision are probably very\n"
"important in practice, but are conceptually uninteresting to this \n"
"understanding of the debugger's role in signaling and handling.\n"
"</p>"
msgstr ""
"<p>\n"
"В случае, если ситуация не обрабатывается, следующее действие зависит от "
"того, \n"
"какой оператор использовался для подачи сигнала. Функция <code>signal</"
"code> \n"
"просто вернется в обычном режиме, когда условие не будет обработано. \n"
"Функция <code>error</code> похожа на signal(сигнал), но вместо возврата \n"
"она попадает в <b class=\"newterm\">debugger</b>(отладчик). Отладчик \n"
"Common Lisp может разрешить доступ к функциональности отладки низкого "
"уровня, \n"
"таким как проверка отдельных мест хранения, но это не обязательно. \n"
"Его <emph>основная</emph> роль - быть интерактивным обработчиком\n"
"(<b class=\"newterm\">interactive handler</b>); то есть интерактивно "
"представить \n"
"пользователю-человеку различные варианты возобновления вычислений. \n"
"Концептуально это то же самое, как если бы он действовал в качестве "
"доверенного \n"
"лица пользователя, являясь элементом в списке обработчиков, так что "
"пользователь-человек \n"
"является источником мудрости, выбор которого будет определять дальнейшие "
"действия. \n"
"Другие возможности, которые отладчик может предложить для поддержки решения "
"этого человека,\n"
"вероятно, очень важны на практике, но концептуально неинтересны для такого "
"понимания роли \n"
"отладчика в передаче сигналов и обработке.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:829
msgid ""
"<p>\n"
"Note, too, that in some possible future world, knowledge representation may\n"
"have advanced enough that handlers could, rather than act unconditionally\n"
"on behalf of the signaler, \n"
"merely return a representation of a set of potential actions accompanied by\n"
"descriptive information respresenting motivations, consequences, and \n"
"even qualitative representations of the goodness of each.\n"
"Such information might be combined with, compared to, or confirmed by\n"
"recommendations from\n"
"other sources of wisdom in order to produce a better result.\n"
"This is how consultation of sources of wisdom would probably work in the\n"
"real world.  Consider that even a doctor who is sure of what a patient "
"needs\n"
"will ask the patient's permission before acting.  \n"
"However, this last step of confirmation,\n"
"which would allow more flexibility in the reasoning process,\n"
"is not manifest in Common Lisp as of the time of writing this paper.\n"
"It is an open area for future research.\n"
"</p>"
msgstr ""
"<p>\n"
"Также обратите внимание, что в некотором возможном мире будущего "
"представление \n"
"знаний может быть достаточно продвинутым, чтобы обработчики могли вместо "
"того, \n"
"чтобы действовать безоговорочно от имени сигнализатора, просто возвращать "
"представление \n"
"набора потенциальных действий, сопровождаемых описательной информацией, "
"соответствующей \n"
"мотивации, последствиям и т. Д. и даже качественные представления о "
"добродетели каждого \n"
"из них. Такую информацию можно комбинировать, сравнивать или подтверждать "
"рекомендациями \n"
"из других источников мудрости, чтобы получить лучший результат. Вот как, "
"вероятно, будет \n"
"работать консультация с источниками мудрости в реальном мире. Учтите, что "
"даже врач, \n"
"уверенный в том, что нужно пациенту, прежде чем действовать, спросит у "
"пациента разрешения. \n"
"Однако этот последний шаг подтверждения, который обеспечил бы большую "
"гибкость в \n"
"процессе рассуждений, не проявился в Common Lisp на момент написания этой "
"статьи. \n"
"Это открытая область для будущих исследований.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:837
msgid ""
"<p>\n"
"Some of these issues are discussed in much greater detail in my 1990\n"
"conference paper <a href=\"#pitman-1990\">[Pitman 1990]</a>.\n"
"</p>"
msgstr ""
"<p>\n"
"Некоторые из этих вопросов обсуждаются более подробно в моем докладе на \n"
"конференции 1990 года  <a href=\"#pitman-1990\">[Pitman 1990]</a>.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:841
msgid "<h3>Generalized Conditions</h3>"
msgstr "<h3>Обобщенные условия</h3>"

#: in_ed/Condition-Handling-2001.html:848
msgid ""
"<p>\n"
"It was mentioned earlier that the space of conditions that can be used\n"
"in the Common Lisp Condition System is more general than the space of\n"
"mere errors.  Here are some examples.\n"
"</p>"
msgstr ""
"<p>\n"
"Ранее упоминалось, что пространство условий, которое может использоваться \n"
"в Common Lisp Condition System, является более общим, чем пространство "
"простых ошибок. \n"
"Вот несколько примеров. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:852
msgid "<h4>Serious, non-error Conditions</h4>"
msgstr "<h4>Серьезные, Условия без ошибок</h4>"

#: in_ed/Condition-Handling-2001.html:864
msgid ""
"<p>\n"
"The superclass of <code>error</code> is <code>serious-condition</code>.\n"
"This kind of condition is a subclass of <code>condition</code> but is \n"
"serious enough that conditions of this kind should generally enter the\n"
"debugger if unhandled.  Serious conditions, which the Zetalisp NES called\n"
"\"debugger conditions\", exist as a separately named concept\n"
"from \"error conditions\" to accommodate things that are\n"
"not semantic errors in a program, but are instead resource limitations and\n"
"other incidental accomodations to pragmatics.\n"
"</p>"
msgstr ""
"<p>\n"
"Суперкласс <code>error</code>(ошибки) это  <code>serious-condition</"
"code>(серьезное условие). \n"
"Этот вид условий является подклассом <code>condition</code>(условий), но "
"достаточно серьезным, \n"
"чтобы условия такого рода обычно попадали в отладчик, если не "
"обрабатывались. Серьезные условия,\n"
"которые Zetalisp NES назвал \"debugger conditions\"(условиями попадания в "
"отладчик, или просто\n"
"условиями отладчика\", существуют как концепция, отдельно от названных "
"\"error conditions\"\n"
"(условий ошибки), чтобы приспособить вещи, которые не являются "
"семантическими ошибками \n"
"в программе, а являются ограничениями ресурсов и другими случайными "
"дополнениями к \n"
"прагматике.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:871
msgid ""
"<p>\n"
"Suppose one writes the following:\n"
"</p>"
msgstr ""
"<p>\n"
"Предположим, кто-то пишет следующее: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:876
msgid ""
"<pre class=\"code\"> (ignore-errors (open \"some.file\"))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:885
msgid ""
"<p>\n"
"This will trap errors during the file open.  However, what if a stack "
"overflow\n"
"occurs, not for reasons of infinite recursion, but merely because the call\n"
"is nested very deeply in other code?  The answer is that a stack overflow\n"
"is considered a serious condition, but not an error.  The above code\n"
"is equivalent to:\n"
"</p>"
msgstr ""
"<p>\n"
"Это позволит отловить ошибки во время открытия файла. Однако что, если "
"произойдет \n"
"переполнение стека не по причинам бесконечной рекурсии, а просто потому, \n"
"что вызов очень глубоко вложен в другой код? Ответ заключается в том, \n"
"что переполнение стека считается серьезным условием(serious condition), \n"
"но не ошибкой. Приведенный выше код эквивалентен: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:892
msgid ""
"<pre class=\"code\"> (handler-case (open \"some.file\")\n"
"   (error (c)\n"
"     (values nil c)))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:901
msgid ""
"<p>\n"
"And since any condition representing a stack overflow is going to be a kind\n"
"of <code>SERIOUS-CONDITION</code>, but not a kind of <code>ERROR</code>, \n"
"the use of <code>IGNORE-ERRORS</code> will succeed in trapping a file\n"
"error but not a stack overflow.  If one wanted to catch serious conditions\n"
"as well, one would write instead:\n"
"</p>"
msgstr ""
"<p>\n"
"И поскольку любое условие, представляющее переполнение стека, будет своего \n"
"рода <code>SERIOUS-CONDITION</code>(СЕРЬЕЗНЫМ УСЛОВИЕМ), но не "
"разновидностью \n"
"<code>ERROR</code>(ОШИБКИ), использование <code>IGNORE-ERRORS</code> "
"приведет \n"
"к улавливанию ошибки файла, но не переполнения стека. Если бы кто-то хотел \n"
"перехватить еще и серьезными условия, вместо этого он бы написал: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:908
msgid ""
"<pre class=\"code\"> (handler-case (open \"some.file\")\n"
"   (serious-condition (c)\n"
"     (values nil c)))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:910
msgid "<h4>Non-serious conditions</h4>"
msgstr "<h4>Не серьезные условия(Non-serious conditions)</h4>"

#: in_ed/Condition-Handling-2001.html:916
msgid ""
"<p>\n"
"Some conditions are not at all serious.  Such conditions might be handled,\n"
"but there is an obvious default action in the case of their going "
"unhandled.\n"
"</p>"
msgstr ""
"<p>\n"
"Некоторые условия вовсе не серьезные. Такие условия могут быть обработаны, \n"
"но есть очевидное действие по умолчанию в случае, если они не будут "
"обработаны.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:924
msgid ""
"<p>\n"
"Consider a program doing line-at-a-time output to a console.  One might\n"
"assume the screen to have infinite height, and the output might look like:\n"
"</p>"
msgstr ""
"<p>\n"
"Рассмотрим программу, которая выводит на консоль построчно. Можно было бы \n"
"предположить, что экран имеет бесконечную высоту, и результат может \n"
"выглядеть так: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:932
msgid ""
"<pre class=\"code\"> (defvar *line-number* 0)\n"
" (defun show-lines (lines)\n"
"   (dolist (line lines)\n"
"     (show-line line)))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:941
msgid ""
"<p>\n"
"However, it might be useful to specify screen line height, and to have\n"
"the console pause every so many lines for a human reader to confirm that\n"
"it's ok to proceed.  There are, of course, a number of ways such a facility\n"
"could be programmed, but one possible such way is to use the condition \n"
"system.  For example,\n"
"</p>"
msgstr ""
"<p>\n"
"Тем не менее, может быть полезно указать высоту строки экрана и сделать "
"так, \n"
"чтобы консоль приостанавливалась каждые несколько строк, чтобы человек-"
"читатель \n"
"подтвердил, что можно продолжить. Конечно, есть несколько способов "
"программирования \n"
"такой функциональности, но один из возможных способов - использовать систему "
"условий. \n"
"Например, \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:956
msgid ""
"<pre class=\"code\"> (defvar *line-number* 0)\n"
" (defvar *page-height* nil)\n"
" (define-condition end-of-page (condition) ())\n"
" (defun show-lines (lines)\n"
"   (dolist (line lines)\n"
"     <font color=\"green\">(show-line line)  ; Oops. Omitted this call from "
"original paper!</font>\n"
"     (incf *line-number*)\n"
"     (when (and *page-height*\n"
"                (zerop (mod *line-number* *page-height*)))\n"
"       (restart-case (signal 'end-of-page)\n"
"         (continue ())))))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:965
msgid ""
"<p>\n"
"In the above, there is only one way to proceed.  A restart named\n"
"<code>CONTINUE</code> is offered as a way of imperatively selecting\n"
"this option (imperatively bypassing any other pending handlers),\n"
"but if the handler declines and the condition goes unhandled, the\n"
"same result will be achieved.\n"
"</p>"
msgstr ""
"<p>\n"
"В приведенном выше описании есть только один способ продолжения. Перезапуск "
"с \n"
"именем <code>CONTINUE</code> предлагается в качестве способа обязательного \n"
"выбора этой опции (обязательного обхода любых других ожидающих "
"обработчиков), \n"
"но если обработчик отклоняется и условие остается необработанным, будет \n"
"достигнут тот же результат.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:977
msgid ""
"<p>\n"
"A similar kind of facility could be used to manage end of line\n"
"handling.  There, it's common to allow various modes, and so a\n"
"corresponding set of restarts has to be established, which handlers\n"
"would choose among.  If no handler elected to handle the condition,\n"
"however, no great harm would come.  Here's an example of how that\n"
"might look:\n"
"</p>"
msgstr ""
"<p>\n"
"Подобное средство можно использовать для управления обработкой конца "
"строки. \n"
"Там обычно разрешаются различные режимы, поэтому должен быть установлен \n"
"соответствующий набор перезапусков, из которых будут выбирать обработчики. \n"
"Однако, если ни один обработчик не выберет обработотку условия, большого \n"
"вреда не будет. Вот пример того, как это может выглядеть: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:999
msgid ""
"<pre class=\"code\"> (defvar *line-length* nil)\n"
" (define-condition end-of-line (condition) ())\n"
" (defun show-line (line)\n"
"   (let ((eol (or *line-length* -1)) (hpos 0))\n"
"     (loop for pos below (length line)\n"
"           for ch = (char line pos)\n"
"           do (write-char ch)\n"
"           when (= hpos eol)\n"
"             do (restart-case (signal 'end-of-line)\n"
"                  (wrap ()\n"
"                    (write-char #\\Newline)\n"
"                    (setq hpos 0))\n"
"                  (truncate ()\n"
"                    (return))\n"
"                  (continue ()\n"
"                    ;; just allow to continue\n"
"                    ))\n"
"           else do (incf hpos))))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1001
msgid "<h3>Independent, Reflective Specification of Restarts</h3>"
msgstr "<h3>Независимая рефлексивная/отражающая спецификация перезапусков</h3>"

#: in_ed/Condition-Handling-2001.html:1011
msgid ""
"<p>\n"
"It has long been the case that Lisp offered the ability to dynamically\n"
"make the decision to transfer to a computed return point using the\n"
"special operator <code>THROW</code>.  However, without reflective \n"
"capabilities, there has not been the ability for a programmer to determine\n"
"if there was a pending <code>CATCH</code> to which control could be thrown\n"
"other than relatively clumsy idioms such as the following:\n"
"</p>"
msgstr ""
"<p>\n"
"Уже давно Lisp предлагал возможность динамически принимать решение о \n"
"передаче в вычисленную точку возврата с помощью специального оператора \n"
"<code>THROW</code>. Однако без рефлексивных возможностей у программиста \n"
"не было возможности определить, есть ли ожидающий <code>CATCH</code>, \n"
"на который может быть брошен элемент управления, кроме относительно "
"неуклюжих \n"
"идиом, таких как следующие: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1016
msgid ""
"<pre class=\"code\"> (ignore-errors (throw 'some-tag 'some-value))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1024
msgid ""
"<p>\n"
"The problem with the above idiom is that while it \"detects\" the presence "
"or\n"
"absence of a pending tag, it only retains local control and the ability to\n"
"reason about this knowledge in the case of the tag's non-existence.  The \n"
"price of detecting the tag's existence is transfer to that tag.\n"
"</p>"
msgstr ""
"<p>\n"
"Проблема с вышеуказанной идиомой заключается в том, что,  хотя она "
"\"обнаруживает\" \n"
"наличие или отсутствие ожидающего тега, она сохраняет только локальный "
"контроль \n"
"и способность рассуждать об этом знании в случае отсутствия тега. Ценой "
"обнаружения \n"
"существования тега является переход на этот тег.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1037
msgid ""
"<p>\n"
"The Common Lisp Condition System adds a limited kind of reflective "
"capability\n"
"in the form of a new kind of catch point, called a \n"
"<b class=\"newterm\">restart</b>, the presence or absence of which can be\n"
"reasoned about without any attempt to actually perform a transfer.  \n"
"A restart can also have associated with it a descriptive textual string\n"
"that a human user can be shown by the debugger to describe the potential\n"
"action offered by the restart.  \n"
"</p>"
msgstr ""
"<p>\n"
"Система условий Common Lisp добавляет ограниченную способность отражения/"
"рефлексии \n"
"в форме нового типа точки перехвата(catch point), называемой <b class="
"\"newterm\">restart</b>\n"
"(перезапуском), о наличии или отсутствии которой можно судить без каких-"
"либо \n"
"попыток фактического выполнения передачи. С перезапуском также может быть "
"связана \n"
"описательная текстовая строка, которую пользователь-человек может показать "
"отладчику \n"
"для описания потенциального действия, предлагаемого перезапуском.  \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1046
msgid ""
"<p>\n"
"Restart points that require transfer of control but no data can be \n"
"established straightforwardly with <code>WITH-SIMPLE-RESTART</code>.\n"
"For example:\n"
"</p>"
msgstr ""
"<p>\n"
"Точки перезапуска, которые требуют передачи управления, но не могут \n"
"быть установлены напрямую с помощью <code>WITH-SIMPLE-RESTART</code>. \n"
"Например: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1055
msgid ""
"<pre class=\"code\"> (defun lisp-top-level-loop ()\n"
"   (with-simple-restart (exit \"Exit from Lisp.\")\n"
"     (loop\n"
"       (with-simple-restart (continue \"Return to Lisp toplevel.\")\n"
"         (print (eval (read)))))))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1066
msgid ""
"<p>\n"
"Restarts that require data can also be established using a slightly more\n"
"elaborate syntax.  This syntax not only accommodates the programmatic\n"
"data flow to the restart,\n"
"but also enough information for the Common Lisp function \n"
"<code>INVOKE-RESTART-INTERACTIVELY</code>\n"
"to properly prompt for any appropriate values to be supplied to that "
"restart.\n"
"For example:\n"
"</p>"
msgstr ""
"<p>\n"
"Перезапуски(Restarts), требующие данных, также могут быть выполнены с \n"
"использованием немного более сложного синтаксиса. Этот синтаксис не \n"
"только учитывает программный поток данных для перезапуска, но также \n"
"предоставляет достаточно информации для функции Common Lisp \n"
"<code>INVOKE-RESTART-INTERACTIVELY</code>, чтобы правильно запрашивать \n"
"любые подходящие значения, которые должны быть предоставлены для этого \n"
"перезапуска. Например: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1087
msgid ""
"<pre class=\"code\"> (defun my-symbol-value (name)\n"
"   (if (boundp name)\n"
"       (symbol-value name)\n"
"     (restart-case (error 'unbound-variable :name name)\n"
"       (use-value (value)\n"
"         :report \"Specify a value to use.\"\n"
"         :interactive (lambda ()\n"
"                        (format t \"~&amp;Value to use: \")\n"
"                        (list (eval (read))))\n"
"         value)\n"
"       (store-value (value)\n"
"         :report \"Specify a value to use and store.\"\n"
"         :interactive (lambda ()\n"
"                        (format t \"~&amp;Value to use and store: \")\n"
"                        (list (eval (read))))\n"
"         (setf (symbol-value name) value)\n"
"         value))))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1095
msgid ""
"<p>\n"
"Code that inquires about such restarts typically makes use of \n"
"<code>FIND-RESTART</code> to test for the availability of a restart,\n"
"and then <code>INVOKE-RESTART</code> to invoke a restart.\n"
"For example:\n"
"</p>"
msgstr ""
"<p>\n"
"Код, который запрашивает такие перезапуски, обычно использует \n"
"<code>FIND-RESTART</code> для проверки доступности перезапуска, \n"
"а затем <code>INVOKE-RESTART</code> для запуска перезапуска(restart). \n"
"Например: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1109
msgid ""
"<pre class=\"interaction\"> (handler-bind ((unbound-variable\n"
"                  #'(lambda (c) ;argument is condition description\n"
"                      ;; Try to make unbound variables get value 17\n"
"                      (dolist (tag '(store-value use-value))\n"
"                        (let ((restart (find-restart tag c)))\n"
"                          (when restart\n"
"                            (invoke-restart restart 17)))))))\n"
"   (+ (my-symbol-value 'this-symbol-has-no-value) \n"
"      (my-symbol-value 'pi))) ;pi DOES have a value!\n"
" =&gt; 20.141592653589793\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1115
msgid ""
"<p>\n"
"Absent such a handler, the restart would be offered interactively by\n"
"the debugger, as in:\n"
"</p>"
msgstr ""
"<p>\n"
"При отсутствии такого обработчика перезапуск будет предлагаться отладчиком \n"
"интерактивно, как в: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1130
msgid ""
"<pre class=\"interaction\"> (+ (my-symbol-value 'this-symbol-has-no-value) \n"
"    (my-symbol-value 'pi))\n"
" Error: The variable THIS-SYMBOL-HAS-NO-VALUE is unbound.\n"
" Please select a restart option:\n"
"   1 - Specify a value to use.\n"
"   2 - Specify a value to use and store.\n"
"   3 - Return to Lisp toplevel.\n"
"   4 - Exit from Lisp.\n"
" Option: 1\n"
" Value to use: 19\n"
" =&gt; 22.141592653589793\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1132
msgid "<h3>Handling in the Context of the Signaler</h3>"
msgstr "<h3>Обработка в контексте сигнализатора(Signaler)</h3>"

#: in_ed/Condition-Handling-2001.html:1141
msgid ""
"<p>\n"
"A key capability provided by Common Lisp is \n"
"the fact that, at the most primitive level,\n"
"handling can be done in the dynamic context of the signaler, while\n"
"certain very critical dynamic state information is still available\n"
"that would be lost if a stack unwind happened before running the handler.\n"
"</p>"
msgstr ""
"<p>\n"
"Ключевой возможностью, предоставляемой Common Lisp, является тот факт, \n"
"что на самом примитивном уровне обработка может выполняться в динамическом \n"
"контексте сигнализатора, в то время как определенная очень важная "
"информация \n"
"о динамическом состоянии все еще доступна, которая будет потеряна, если \n"
"раскрутка стека произойдет раньше запуска обработчика.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1155
msgid ""
"<p>\n"
"This capability is reflected in \n"
"the ability of the operator <code>handler-bind</code> to take \n"
"control of a computation <emph>before</emph> any transfer of\n"
"control occurs.  Note that the Common Lisp operator <code>handler-case</"
"code>,\n"
"which is more analogous to facilities offered in other languages,\n"
"does not allow programmer-supplied code to run until after the \n"
"transfer of control; this is useful for some simple situations, but is\n"
"less powerful.\n"
"</p>"
msgstr ""
"<p>\n"
"Эта возможность отражается в способности оператора <code>handler-bind</"
"code>\n"
"взять на себя управление вычислением <emph>до того</emph>, как произойдет \n"
"какая-либо передача управления. Обратите внимание, что оператор\n"
"<code>handler-case</code> а Common Lisp, который более аналогичен "
"средствам, \n"
"предлагаемым в других языках, не позволяет запускать код, поставляемый \n"
"программистом, до момента передачи управления; это полезно в некоторых \n"
"простых ситуациях, но менее эффективно.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1162
msgid ""
"<p>\n"
"Consider a code fragment such as:\n"
"</p>"
msgstr ""
"<p>\n"
"Рассмотрим такой фрагмент кода: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1168
msgid ""
"<pre class=\"code\"> (handler-case (main-action)\n"
"   (error (c) (other-action)))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1176
msgid ""
"<p>\n"
"In this example, the expression <code>(other-action)</code> will run\n"
"<emph>after</emph> unwinding from wherever in <code>(main-action)</code>\n"
"signaled the error, regardless of how deep into <code>main-action</code>\n"
"that signaling occured.\n"
"</p>"
msgstr ""
"<p>\n"
"В этом примере выражение <code>(other-action)</code> будет выполняться \n"
"<emph>после</emph> unwinding(раскрутки) из того места, где <code>(main-"
"action)</code>\n"
"сигнализировало об ошибке, независимо от того, насколько глубоко в "
"<code>main-action</code>\n"
"(основном действии) произошла сигнализация.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1187
msgid ""
"<p> \n"
"By contrast, <code>handler-bind</code> takes control <emph>inside</emph>\n"
"the dynamic context of the call to <code>SIGNAL</code>, and so is capable\n"
"of accessing restarts that are dynamically between the call to\n"
"<code>SIGNAL</code> and the use of <code>HANDLER-BIND</code>. \n"
"Consider this example:\n"
"</p>"
msgstr ""
"<p> \n"
"Напротив, <code>handler-bind</code> берет на себя управление <emph>внутри</"
"emph> \n"
"динамического контекста вызова <code>SIGNAL</code> и, таким образом, может "
"получать \n"
"доступ к перезапускам, которые динамически происходят между вызовом "
"<code>SIGNAL</code> \n"
"и использованием <code>HANDLER-BIND</code>. Рассмотрим этот пример: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1195
msgid ""
"<pre class=\"code\"> (with-simple-restart (foo \"Outer foo.\")\n"
"   (handler-case (with-simple-restart (foo \"Inner foo.\")\n"
"                   (error \"Lossage.\"))\n"
"      (error (c) (invoke-restart 'foo))))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1201
msgid ""
"<p>\n"
"In the above, the outer <code>FOO</code> restart will be selected, as "
"contrasted\n"
"with the following, where the inner <code>FOO</code> restart will be "
"selected:\n"
"</p>"
msgstr ""
"<p>\n"
"В приведенном выше примере будет выбран внешний перезапуск <code>FOO</code>, "
"в отличие \n"
"от следующего, где будет выбран внутренний перезапуск <code>FOO</code>: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1209
msgid ""
"<pre class=\"code\"> (with-simple-restart (foo \"Outer foo.\")\n"
"   (handler-bind ((error #'(lambda (c) (invoke-restart 'foo))))\n"
"     (with-simple-restart (foo \"Inner foo.\")\n"
"       (error \"Lossage.\"))))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1217
msgid ""
"<p>\n"
"This is important because error handling tends to want to make use of all\n"
"available restarts, but <emph>especially</emph> those that are in that code\n"
"region that <code>HANDLER-BIND</code> can see but <code>HANDLER-CASE</code>\n"
"cannot.  Consider another example:\n"
"</p>"
msgstr ""
"<p>\n"
"Это важно, потому что при обработке ошибок обычно используются все "
"доступные \n"
"перезапуски, но <emph>особенно</emph> те, которые находятся в той области "
"кода, \n"
"которую <code>HANDLER-BIND</code> может видеть, но <code>HANDLER-CASE</code> "
"не может. \n"
"Рассмотрим другой пример: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1225
msgid ""
"<pre class=\"code\"> (handler-case (foo)\n"
"   (unbound-variable (c)\n"
"     (let ((r (find-restart 'use-value c))) \n"
"       (if r (invoke-restart r nil)))))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1236
msgid ""
"<p>\n"
"The above example will not achieve its presumed intent, which is to \n"
"supply NIL as the default value for any unbound variable encountered\n"
"during the call to <code>FOO</code>.  The problem is that any \n"
"<code>USE-VALUE</code> restart that is likely to be found will also be\n"
"within the call to <code>FOO</code>, and will no longer be active \n"
"by the time the <code>ERROR</code> clause of the <code>HANDLER-CASE</code>\n"
"expression is executed.\n"
"</p>"
msgstr ""
"<p>\n"
"В приведенном выше примере не будет достигнута предполагаемая цель, \n"
"заключающаяся в предоставлении NIL в качестве значения по умолчанию \n"
"для любой несвязанной переменной, обнаруженной во время вызова <code>FOO</"
"code>. \n"
"Проблема в том, что любой перезапуск <code>USE-VALUE</code>, который, "
"вероятно, \n"
"будет обнаружен, также будет в рамках вызова <code>FOO</code> и больше не "
"будет \n"
"активен к моменту выполнения предложения <code>ERROR</code> выражения \n"
"<code>HANDLER-CASE</code>.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1245
msgid ""
"<p>\n"
"Use of <code>HANDLER-BIND</code> allows this example to work in a way\n"
"that is not possible with <code>HANDLER-CASE</code> and its analogs in\n"
"other programming languages.  Consider:\n"
"</p>"
msgstr ""
"<p>\n"
"Использование <code>HANDLER-BIND</code> позволяет этому примеру работать \n"
"способом, который невозможен с <code>HANDLER-CASE</code> и его аналогами \n"
"на других языках программирования. Рассмотрите: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1254
msgid ""
"<pre class=\"code\"> (handler-bind (error\n"
"                 #'(lambda (c)\n"
"                     (let ((r (find-restart 'use-value c))) \n"
"                       (if r (invoke-restart r nil)))))\n"
"   (foo))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1256
msgid "<h3>Default Handling</h3> "
msgstr "<h3>Обработка по умолчанию</h3> "

#: in_ed/Condition-Handling-2001.html:1265
msgid ""
"<p>\n"
"Zetalisp contained a facility not only for asserting handlers to be used\n"
"for conditions, but also an additional facility for asserting handlers\n"
"that should be provisionally used only if no normal handlers were found.\n"
"In effect, this meant there were two search lists, a handlers list and\n"
"a default handlers list, which were searched in order.\n"
"</p>"
msgstr ""
"<p>\n"
"Zetalisp содержал средство не только для asserting(утверждения) "
"обработчиков, \n"
"которые будут использоваться для условий, но также и дополнительное "
"средство \n"
"для утверждения обработчиков, которые должны временно использоваться только "
"в \n"
"том случае, если не были найдены нормальные обработчики. Фактически это "
"означало, \n"
"что существует два списка поиска, список обработчиков и список обработчиков "
"по \n"
"умолчанию, поиск в которых выполняется по порядку. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1284
msgid ""
"<p>\n"
"In my use of Zetalisp's NES, I became convinced that it was conceptually "
"incorrect\n"
"to search the default handlers list in order; I felt it should be searched\n"
"in reverse order.  I had reported this as a bug, but it was never fixed.\n"
"In all honesty, I'm not sure there was enough data then\n"
"or perhaps even now to say whether I was right, although I continue to \n"
"believe that default handling is something that should proceed from the\n"
"outside in, not the inside out.\n"
"Nevertheless, whether I was right or not is not so much relevant in this\n"
"context as is the fact that it was a point of controversy that ended up\n"
"influencing the design of Common Lisp's  condition system.  I was "
"distrustful\n"
"of the operator <code>condition-bind-default</code> that was offered by "
"NES,\n"
"and so I omitted it from the set of offerings that I transplanted to\n"
"Common Lisp.\n"
"</p>"
msgstr ""
"<p>\n"
"При использовании NES от Zetalisp я убедился, что поиск в списке "
"обработчиков \n"
"по умолчанию по порядку концептуально неверен; Я чувствовал, что "
"его(обработчик) \n"
"нужно искать в обратном порядке. Я сообщил об этом как об ошибке, но она так "
"и \n"
"не была исправлена. Честно говоря, я не уверен, что тогда или, возможно, "
"даже \n"
"сейчас было достаточно данных, чтобы сказать, был ли я прав, хотя я по-"
"прежнему считаю, \n"
"что обработка по умолчанию - это то, что должно происходить снаружи "
"вовнутрь, а не изнутри. \n"
"Тем не менее, был ли я прав или нет, в данном контексте не так важно, как "
"тот факт, \n"
"что это был предмет разногласий, который в конечном итоге повлиял на "
"разработку системы \n"
"условий Common Lisp. Я не доверял оператору <code>condition-bind-default</"
"code>, который \n"
"предлагала NES, и поэтому исключил его из набора предложений, которые я "
"перенес в \n"
"Common Lisp.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1294
msgid ""
"<p>\n"
"The Common Lisp Condition System <i>does</i> provide a way to implement the\n"
"concept of a default handler, but it is idiomatic.  And, perhaps not "
"entirely\n"
"coincidentally, it has the net effect of seeking default handlers from the\n"
"outside in rather than the inside out, as I had always felt was right.\n"
"</p>"
msgstr ""
"<p>\n"
"Система условий Common Lisp действительно предоставляет способ реализовать "
"концепцию \n"
"обработчика по умолчанию, но это идиоматично. И, возможно, не совсем "
"случайно, это \n"
"имеет чистый эффект поиска обработчиков по умолчанию снаружи вовнутрь, а не "
"изнутри, \n"
"как я всегда считал правильным.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1301
msgid ""
"<p>\n"
"The Zetalisp mechanism looked like this:\n"
"</p>"
msgstr ""
"<p>\n"
"Механизм Zetalisp выглядел так: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1309
msgid ""
"<pre class=\"code\">(condition-bind-default ((error\n"
"                            #'(lambda (c)\n"
"                                <i>...default handling...</i>)))\n"
"  <i>...body in which handler is in effect...</i>)\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1315
msgid ""
"<p>\n"
"The corresponding Common Lisp idiom looks like this:\n"
"</p>"
msgstr ""
"<p>\n"
"Соответствующая идиома Common Lisp выглядит так: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1324
msgid ""
"<pre class=\"code\">(handler-bind ((error\n"
"                 #'(lambda (c)\n"
"                     (signal c) ;resignal\n"
"                     <i>...default handling...</i>)))\n"
"  <i>...body in which handler is in effect...</i>)\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1334
msgid ""
"<p>\n"
"In effect, the Common Lisp idiom continues the signaling process \n"
"but without explicitly relinquishing control.  If the resignaled\n"
"condition is unhandled, control will return to this handler and the\n"
"default handling will be done.  If, on the other hand, some outer\n"
"handler does handle the condition, the default handling code will\n"
"never be reached and so will not be run.\n"
"</p>"
msgstr ""
"<p>\n"
"По сути, идиома Common Lisp продолжает процесс передачи сигналов, \n"
"но без явной передачи управления. Если отмененное условие не обработано, \n"
"управление вернется к этому обработчику, и будет выполнена обработка по "
"умолчанию. \n"
"Если, с другой стороны, некоторый внешний обработчик действительно "
"обрабатывает условие, \n"
"код обработки по умолчанию никогда не будет достигнут и поэтому не будет "
"запущен.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1341
msgid ""
"<!--\n"
"We later note that the correct behavior of this code relies on\n"
"the presence of the \"condition firewall\".\n"
"-->"
msgstr ""
"<!--\n"
"We later note that the correct behavior of this code relies on\n"
"the presence of the \"condition firewall\".\n"
"-->"

#: in_ed/Condition-Handling-2001.html:1343
msgid "<h3>Unifying \"Signals\" and \"Exceptions\"</h3>"
msgstr ""
"<h3>Объединение \"Signals\"(сигналов) и \"Exceptions\"(исключений)</h3>"

#: in_ed/Condition-Handling-2001.html:1350
msgid ""
"<p>\n"
"In some systems, such as Unix, \"signals\" are an asynchronous mechanism \n"
"primarily used for implementing event-driven programming interfaces, but\n"
"are not generally used within ordinary, synchronous programming.\n"
"</p>"
msgstr ""
"<p>\n"
"В некоторых системах, таких как Unix, \"signals\"(сигналы) представляют "
"собой \n"
"асинхронный механизм, который в основном используется для реализации "
"интерфейсов \n"
"программирования, управляемого событиями, но обычно не используется в "
"обычном \n"
"синхронном программировании. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1362
msgid ""
"<p>\n"
"While it is beyond the scope of the ANSI Common Lisp standard to address\n"
"the issue of either interrupts or multitasking, most Common Lisp\n"
"implementations have a convergent manner of coping with these issues \n"
"that is sufficiently stable as to be worth some mention.\n"
"The approach has been to separate the notion of \"interrupting\"\n"
"from the notion of \"signaling\".\n"
"</p>"
msgstr ""
"<p>\n"
"Хотя решение проблемы прерываний или многозадачности выходит за рамки \n"
"стандарта ANSI Common Lisp, большинство реализаций Common Lisp имеют \n"
"конвергентный способ справиться с этими проблемами, который достаточно \n"
"стабилен, чтобы о нем упомянуть. Подход заключался в том, чтобы отделить \n"
"понятие \"interrupting\"(прерывание) от понятия \"signaling"
"\"(сигнализация).\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1371
msgid ""
"<p>\n"
"That is, in Common Lisp, all signaling is synchronous.  <i>However,</i>\n"
"such synchronous behavior can be usefully coupled with\n"
"a process interruption to produce interesting effects.\n"
"</p>"
msgstr ""
"<p>\n"
"То есть в Common Lisp все сигналы синхронны. <i>Однако</i> такое \n"
"синхронное поведение может быть полезно сочетать с прерыванием процесса \n"
"для получения интересных эффектов.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1381
msgid ""
"<p>\n"
"In this separation, process interruptions without signaling might be\n"
"done for any reason that involved the need to read or modify dynamic\n"
"state of another process.  Here is an example that merely reads the\n"
"dynamic state of another process:\n"
"</p>"
msgstr ""
"<p>\n"
"При таком разделении прерывания процесса без сигнализации могут "
"происходить \n"
"по любой причине, связанной с необходимостью чтения или изменения "
"динамического \n"
"состояния другого процесса. Вот пример, который просто считывает "
"динамическое \n"
"состояние другого процесса: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1385
msgid "<pre class=\"interaction\"> (defvar *my-dynamic-variable* 1)"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1407
msgid ""
" (let ((temporary-process\n"
"          (mp:process-run-function \"temp\" '()\n"
"             ;; Launch a temporary process that\n"
"             ;;  merely dynamically binds a \n"
"             ;;  certain variable and then\n"
"             ;;  sleeps for a minute.\n"
"             #'(lambda ()\n"
"                 (let ((*my-dynamic-variable* 2)) \n"
"                   (sleep 60)))))\n"
"       (result-value nil))\n"
"   ;; Now interrupt our temporary process \n"
"   ;; to see the value of the variable\n"
"   (mp:process-interrupt temporary-process\n"
"     #'(lambda () \n"
"         (setq result-value *my-dynamic-variable*)))\n"
"   ;; Now wait for the interrupt to occur\n"
"   (mp:process-wait \"not yet assigned\"\n"
"     #'(lambda () result-value)) ;tests for a non-null value\n"
"   ;; If we get this far, the result-value has been assigned\n"
"   ;; and can be returned.\n"
"   result-value)"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1410
msgid ""
" =&gt; 2\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1418
msgid ""
"<p>\n"
"Note that this merely examines the dynamic state of our temporary process,\n"
"but does not invoke any signaling mechanism at all.  And while the process\n"
"of interruption is inherently asynchronous, the actions to be done in the\n"
"interrupted process are synchronous.  \n"
"</p>"
msgstr ""
"<p>\n"
"Обратите внимание, что этот код просто проверяет динамическое состояние "
"нашего \n"
"временного процесса, но не вызывает никакого механизма сигнализации. И хотя "
"процесс \n"
"прерывания по своей сути асинхронен, действия, которые необходимо выполнить "
"в \n"
"прерванном процессе, синхронны.  \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1429
msgid ""
"<p>\n"
"If we instead intertwine the notion of process interruption with signaling,\n"
"we get what some systems might call \"asynchronous signaling\", but which \n"
"Common Lisp views as just the composition of two orthogonal facilities.\n"
"So, for example, a keyboard interrupt to a process \n"
"might be accomplished by:\n"
"</p>"
msgstr ""
"<p>\n"
"Если мы вместо этого переплетаем понятие прерывания процесса с "
"сигнализацией, \n"
"мы получаем то, что некоторые системы могут назвать \"asynchronous signaling"
"\"(асинхронной\n"
" сигнализацией), но что Common Lisp рассматривает как просто композицию "
"двух \n"
"ортогональных средств. Так, например, клавиатурное прерывание процесса "
"может \n"
"быть выполнено следующим образом: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1437
msgid ""
"<pre class=\"code\"> (define-condition keyboard-interrupt ()\n"
"   ((character :initarg :character :reader kbd-char))\n"
"   (:report (lambda (condition stream)   \n"
"              (format t \"The character ~@:C was typed.\"\n"
"                      (kbd-char condition)))))"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1447
msgid ""
" (defun keyboard-interrupt (process character)\n"
"   (mp:process-interrupt process\n"
"      #'(lambda ()\n"
"          ;; Offer the process a chance to handle the condition.\n"
"          ;; If the condition is not handled, the call to SIGNAL returns\n"
"          ;; and the interrupt is completed.  Normal process execution\n"
"          ;; then continues.\n"
"          (signal 'keyboard-interrupt :character character))))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1454
msgid ""
"<p>\n"
"Using such a facility, a keyboard process (itself a synchronous activity)\n"
"can asynchronously interrupt another process (presumably, the window \n"
"selected at the point an interrupt character is seen).\n"
"</p>"
msgstr ""
"<p>\n"
"Используя такое средство, процесс клавиатуры (сам по себе является \n"
"синхронной деятельностью) может асинхронно прерывать другой процесс \n"
"(предположительно, окно, выбранное в точке, где виден символьный\n"
"знак прерывания). \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1458
msgid "<pre class=\"code\">(defvar *selected-window* nil)"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1468
msgid ""
"(defun keyboard-process (raw-keyboard-stream)\n"
"  (loop (let ((char (read-char raw-keyboard-stream)))\n"
"          (when *selected-window*\n"
"            (if (is-interrupt-character? char)\n"
"                (keyboard-interrupt (window-process *selected-window*)\n"
"                                    char)\n"
"                ;; otherwise...\n"
"                (add-to-input-buffer *selected-window* char))))))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1477
msgid ""
"<p>\n"
"Although the <code>KEYBOARD-PROCESS</code> shown here will interrupt the\n"
"window process, an understanding of what happens at that point does not\n"
"require any special knowledge of asynchrony.  It merely requires observing\n"
"that at the time of interruption, the other process was about to execute\n"
"some expression <code>(exp)</code> and will now execute instead\n"
"</p>"
msgstr ""
"<p>\n"
"Хотя показанный здесь <code>KEYBOARD-PROCESS</code> прервет оконный "
"процесс, \n"
"понимание того, что происходит в этот момент, не требует каких-либо "
"специальных \n"
"знаний об асинхронности. Это просто требует наблюдения, что во время "
"прерывания \n"
"другой процесс собирался выполнить какое-то выражение <code>(exp)</code> и \n"
"теперь будет выполняться вместо \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1482
msgid ""
"<pre class=\"code\">(progn (funcall <i>interrupt-function</i>) (exp))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1494
msgid ""
"<p>\n"
"This kind of structured approach removes much of the mystery and\n"
"unpredictability normally associated with asynchronous interrupts\n"
"in other systems, where the description of the effect is often not\n"
"linguistic at all but deals in overly concrete terms of bits and registers\n"
"in a way that only career experts can hope to navigate.\n"
"The sense in the Common Lisp community is that a correct conceptual\n"
"treatment of these issues makes these sorts of capabilities something\n"
"that \"mere mortals\" can safely and conveniently employ in their "
"programming.\n"
"</p>"
msgstr ""
"<p>\n"
"Такой структурированный подход устраняет большую часть таинственности и \n"
"непредсказуемости, обычно связанных с асинхронными прерываниями в \n"
"других системах, где описание эффекта часто вовсе не лингвистическое, а \n"
"имеет дело с чрезмерно конкретными терминами битов и регистров таким "
"образом, \n"
"что только профессиональные специалисты можно надеяться сориентироваться. \n"
"Сообщество Common Lisp считает, что правильная концептуальная трактовка \n"
"этих проблем делает такие возможности чем-то, что «простые смертные» могут \n"
"безопасно и удобно использовать в своем программировании. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1498
msgid "<h2>Open Issues</h2>"
msgstr "<h2>Открытые вопросы</h2>"

#: in_ed/Condition-Handling-2001.html:1509
msgid ""
"<p>\n"
"The Dylan language patterned its efforts after the Common Lisp Condition\n"
"System, but made some interesting changes.\n"
"I probably lack the appropriate experience and surely the appropriate \n"
"objectivity to conclude whether their changes are clear improvements\n"
"over the Common Lisp approaches.  But it's plain that by making divergent\n"
"decisions in some places, the Dylan community has identified certain areas\n"
"of the Common Lisp design as \"controversial\".\n"
"</p>"
msgstr ""
"<p>\n"
"Язык Dylan по образцу системы условий Common Lisp, но внес некоторые "
"интересные \n"
"изменения. Мне, вероятно, не хватает соответствующего опыта и, конечно же, \n"
"соответствующей объективности, чтобы сделать вывод о том, являются ли их \n"
"изменения явным улучшением подходов Common Lisp. Но очевидно, что, приняв \n"
"в некоторых местах различные решения, сообщество Dylan определило "
"определенные \n"
"области проектирования Common Lisp как «спорные». \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1513
msgid "<h3>Restarts vs Handlers</h3>"
msgstr "<h3>Перезапуски против обработчиков</h3>"

#: in_ed/Condition-Handling-2001.html:1526
msgid ""
"<p>\n"
"Common Lisp provides parallel but unrelated operators such as \n"
"<code>HANDLER-BIND</code> and <code>HANDLER-CASE</code>\n"
"for dealing with handlers, and \n"
"<code>RESTART-BIND</code> and <code>RESTART-CASE</code>\n"
"for dealing with restarts.  It was thought\n"
"that these were orthogonal operations, requiring unrelated dataflow,\n"
"that really didn't belong intermingled.  The Dylan community has sought\n"
"to coalesce these by making restarts into a kind of condition, and \n"
"eliminating special binding forms for them.\n"
"</p>"
msgstr ""
"<p>\n"
"Common Lisp предоставляет параллельные, но не связанные между собой "
"операторы, \n"
"такие как <code>HANDLER-BIND</code> и <code>HANDLER-CASE</code> для работы "
"с \n"
"обработчиками, и <code>RESTART-BIND</code> и <code>RESTART-CASE</code> для \n"
"работы с перезапусками. Считалось, что это ортогональные операции, "
"требующие \n"
"несвязанного потока данных, которые на самом деле не должны были "
"смешиваться. \n"
"Сообщество Dylan стремилось объединить их, превратив перезапуски в своего "
"рода \n"
"условие и устранив для них особые формы связывания. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1530
msgid "<h3>The \"Condition Firewall\"</h3>"
msgstr "<h3>\"Брандмауэр условий\"(Condition Firewall)</h3>"

#: in_ed/Condition-Handling-2001.html:1539
msgid ""
"<p>\n"
"Probably the most controversial semantic component of the Common Lisp \n"
"condition system is what has come to be called the \"condition firewall\".\n"
"The idea behind the condition firewall is that a given handler should \n"
"be executed in an environment that does not \"see\" intervening handlers\n"
"that might have been established since its establishment.\n"
"</p>"
msgstr ""
"<p>\n"
"Вероятно, наиболее спорным семантическим компонентом системы условий \n"
"Common Lisp является то, что стало называться \"condition firewall"
"\"(брандмауэром \n"
"условий). Идея, лежащая в основе брандмауэра условий, заключается в том, \n"
"что данный обработчик должен выполняться в среде, которая не «видит» \n"
"промежуточные обработчики, которые могли быть установлены с момента \n"
"его создания.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1546
msgid ""
"<p>\n"
"So, for example, consider this code:\n"
"</p>"
msgstr ""
"<p>\n"
"Так, например, рассмотрим этот код: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1559
msgid ""
"<pre class=\"code\"> (handler-case \n"
"     (handler-bind ((error \n"
"                      #'(lambda (condition)\n"
"                          (declare (ignore condition)) \n"
"                          (error 'unbound-variable :name 'fred))))\n"
"        (handler-case ;; Signal an arbitrary error:\n"
"                      (error \"Not an UNBOUND-VARIABLE error.\")\n"
"          (unbound-variable (c) (list 'inner c))))\n"
"   (unbound-variable (c) (list 'outer c)))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1574
msgid ""
"<p>\n"
"This sets up two handlers for conditions of class\n"
"<code>UNBOUND-VARIABLE</code>, one outside of the scope of the\n"
"general-purpose handler for conditions of class <code>ERROR</code> and\n"
"one inside of its scope.  At the time the \"arbitrary\" error\n"
"signaled, both handlers are in effect.  This means that if the error\n"
"being signaled <emph>had</emph> been of class\n"
"<code>UNBOUND-VARIABLE</code>, it would have been caught by the inner\n"
"<code>HANDLER-CASE</code> for <code>UNBOUND-VARIABLE</code>.  However,\n"
"as the search for a handler proceeds outward, the handlers that are\n"
"tried are executed in a context where the inner handlers are no longer\n"
"visible.  As such, the above example yields\n"
"</p>"
msgstr ""
"<p>\n"
"Этот код устанавливает два обработчика для условий класса <code>UNBOUND-"
"VARIABLE</code>, \n"
"один вне области действия универсального обработчика для условий класса \n"
"<code>ERROR</code>, а другой - внутри его области. В то время, когда "
"сигнализируется \n"
"\"произвольная\" ошибка, действуют оба обработчика. Это означает, что если "
"бы \n"
"сообщаемая ошибка была класса <code>UNBOUND-VARIABLE</code>, она была бы "
"обнаружена \n"
"внутренним <code>HANDLER-CASE</code> для <code>UNBOUND-VARIABLE</code>. "
"Однако \n"
"по мере того, как поиск обработчика продолжается вовне, проверенные "
"обработчики \n"
"выполняются в контексте, в котором внутренние обработчики больше не видны. \n"
"Таким образом, приведенный выше пример дает \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1579
msgid ""
"<pre class=\"code\"> (OUTER #&lt;ERROR UNBOUND-VARIABLE 12A39B87&gt;)\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1584
msgid ""
"<p>\n"
"By contrast, the following code:\n"
"</p>"
msgstr ""
"<p>\n"
"Напротив, следующий код: \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1595
msgid ""
"<pre class=\"code\"> (handler-case \n"
"     (handler-bind ((error #'(lambda (condition)\n"
"                               (declare (ignore condition)) \n"
"                               (error 'unbound-variable :name 'fred))))\n"
"       (handler-case (error 'unbound-variable :name 'marvin)\n"
"         (unbound-variable (c) (list 'inner c))))\n"
"   (unbound-variable (c) (list 'outer c)))\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1600
msgid ""
"<p>\n"
"yields \n"
"</p>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1605
msgctxt "in_ed/Condition-Handling-2001.html:1605"
msgid ""
"<pre class=\"code\"> (INNER #&lt;ERROR UNBOUND-VARIABLE 12A39B87&gt;)\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1615
msgid ""
"<p>\n"
"It is interesting to note as an aside that the \"resignaling trick\"\n"
"used earlier in the discussion of default handling relies implicitly \n"
"on the condition firewall in order to avoid infinite recursion.\n"
"Without the condition firewall, a different mechanism for implementing\n"
"default handling is needed.\n"
"</p>"
msgstr ""
"<p>\n"
"Интересно отметить в качестве отступления, что \"resignaling trick\"(трюк \n"
"с изменением сигнала), использованный ранее при обсуждении обработки по "
"умолчанию, \n"
"неявно полагается на брандмауэр условий(condition firewall), чтобы "
"избежать \n"
"бесконечной рекурсии. Без брандмауэра условий необходим другой механизм "
"для \n"
"реализации обработки по умолчанию.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1630
msgid ""
"<p>\n"
"The designers of the Dylan language chose to eliminate the condition\n"
"firewall, perhaps out of necessity since the most useful restarts \n"
"almost always occur in the dynamic space near the point of signal,\n"
"and the handlers usually occur farther out.  If handlers could only see\n"
"the restarts farther out than where they were established, they would \n"
"not see the most useful restarts.  (I am personally doubtful of this \n"
"argument, and am more inclined to believe that this is why restarts should\n"
"not have been turned into a kind of condition in Dylan, but I could\n"
"be wrong and time will tell.)\n"
"</p>"
msgstr ""
"<p>\n"
"Разработчики языка Дилана решили исключить условный брандмауэр, возможно, \n"
"по необходимости, поскольку наиболее полезные перезапуски почти всегда "
"происходят \n"
"в динамическом пространстве рядом с точкой сигнала, а обработчики обычно \n"
"происходят дальше. Если бы обработчики могли видеть перезапуски только "
"дальше, \n"
"чем там где они были установлены, они не увидели бы наиболее полезных "
"перезапусков. \n"
"(Я лично сомневаюсь в этом аргументе и более склонен полагать, что именно "
"поэтому \n"
"перезапуски не должны были превращаться в своего рода условия в Дилане, \n"
"но я могу ошибаться, и время покажет.)\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1639
msgid ""
"<p>\n"
"The Dylan notation is different in many ways from Common Lisp,\n"
"but the approximately equivalent code\n"
"to the above two examples would <emph>both</emph>, I believe, return \n"
"</p>"
msgstr ""
"<p>\n"
"Нотация Дилана во многом отличается от Common Lisp, но код, примерно \n"
"эквивалентный <emph>обоим</emph> приведенным выше примерам, как я полагаю, "
"вернет \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1644
msgctxt "in_ed/Condition-Handling-2001.html:1644"
msgid ""
"<pre class=\"code\"> (INNER #&lt;ERROR UNBOUND-VARIABLE 12A39B87&gt;)\n"
"</pre>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1648
msgid ""
"<!-- Bernie Greenberg, in reviewing this document \n"
"     notes the following, which didn't seem appropriate\n"
"    for this document, but was something I didn't want to lose:"
msgstr ""
"<p>Отступление <br>\n"
"\tБерни Гринберг, просматривая этот документ, отмечает следующее, \n"
"\tчто не казалось подходящим для этого документа, но \n"
"\tя не хотел терять:\n"
"</p> "

#: in_ed/Condition-Handling-2001.html:1655
msgid ""
"Speaking of firewalls, the Multics condition system used\n"
"\"any_other\" (handle any condition not otherwised named) each time\n"
"a new command shell was pushed on the stack by (say) an error\n"
"(there were often several command levels on the stack in one\n"
"process). This would prevent an earlier command environment from\n"
"handling an unclaimed error in a more recent one."
msgstr ""
"<p>\n"
"Говоря о брандмауэрах, система условий Multics использовала «any_other» \n"
"(обрабатывать любое условие, не названное иначе) каждый раз, когда новая \n"
"командная оболочка помещалась в стек (скажем) из-за ошибки (часто в одном \n"
"процессе в стеке было несколько уровней команд. ). Это помешало бы более \n"
"ранней командной среде обрабатывать невостребованную ошибку в более "
"поздней. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1659
msgid ""
"An exception was made for the \"program_interrupt\" condition, which\n"
"was usually used to restore control to an earlier, interrupted\n"
"command environment."
msgstr ""
"<p>\n"
"Исключение было сделано для условия «program_interrupt», которое обычно \n"
"использовалось для восстановления управления ранее прерванного командной \n"
"средой. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1664
msgid ""
"Note also that for hardware-originated conditions (e.g., divide error,\n"
"paging exception) the condition data passed by signal_ included an image\n"
"of the machine state, subject to both inspection and modification, which\n"
"had to be security-validated by the supervisor upon restart."
msgstr ""
"<p>\n"
"Также обратите внимание, что для условий, вызванных аппаратным "
"обеспечением \n"
"(например, ошибка деления, исключение сегментации страниц), данные "
"условия, \n"
"переданные signal_, включали образ состояния машины, подлежащий как "
"проверке, \n"
"так и изменению, которое должно было быть подтверждено системой "
"безопасности \n"
"при перезапуске. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1666
msgid "-->"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1669
msgid "<h2>Summary</h2>"
msgstr "<h2>Резюме</h2>"

#: in_ed/Condition-Handling-2001.html:1681
msgid ""
"<p>\n"
"Language features don't originate spontaneously out of nowhere.\n"
"We have surveyed some of the origins of the Common Lisp Condition System\n"
"in an effort to demonstrate how prior experiences, both good and bad,\n"
"have influenced the present design.  Nor is this the end of the story.\n"
"The ideas in Common Lisp have had some influence on other languages \n"
"and will, I hope, continue to do so, since there are a number of \n"
"things the Common Lisp  makes easy through its condition system that\n"
"other languages do not.\n"
"</p>"
msgstr ""
"<p>\n"
"Языковые особенности не возникают спонтанно из ниоткуда. Мы рассмотрели \n"
"некоторые из истоков Common Lisp Condition System, чтобы "
"продемонстрировать, \n"
"как предыдущий опыт, как хороший, так и плохой, повлиял на нынешний "
"проект. \n"
"И это еще не конец истории. Идеи Common Lisp оказали некоторое влияние на \n"
"другие языки и, я надеюсь, продолжат это делать, поскольку есть ряд вещей, \n"
"которые Common Lisp упрощает посредством своей системы условий, чего не \n"
"делают другие языки.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1688
msgid ""
"<p>\n"
"We have also seen that good terminology is important both to the \n"
"specification of a programming language and to its community acceptance."
msgstr ""
"<p>\n"
"Мы также убедились, что хорошая терминология важна как для спецификации \n"
"языка программирования, так и для признания его сообществом. "

#: in_ed/Condition-Handling-2001.html:1695
msgid ""
"Programming\n"
"is not only a technical endeavor, but a social one.  So much of so many\n"
"lives is spent doing programming, that it is critical that we have good\n"
"terminology, beyond the terms of the language itself, for talking among\n"
"each other about what we are doing within the language.\n"
"</p>"
msgstr ""
"Программирование - это занятие не только техническое, но и социальное. \n"
"Так много жизней уходит на программирование, поэтому очень важно, чтобы у "
"нас \n"
"была хорошая терминология, выходящая за рамки самого языка, для того, "
"чтобы \n"
"разговаривать друг с другом о том, что мы делаем в этом языке.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1705
msgid ""
"<p>\n"
"And we have surveyed some of the key features that distinguish Common "
"Lisp's\n"
"condition system from those offered by other languages, and highlighted\n"
"some open issues, where Common Lisp's answers to certain problems have \n"
"already met with challenges.\n"
"</p>"
msgstr ""
"<p>\n"
"И мы рассмотрели некоторые ключевые особенности, которые отличают систему \n"
"условий Common Lisp от систем, предлагаемых другими языками, и выделили \n"
"некоторые открытые проблемы, ответы на которые Common Lisp на определенные \n"
"проблемы уже столкнулись с трудностями. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1709
msgid "<h3><a name=\"footnote\">A Personal Footnote</a></h3>"
msgstr "<h3><a name=\"footnote\">Личная сноска</a></h3>"

#: in_ed/Condition-Handling-2001.html:1719
msgid ""
"<p>\n"
"During the design of Common Lisp, I headed the committee that produced\n"
"the design of the condition system.  At that time, there were many\n"
"questions and doubts about the design: Were the decisions sound?  Were\n"
"all of the alternatives explored, or were there better ways we might\n"
"later wish we'd tried?  Were there problems lurking under the surface,\n"
"waiting to bite someone when used under heavier stress?\n"
"</p>"
msgstr ""
"<p>\n"
"Во время разработки Common Lisp я возглавлял комитет, который занимался \n"
"разработкой системы условий. В то время было много вопросов и сомнений по \n"
"поводу проектирования: были ли принятые решения правильными? Были ли "
"изучены \n"
"все альтернативы, или есть лучшие способы, которые мы могли бы позже "
"попробовать? \n"
"Были ли проблемы, скрывающиеся под поверхностью, ожидающие, чтобы кого-"
"нибудь \n"
"укусить, когда их использовали в более тяжелых условиях? \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1736
msgid ""
"<p>\n"
"It wasn't that people doubted our committee's competence, but rather\n"
"many would-be reviewers lacked the relevant experience to critically\n"
"analyze our proposals.  Yet the design seemed mostly right to me, and my\n"
"larger concern was that if we didn't at some point release it to a\n"
"community of users to try, we'd be back at the same design table a few\n"
"years later with the same questions and the same lack of community\n"
"experience to answer them.  A leap of faith seemed to be required to move\n"
"ahead.  So I and my committee nodded our collective heads and said we \n"
"stood by the design.  Personally, I had some doubts about some details, \n"
"but I found it counterproductive to raise them because I believed the \n"
"risk of not trying these things out was higher than the risk of trying "
"them.\n"
"</p>"
msgstr ""
"<p>\n"
"Дело не в том, что люди сомневались в компетентности нашего комитета, \n"
"а скорее в том, что многим потенциальным рецензентам не хватало "
"соответствующего \n"
"опыта для критического анализа наших предложений. Тем не менее, проект \n"
"казался мне в основном правильным, и меня больше беспокоило то, что, если "
"мы \n"
"в какой-то момент не представим его сообществу пользователей, чтобы "
"попробовать, \n"
"мы вернемся к той же таблице проектирования через несколько лет с тем же "
"самым \n"
"вопросом и тем же отсутствием опыта в сообществе, чтобы на них ответить. \n"
"Казалось, что для того, чтобы двигаться вперед, требовался прыжок веры. "
"Итак, \n"
"я и мой комитет кивнули нашим коллективным головам и сказали, что мы "
"поддерживаем проект. \n"
"Лично у меня были некоторые сомнения по поводу некоторых деталей, но я "
"счел \n"
"контрпродуктивным поднимать их, потому что я считал, что риск не попробовать "
"эти \n"
"вещи выше, чем риск попробовать их.\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1748
msgid ""
"<p>\n"
"In my experience, much of language design is like this.  We \n"
"<i>think</i> we know how it will all come out, but we don't always.  Usage\n"
"patterns are often surprising, as one learns if one is around long\n"
"enough to design a language or two and then watch how expectations\n"
"play out in reality over a course of years.  So it's a gamble.  But\n"
"the only way not to gamble is not to move ahead.\n"
"</p>"
msgstr ""
"<p>\n"
"По моему опыту, большая часть языкового проекта похожа на это. Мы <i>думаем</"
"i>, \n"
"что знаем, чем все это закончится, но не всегда. Паттерны использования "
"часто \n"
"удивительны, поскольку человек узнает, достаточно ли он существует, чтобы \n"
"разработать язык или два, а затем наблюдать, как ожидания разыгрываются в \n"
"действительности в течение многих лет. Так что это авантюра. Но "
"единственный \n"
"способ не играть в азартные игры - не двигаться вперед. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1763
msgid ""
"<p>\n"
"I once saw an interview on television with a font designer from\n"
"Bitstream Inc. about how he conceptualized the process of font design.\n"
"It is not about designing the shape of the letters, he explained, much\n"
"to my initial surprise.  Then he went on to explain that it was really\n"
"about the shape of words.  The font shapes play into that, but they\n"
"are not, in themselves, the end goal.  Programming language design is\n"
"like that, too.  It's not about the semantics of individual operators,\n"
"but about how those operators fit together to form sentences in\n"
"programs.\n"
"</p>"
msgstr ""
"<p>\n"
"Однажды я увидел по телевидению интервью с дизайнером шрифтов из Bitstream "
"Inc. \n"
"о том, как он концептуализирует процесс дизайна шрифтов. «Речь идет не о "
"разработке \n"
"формы букв, - пояснил он, к моему первоначальному удивлению. Затем он "
"объяснил, \n"
"что на самом деле, дело в форме слов. Формы шрифта играют в этом роль, но "
"сами \n"
"по себе не являются конечной целью. Разработка языков программирования тоже "
"похожа. \n"
"Дело не в семантике отдельных операторов, а в том, как эти операторы "
"сочетаются друг \n"
"с другом для формирования предложений(высказываний) в программах.\n"
"\n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1782
msgid ""
"<p>\n"
"Unlike the situation with fonts, where whole books can be viewed\n"
"instantly in a new font to see how the design works, we don't know in\n"
"advance what sentences will be made in a programming language.  We\n"
"have to wait and see what people choose to write.  Common Lisp took a\n"
"step forward, and while we can quibble endlessly over whether any\n"
"given design decision was right, the one design decision I'm most\n"
"certain was right was to offer the community a rich set of\n"
"capabilities that would empower them not only to write programs, but\n"
"also to have a stake in future designs.  Never again will I fear\n"
"sending out e-mail to a design group asking for advice about what the\n"
"semantics of <code>HANDLER-BIND</code> should be and finding that no one "
"has\n"
"an opinion!  To me, that kind of progress, the evolution of a whole\n"
"community's understanding, is the best kind of progress of all.\n"
"</p>"
msgstr ""
"<p>\n"
"В отличие от ситуации со шрифтами, когда целые книги можно мгновенно "
"просматривать \n"
"с новым шрифтом, чтобы увидеть, как работает дизайн, мы не знаем заранее, \n"
"какие предложения будут составлены на языке программирования. Мы должны "
"подождать \n"
"и посмотреть, что люди предпочитают писать. Common Lisp сделал шаг вперед, "
"и, \n"
"хотя мы можем бесконечно спорить о правильности того или иного проектного "
"решения, \n"
"единственное проектное решение, которое, я уверен, было правильным, "
"заключалось в том, \n"
"чтобы предложить сообществу богатый набор возможностей, которые дадут им "
"возможность \n"
"не только писать программы, но также иметь долю в будущих проектах. Никогда "
"больше \n"
"я не буду бояться послать электронное письмо группе разработчиков с просьбой "
"дать совет\n"
"о семантике <code>HANDLER-BIND</code> и обнаружить, что ни у кого нет "
"мнения! \n"
"Для меня такой прогресс, развитие понимания всего сообщества - лучший из "
"всех \n"
"видов прогресса. \n"
"</p>"

#: in_ed/Condition-Handling-2001.html:1786
msgid "<h2>Acknowledgements</h2>"
msgstr "<h2>Благодарности</h2>"

#: in_ed/Condition-Handling-2001.html:1796
msgid ""
"<p>\n"
"I would like to thank Keith Corbett, Christophe Dony,\n"
"Bernard Greenberg, and Erik Naggum for \n"
"reviewing drafts of this text.  Any lingering errors after they got done \n"
"looking at it are still my responsibility, but I'm quite sure the \n"
"editorial, technical, and historical quality of this text was improved\n"
"measurably through their helpful scrutiny.\n"
"</p>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1800
msgid "<h2>Bibliography</h2>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1802
msgid "<dl>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1806
msgid ""
"<dt><a name=\"multicians-2000\">[Multicians 2000]</a></dt>\n"
"<dd>Historical references to Multics can probably best be obtained from<br>\n"
"<a href=\"http://www.multicians.org/\"><tt class=\"urlref\">http://www."
"multicians.org/</tt></a>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1812
msgid ""
"</dd><dt><a name=\"pitman-1983\">[Pitman 1983]</a></dt>\n"
"<dd>Kent M. Pitman, <i>The Revised Maclisp Manual</i>,\n"
"Technical Report 295, MIT Laboratory for Computer Science,\n"
"Cambridge, MA, May 1983.\n"
"</dd>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1820
msgid ""
"<dt><a name=\"pitman-1990\">[Pitman 1990]</a></dt>\n"
"<dd>Kent M. Pitman, \"Exceptional Situations in Lisp\",\n"
"proceedings for the\n"
"First European Conference on the Practical Application of Lisp "
"(EUROPAL'90),\n"
"Churchill College, Cambridge, UK, March 27-29, 1990.<br>\n"
"<a href=\"http://www.nhplace.com/kent/Papers/Exceptional-Situations-1990.html"
"\"><tt class=\"urlref\">http://www.nhplace.com/kent/Papers/Exceptional-"
"Situations-1990.html</tt></a>\n"
"</dd>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1831
msgid ""
"<dt><a name=\"smith-1982\">[Smith 1982]</a></dt>\n"
"<dd>B.C. Smith, <i>Reflection and Semantics in a Procedural Language</i>,\n"
"Technical Report 272, MIT Laboratory for Computer Science,\n"
"Cambridge, MA, January 1982.\n"
"<!-- \n"
"It appears that this should be available at\n"
"ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-272.ps.gz \n"
"however it's missing.\n"
"-->\n"
"</dd>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1836
msgid ""
"<dt><a name=\"x3j13-1994\">[X3J13 1994]</a></dt>\n"
"<dd><i>American National Standard for Information Systems--Programming "
"Language--Common Lisp</i> (X3.226-1994)<br>\n"
"<a href=\"http://www.lispworks.com/documentation/HyperSpec/Front/\"><font "
"color=\"green\"><tt class=\"urlref\">http://www.lispworks.com/documentation/"
"HyperSpec/Front/</tt></font></a>\n"
"</dd>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1841
msgid ""
"<dt><a name=\"weinreb-1981\">[Weinreb 1983]</a></dt>\n"
"<dd>D.L. Weinreb and D.A. Moon, <i>Lisp Machine Manual</i>,\n"
"MIT Artificial Intelligence Laboratory, Cambridge, MA, July 1981. \n"
"</dd>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1843
msgid "</dl>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1845
msgctxt "in_ed/Condition-Handling-2001.html:1845"
msgid "<hr>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1847
msgctxt "in_ed/Condition-Handling-2001.html:1847"
msgid "<font color=\"green\">"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1853
msgid ""
"<p><a name=\"COPYRIGHT\">\n"
"Original printed text document<br>\n"
"<b>Copyright 2001 by Kent M. Pitman. All Rights Reserved.</b>\n"
"</a></p>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1863
msgid ""
"<p>\n"
"HTML hypertext version of document<br>\n"
"<b>Copyright 2002, Kent M. Pitman.  All rights reserved.</b><br>\n"
"The following limited, non-exclusive, \n"
"revokable licenses are granted:\n"
"</p>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1867
msgctxt "in_ed/Condition-Handling-2001.html:1867"
msgid "<blockquote>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1875
msgid ""
"<p>\n"
"Browsing of this document (that is, transmission and display of a temporary\n"
"copy of this document for the ordinary purpose of direct viewing by a \n"
"human being in the usual manner that hypertext browsers permit such\n"
"viewing) is expressly permitted, provided that no recopying, \n"
"redistribution, redisplay, or retransmission is made of any such copy.\n"
"</p>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1887
msgid ""
"<p>\n"
"Bookmarking of this document (that is, recording only the document's title "
"and \n"
"Uniform Resource Locator, or URL, but not its content,\n"
"for the purpose of remembering an association between the document's title\n"
"and the URL, and/or for the purpose of making a subsequent request \n"
"for a fresh copy of the content named by that URL)\n"
"is also expressly permitted.\n"
"</p>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1890
msgctxt "in_ed/Condition-Handling-2001.html:1890"
msgid "</blockquote>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1895
msgid ""
"<p>\n"
"All other uses require negotiated permission.\n"
"</p>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1899
msgctxt "in_ed/Condition-Handling-2001.html:1899"
msgid "</font>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1901
msgctxt "in_ed/Condition-Handling-2001.html:1901"
msgid "<hr>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1906
msgid ""
"<p align=\"center\">\n"
"<a href=\"http://www.nhplace.com/kent/Papers/index.html\"><i>Click here for "
"an index \n"
"of other titles by Kent Pitman.</i></a>\n"
"</p>"
msgstr ""

#: in_ed/Condition-Handling-2001.html:1913
msgid "</body></html>"
msgstr ""

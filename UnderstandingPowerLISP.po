#
# NuINu <don't@send.my>, 2022.
#
#. extracted from in_ed/UnderstandingPowerLISP.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-05 11:48+0300\n"
"PO-Revision-Date: 2022-01-05 15:29+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in_ed/UnderstandingPowerLISP.html:27
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n"
"<html>\n"
"<head>\n"
"\t<meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"/>\n"
"\t<title></title>\n"
"\t<meta name=\"generator\" content=\"LibreOffice 6.0.7.3 (Linux)\"/>\n"
"\t<meta name=\"created\" content=\"2022-01-05T11:13:29.493263733\"/>\n"
"\t<meta name=\"changed\" content=\"2022-01-05T11:29:31.940450377\"/>\n"
"\t<style type=\"text/css\">\n"
"\t\t@page { margin: 2cm }\n"
"\t\tp { margin-bottom: 0.25cm; line-height: 115% }\n"
"\t\th1 { margin-bottom: 0.21cm }\n"
"\t\th1.western { font-family: \"Liberation Serif\", serif }\n"
"\t\th1.cjk { font-family: \"Noto Sans CJK SC\"; font-size: 24pt }\n"
"\t\th1.ctl { font-family: \"Lohit Devanagari\"; font-size: 24pt }\n"
"\t\th2.cjk { font-family: \"Noto Sans CJK SC\" }\n"
"\t\th2.ctl { font-family: \"Lohit Devanagari\" }\n"
"\t\tpre.cjk { font-family: \"Courier New\", monospace }\n"
"\t\th3.cjk { font-family: \"Noto Sans CJK SC\" }\n"
"\t\th3.ctl { font-family: \"Lohit Devanagari\" }\n"
"\t\ta:link { so-language: zxx }\n"
"\t\tcode.cjk { font-family: \"Courier New\", monospace }\n"
"\t</style>\n"
"</head>\n"
"<body lang=\"en-US\" dir=\"ltr\">\n"
"<h1 class=\"western\">Understanding the Power of LISP</h1>"
msgstr ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n"
"<html>\n"
"<head>\n"
"\t<meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"/>\n"
"\t<title></title>\n"
"\t<meta name=\"generator\" content=\"LibreOffice 6.0.7.3 (Linux)\"/>\n"
"\t<meta name=\"created\" content=\"2022-01-05T11:13:29.493263733\"/>\n"
"\t<meta name=\"changed\" content=\"2022-01-05T11:29:31.940450377\"/>\n"
"\t<style type=\"text/css\">\n"
"\t\t@page { margin: 2cm }\n"
"\t\tp { margin-bottom: 0.25cm; line-height: 115% }\n"
"\t\th1 { margin-bottom: 0.21cm }\n"
"\t\th1.western { font-family: \"Liberation Serif\", serif }\n"
"\t\th1.cjk { font-family: \"Noto Sans CJK SC\"; font-size: 24pt }\n"
"\t\th1.ctl { font-family: \"Lohit Devanagari\"; font-size: 24pt }\n"
"\t\th2.cjk { font-family: \"Noto Sans CJK SC\" }\n"
"\t\th2.ctl { font-family: \"Lohit Devanagari\" }\n"
"\t\tpre.cjk { font-family: \"Courier New\", monospace }\n"
"\t\th3.cjk { font-family: \"Noto Sans CJK SC\" }\n"
"\t\th3.ctl { font-family: \"Lohit Devanagari\" }\n"
"\t\ta:link { so-language: zxx }\n"
"\t\tcode.cjk { font-family: \"Courier New\", monospace }\n"
"\t</style>\n"
"</head>\n"
"<body lang=\"en-US\" dir=\"ltr\">\n"
"<h1 class=\"western\">Понимание силы LISP</h1>"

#: in_ed/UnderstandingPowerLISP.html:31
msgid ""
"<p><font size=\"2\" style=\"font-size: 10pt\"><a href=\"https://joshbradley."
"me/categories/programming/\">Programming</a>\n"
"</font>\n"
"</p>"
msgstr ""
"<p><font size=\"2\" style=\"font-size: 10pt\"><a href=\"https://joshbradley."
"me/categories/programming/\">Программирование</a>\n"
"</font>\n"
"</p>"

#: in_ed/UnderstandingPowerLISP.html:39
msgid ""
"<p>Paul Graham describes LISP as the convergence point for all\n"
"programming languages. His observation is that as languages mature,\n"
"the average language continues to slide towards LISP. Therefore\n"
"understanding LISP is to understand the fundamental model of modern\n"
"programming.</p>"
msgstr ""
"<p>Пол Грэм описывает LISP как точку схождения для всех языков "
"программирования. \n"
"По его наблюдениям, по мере развития языков средний язык продолжает "
"скатываться \n"
"в сторону LISP. Поэтому понимание LISP означает понимание фундаментальной "
"модели \n"
"современного программирования.</p>"

#: in_ed/UnderstandingPowerLISP.html:45
msgid ""
"<p>Others tout LISP as necessary to becoming a better programmer.\n"
"Eric Raymond went so far as to say that understanding LISP is a\n"
"âprofound enlightenment experience.â</p>"
msgstr ""
"<p>Другие называют LISP необходимым для того, чтобы стать лучшим "
"программистом. \n"
"Эрик Реймонд зашел так далеко, что сказал, что понимание LISP - \n"
"это «глубокое просветление». </p>"

#: in_ed/UnderstandingPowerLISP.html:52
msgid ""
"<p>In search of this understanding, I went to the source. John\n"
"McCarthyâs original paper <a href=\"http://www-formal.stanford.edu/jmc/"
"recursive/recursive.html\" target=\"_blank\">Recursive\n"
"Functions of Symbolic Expressions and Their Computation by Machine</a>\n"
"that laid the foundation for LISP.</p>"
msgstr ""
"<p>В поисках этого понимания я обратился к первоисточнику. Оригинальная "
"статья \n"
"Джона Маккарти <a href=\"http://www-formal.stanford.edu/jmc/recursive/"
"recursive.html\" target=\"_blank\">Recursive Functions of Symbolic "
"Expressions and Their Computation by Machine</a>(Рекурсивные функции "
"символьных выражений и их вычисление машиной), заложившая \n"
"основу для LISP.</p>"

#: in_ed/UnderstandingPowerLISP.html:61
msgid ""
"<p>It is a dense, exploratory paper written by a genius for early\n"
"computer scientists. Not a digestible piece of documentation meant to\n"
"guide others to understanding LISP. I struggled through each sentence\n"
"before stumbling upon Paul Grahamâs article <a href=\"http://www.paulgraham."
"com/rootsoflisp.html\" target=\"_blank\">The\n"
"Roots of LISP</a>. His clarity helped guide me to that elusive sense\n"
"of understanding.</p>"
msgstr ""
"<p>Это объемная исследовательская статья, написанная гением для первых \n"
"компьютерных ученых. Это не легко усваиваемая документация, "
"предназначенная \n"
"для того, чтобы помочь другим понять LISP. Я с трудом перебирал каждое "
"предложение, \n"
"прежде чем наткнулся на статью Пола Грэма <a href=\"http://www.paulgraham."
"com/rootsoflisp.html\" target=\"_blank\">The Roots of LISP</a>(Корни LISP). "
"Её ясность помогла мне обрести \n"
"это неуловимое чувство понимания.</p>"

#: in_ed/UnderstandingPowerLISP.html:68
msgid ""
"<p>But it wasnât until I wrote this article that I gained a full\n"
"grasp of the language and its power. Iâm leaving my steps here for\n"
"any who have gone down a similar path and still struggle to\n"
"understand.</p>"
msgstr ""
"<p>Но только когда я написал эту статью, я полностью понял язык и его "
"возможности.\n"
"Я оставляю свои шаги здесь для всех, кто прошел подобный путь и все еще "
"пытается понять.</p>"

#: in_ed/UnderstandingPowerLISP.html:74
msgid ""
"<p>Keeping true to Paul Graham, I implemented this version of LISP in\n"
"<a href=\"http://www.arclanguage.org/tut.txt\" target=\"_blank\">Arc</a>.\n"
"You can find the full code <a href=\"https://gist.github.com/"
"joshuabradley012/d8e86fcbabac04b230b37e0f173259f5\" target=\"_blank\">here</"
"a>.</p>"
msgstr ""
"<p>Сохраняя верность Полу Грэму, я реализовал эту версию LISP в \n"
"<a href=\"http://www.arclanguage.org/tut.txt\" target=\"_blank\">Arc</a>. Вы "
"можете найти \n"
"полный код  <a href=\"https://gist.github.com/joshuabradley012/"
"d8e86fcbabac04b230b37e0f173259f5\" target=\"_blank\">здесь</a>.</p>"

#: in_ed/UnderstandingPowerLISP.html:77
msgid ""
"<h2 class=\"western\"><a name=\"list-expressions\"></a>List expressions</h2>"
msgstr ""
"<h2 class=\"western\"><a name=\"list-expressions\"></a>List expressions/"
"Списковые выражения</h2>"

#: in_ed/UnderstandingPowerLISP.html:82
msgid ""
"<p>Originally, John McCarthy had defined symbolic expressions\n"
"(S-expressions) and meta expressions (M-expressions). S-expressions\n"
"were to contain lists of symbols, while M-expressions were to denote\n"
"functions.</p>"
msgstr ""
"<p>Первоначально Джон Маккарти определил символические выражения (S-"
"выражения) \n"
"и мета-выражения (M-выражения). S-выражения должны были содержать списки "
"символов, \n"
"а M-выражения должны были обозначать функции. </p>"

#: in_ed/UnderstandingPowerLISP.html:86
msgid ""
"<pre class=\"western\"><code class=\"western\">; S-expression</code>\n"
"<code class=\"western\">((ab .&nbsp;c) . d . nil)</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:95
msgid ""
"<code class=\"western\">; M-expression</code>\n"
"<code class=\"western\">eq[x; x]</code>\n"
"<code class=\"western\">; returns t</code></pre>\n"
"<p>\n"
"However, the computer they used to first implement LISP was missing\n"
"square brackets, so everything was written in S-expression notation.<a href="
"\"https://joshbradley.me/understanding-the-power-of-lisp/#ref:1\"><sup>1</"
"sup></a>\n"
"Dots were omitted and the <code class=\"western\">nil</code> that\n"
"terminates lists is assumed.</p>"
msgstr ""
"<code class=\"western\">; M-expression</code>\n"
"<code class=\"western\">eq[x; x]</code>\n"
"<code class=\"western\">; returns t</code></pre>\n"
"<p>\n"
"Однако на компьютере, который они использовали для первой реализации LISP, \n"
"отсутствовали квадратные скобки, поэтому все было написано в нотации S-"
"выражений.\n"
"<a href=\"https://joshbradley.me/understanding-the-power-of-lisp/"
"#ref:1\"><sup>1</sup></a> \n"
"Точки были опущены, и предполаглось, что завершения списков завершались \n"
"<code class=\"western\">nil</code>.\n"
"</p>"

#: in_ed/UnderstandingPowerLISP.html:99
msgid "<p>So the above M-expression becomes</p>"
msgstr "<p>Таким образом, приведенное выше M-выражение становится </p>"

#: in_ed/UnderstandingPowerLISP.html:106
msgid ""
"<pre class=\"western\"><code class=\"western\">(eq x x)</code>\n"
"<code class=\"western\">; returns t</code></pre>\n"
"<p>\n"
"which became the standard syntax for LISP, making the language\n"
"syntactically uniform.</p>"
msgstr ""
"<pre class=\"western\"><code class=\"western\">(eq x x)</code>\n"
"<code class=\"western\">; returns t</code></pre>\n"
"<p>\n"
"которое стало стандартным синтаксисом LISP, сделав синтаксически \n"
"единообразным язык.</p>"

#: in_ed/UnderstandingPowerLISP.html:110
msgid ""
"<h2 class=\"western\"><a name=\"elementary-functions\"></a>Elementary\n"
"functions</h2>"
msgstr ""
"<h2 class=\"western\"><a name=\"elementary-functions\"></a>Элементарные "
"функции</h2>"

#: in_ed/UnderstandingPowerLISP.html:114
msgid ""
"<p>There are very few elementary functions necessary to make LISP a\n"
"complete language. Many complexities, such as memory allocation and\n"
"garbage collection, are handled by the compiler.</p>"
msgstr ""
"<p>Чтобы сделать LISP законченным языком, необходимо очень мало элементарных "
"функций. \n"
"Компилятор решает многие сложности, такие как выделение памяти и сборка "
"мусора.\n"
"</p>"

#: in_ed/UnderstandingPowerLISP.html:120
msgid ""
"<p>A brief introduction to the syntax of LISP is helpful because some\n"
"aspects are not intuitive. In particular, quotes and inside-out\n"
"evaluation.</p>"
msgstr ""
"<p>Краткое введение в синтаксис LISP полезно, потому что некоторые аспекты \n"
"не понятны интуитивно. В частности, цитаты(quotes) и вычисление/evaluation "
"изнутри наружу.</p>"

#: in_ed/UnderstandingPowerLISP.html:127
msgid ""
"<p>Quotes are necessary for LISP because there is no separation of\n"
"data and code. Sequences of characters can be interpreted as\n"
"variables or values depending on their context. Quoting characters\n"
"solves this by forcing a literal interpretation of values.</p>"
msgstr ""
"<p>Кавычки необходимы для LISP, потому что нет разделения данных и кода. \n"
"Последовательности символьных знаков могут интерпретироваться как "
"переменные \n"
"или значения в зависимости от их контекста. Цитирование символьных знаков \n"
"решает эту проблему, заставляя буквально интерпретировать их как значения. </"
"p>"

#: in_ed/UnderstandingPowerLISP.html:135
msgid ""
"<p>Without quote, <code class=\"western\">(eq x x)</code> will attempt\n"
"to find the defined value of <code class=\"western\">x</code> and throw\n"
"an error if not found. While <code class=\"western\">(eq 'x 'x)</code>\n"
"returns <code class=\"western\">t</code>. Keep in mind this is\n"
"shorthand for <code class=\"western\">(eq (quote x) (quote x))</code>.</p>"
msgstr ""
"<p>Без quote(цитирования) <code class=\"western\">(eq x x)</code> "
"попытается \n"
"найти определенное/привязанное значение <code class=\"western\">x</code> и \n"
"выдаст ошибку, если не оно будет найдено. Хотя <code class=\"western\">(eq "
"'x 'x)</code> \n"
"возвращает <code class=\"western\">t</code>. Имейте в виду, что это "
"сокращение от \n"
"<code class=\"western\">(eq (quote x) (quote x))</code>.\n"
"</p>"

#: in_ed/UnderstandingPowerLISP.html:144
msgid ""
"<p>Inside-out interpretation feels very unnatural because we are\n"
"trained to read left-to-right, even in programming languages. When\n"
"reading expressions such as <code class=\"western\">(outer (inner '(a\n"
"b)))</code> you might expect <code class=\"western\">outer</code> to be\n"
"evaluated first. However, <code class=\"western\">inner</code> will be\n"
"the first to evaluate.</p>"
msgstr ""
"<p>Интерпретация изнутри наружу кажется очень неестественной, потому что \n"
"мы обучены читать слева направо даже на языках программирования. При "
"чтении \n"
"таких выражений, как <code class=\"western\">(outer (inner '(a b)))</"
"code>, \n"
"вы можете ожидать, что в первую очередь будет вычислено <code class=\"western"
"\">outer</code>. \n"
"Однако в первую очередь будет вычислено <code class=\"western\">inner</"
"code>.\n"
"</p>"

#: in_ed/UnderstandingPowerLISP.html:149
msgid ""
"<p>Armed with this basic understanding, youâre ready for the 5\n"
"elementary functions necessary for LISP.</p>"
msgstr ""
"<p>Вооружившись этим базовым пониманием, вы готовы к 5 элементарным "
"функциям, \n"
"необходимым для работы LISP. </p>"

#: in_ed/UnderstandingPowerLISP.html:152
msgid ""
"<h3 class=\"western\"><a name=\"atom\"></a><code class=\"western\">atom</"
"code></h3>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:154
msgid "<p>Checks if an element is a single symbol.</p>"
msgstr "<p>Проверяет, является ли элемент одиночным символом. </p>"

#: in_ed/UnderstandingPowerLISP.html:158
msgid ""
"<pre class=\"western\"><code class=\"western\">(atom 'x)</code>\n"
"<code class=\"western\">; returns t</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:162
msgid ""
"<code class=\"western\">(atom '(a b))</code>\n"
"<code class=\"western\">; returns nil</code></pre><h3 class=\"western\">\n"
"<a name=\"eq\"></a><code class=\"western\">eq</code></h3>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:165
msgid ""
"<p>Checks if two atomic symbols are the same. In Arc, this is written\n"
"as <code class=\"western\">is</code>.</p>"
msgstr ""
"<p>Проверяет, совпадают ли два атомарных символа. В Arc это пишется как \n"
"<code class=\"western\">есть</code>.</p>"

#: in_ed/UnderstandingPowerLISP.html:169
msgid ""
"<pre class=\"western\"><code class=\"western\">(eq 'x 'x)</code>\n"
"<code class=\"western\">; returns t</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:172
msgid ""
"<code class=\"western\">(eq 'x 'y)</code>\n"
"<code class=\"western\">; returns nil</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:177
msgid ""
"<code class=\"western\">(eq '(a b) '(a b))</code>\n"
"<code class=\"western\">; (a b) is a list and cannot be evaluated by eq</"
"code>\n"
"<code class=\"western\">; returns nil</code></pre><h3 class=\"western\">\n"
"<a name=\"car\"></a><code class=\"western\">car</code></h3>"
msgstr ""
"<code class=\"western\">(eq '(a b) '(a b))</code>\n"
"<code class=\"western\">; (a b) is a list and cannot be evaluated by eq</"
"code>\n"
"<code class=\"western\">; returns nil</code></pre><h3 class=\"western\">\n"
"<a name=\"car\"></a><code class=\"western\">car</code></h3>"

#: in_ed/UnderstandingPowerLISP.html:180
msgid ""
"<p>Stands for contents of the address register. It returns the first\n"
"item in a list, as long as it isnât atomic.</p>"
msgstr ""
"<p>Обозначает в лисп машине (contents of the address register) содержимое "
"адресного регистра. \n"
"Она возвращает первый элемент в списке, если он не является атомарным. </p>"

#: in_ed/UnderstandingPowerLISP.html:184
msgid ""
"<pre class=\"western\"><code class=\"western\">(car '(x a))</code>\n"
"<code class=\"western\">; returns x</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:188
msgid ""
"<code class=\"western\">(car '((x a) y))</code>\n"
"<code class=\"western\">; returns (x a)</code></pre><h3 class=\"western\">\n"
"<a name=\"cdr\"></a><code class=\"western\">cdr</code></h3>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:191
msgid ""
"<p>Stands for contents of the decrement register. It returns\n"
"everything after the first item in a list.</p>"
msgstr ""
"<p>Обозначает в лисп машине (contents of the decrement register)содержимое "
"регистра декремента. \n"
"Она возвращает остаток - все, что находится после первого элемента в списке."
"</p>"

#: in_ed/UnderstandingPowerLISP.html:195
msgid ""
"<pre class=\"western\"><code class=\"western\">(cdr '(x a))</code>\n"
"<code class=\"western\">; returns a</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:198
msgid ""
"<code class=\"western\">(cdr '((x a) y))</code>\n"
"<code class=\"western\">; returns y</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:202
msgid ""
"<code class=\"western\">(cdr '((x a) (y b)))</code>\n"
"<code class=\"western\">; returns (y b)</code></pre><h3 class=\"western\">\n"
"<a name=\"cons\"></a><code class=\"western\">cons</code></h3>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:204
msgid "<p>Is used to construct a list from atoms or other lists.</p>"
msgstr "<p>Используется для создания списка из атомов или других списков. </p>"

#: in_ed/UnderstandingPowerLISP.html:212
msgid ""
"<pre class=\"western\"><code class=\"western\">(cons 'x 'a)</code>\n"
"<code class=\"western\">; returns (x . a)</code>\n"
"<code class=\"western\">; lists should typically end in nil</code>\n"
"<code class=\"western\">; so it is better to write (cons x (cons a nil))</"
"code>\n"
"<code class=\"western\">; which returns (x . a . nil)</code>\n"
"<code class=\"western\">; and can be written as (x a)</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:215
msgid ""
"<code class=\"western\">(cons '(x a) 'y)</code>\n"
"<code class=\"western\">; returns ((x a) . y)</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:219
msgid ""
"<code class=\"western\">(cons '(x a) '(y b))</code>\n"
"<code class=\"western\">; returns ((x a) y b)</code></pre><h2 class=\"western"
"\">\n"
"<a name=\"foundational-functions\"></a>Foundational functions</h2>"
msgstr ""
"<code class=\"western\">(cons '(x a) '(y b))</code>\n"
"<code class=\"western\">; returns ((x a) y b)</code></pre><h2 class=\"western"
"\">\n"
"<a name=\"foundational-functions\"></a>Основные функции</h2>"

#: in_ed/UnderstandingPowerLISP.html:222
msgid ""
"<p>These functions form the core of the âuniversal functionâ\n"
"which is the ultimate end of this implementation.</p>"
msgstr ""
"<p>Эти функции составляют основу «универсальной функции», которая является \n"
"конечной целью данной реализации.</p>"

#: in_ed/UnderstandingPowerLISP.html:231
msgid ""
"<p>Because I am implementing this in Arc, I will be moving away from\n"
"John McCarthyâs use of <code class=\"western\">=</code> to define\n"
"functions and <code class=\"western\">[condition -&gt; expression; T -&gt;\n"
"expression]</code> syntax for <code class=\"western\">if...else</code>\n"
"conditions. Instead, I will use <code class=\"western\">def</code> and\n"
"<code class=\"western\">if</code> as defined in Arc.</p>"
msgstr ""
"<p>Поскольку я реализую это в Arc, я буду отходить от использования \n"
"Джоном Маккарти <code class=\"western\">=</code> для определения функций и \n"
"<code class=\"western\">[condition -&gt; expression; T -&gt; expression]</"
"code> \n"
"синтаксис для условий <code class=\"western\">if...else</code>. Вместо этого "
"я \n"
"буду использовать  <code class=\"western\">def</code> и <code class=\"western"
"\">if</code>, \n"
"как определено в Arc.</p>"

#: in_ed/UnderstandingPowerLISP.html:239
msgid ""
"<p>Other differences include using <code class=\"western\">is</code>\n"
"for <code class=\"western\">eq</code> and I will prefix all functions\n"
"with <code class=\"western\">_</code> to avoid conflicts with existing\n"
"functions. Additionally, <code class=\"western\">t</code> represents\n"
"truth and <code class=\"western\">nil</code> represents falsity.</p>"
msgstr ""
"<p>Другие отличия включают использование <code class=\"western\">is</code>\n"
"для <code class=\"western\">eq</code>, и я буду ставить перед всеми "
"функциями префикс \n"
"<code class=\"western\">_</code>, чтобы избежать конфликтов с существующими "
"функциями. \n"
"Кроме того, <code class=\"western\">t</code> представляет истину, а \n"
"<code class=\"western\">nil</code> - ложь.</p>"

#: in_ed/UnderstandingPowerLISP.html:245
msgid ""
"<p>If you have trouble following the syntax, I suggest reading Paul\n"
"Grahamâs <a href=\"http://www.arclanguage.org/tut.txt\" target=\"_blank"
"\">Arc\n"
"tutorial</a> first.</p>"
msgstr ""
"<p>Если у вас возникли проблемы с синтаксисом, я предлагаю сначала прочитать "
"учебник \n"
"Пола Грэма по <a href=\"http://www.arclanguage.org/tut.txt\" target=\"_blank"
"\">Arc\n"
"tutorial</a>. </p>"

#: in_ed/UnderstandingPowerLISP.html:248
msgid ""
"<h3 class=\"western\"><a name=\"_null\"></a><code class=\"western\">_null</"
"code></h3>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:250
msgid "<p>Evaluates if the expression is empty.</p>"
msgstr "<p>Проверяет, является ли выражение пустым.</p>"

#: in_ed/UnderstandingPowerLISP.html:254
msgid ""
"<pre class=\"western\"><code class=\"western\">(def _null (x)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(is x nil))</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:257
msgid ""
"<code class=\"western\">(_null nil)</code>\n"
"<code class=\"western\">; returns t</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:261
msgid ""
"<code class=\"western\">(_null '(x a))</code>\n"
"<code class=\"western\">; returns nil</code></pre><h3 class=\"western\">\n"
"<a name=\"_and\"></a><code class=\"western\">_and</code></h3>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:265
msgid ""
"<p>Evaluates if both conditions are true. In Arc, <code class=\"western\">t</"
"code>\n"
"represents true, and <code class=\"western\">nil</code> represents\n"
"false.</p>"
msgstr ""
"<p>Проверяет, верны ли оба условия. В Arc <code class=\"western\">t</code> "
"представляет истину, \n"
"а <code class=\"western\">nil</code> - ложь. </p>"

#: in_ed/UnderstandingPowerLISP.html:269
msgid ""
"<pre class=\"western\"><code class=\"western\">(def _and (x y)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(if (is x t) (is y "
"t) t nil))</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:272
msgid ""
"<code class=\"western\">(_and 'x 'y)</code>\n"
"<code class=\"western\">; returns t</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:276
msgid ""
"<code class=\"western\">(_and 'x nil)</code>\n"
"<code class=\"western\">; returns nil</code></pre><h3 class=\"western\">\n"
"<a name=\"_not\"></a><code class=\"western\">_not</code></h3>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:278
msgid ""
"<p>Evaluates if the condition is <code class=\"western\">nil</code>.</p>"
msgstr ""
"<p>Проверяет, равно ли условие  <code class=\"western\">nil</code>.</p>"

#: in_ed/UnderstandingPowerLISP.html:282
msgid ""
"<pre class=\"western\"><code class=\"western\">(def _not (x)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(if (is x nil) t))</"
"code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:285
msgid ""
"<code class=\"western\">(_not nil)</code>\n"
"<code class=\"western\">; returns t</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:291
msgid ""
"<code class=\"western\">(_not 'x)</code>\n"
"<code class=\"western\">; returns nil</code></pre><h3 class=\"western\">\n"
"<a name=\"_caar-_cadr-_caddr-_cadar-and-_caddar\"></a><code class=\"western"
"\">_caar</code>,\n"
"<code class=\"western\">_cadr</code>, <code class=\"western\">_caddr</"
"code>,\n"
"<code class=\"western\">_cadar</code>, and <code class=\"western\">_caddar</"
"code></h3>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:295
msgid ""
"<p>These are shorthand for combinations of <code class=\"western\">car</"
"code>\n"
"and <code class=\"western\">cdr</code>. They occur often so the\n"
"shorthand keeps your code DRY.</p>"
msgstr ""
"<p>Это сокращение для комбинаций <code class=\"western\">car</code> и\n"
"<code class=\"western\">cdr</code>. Они возникают часто, поэтому "
"сокращение \n"
"сохраняет ваш код DRY.</p>"

#: in_ed/UnderstandingPowerLISP.html:299
msgid ""
"<pre class=\"western\"><code class=\"western\">(def _caar (x)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(car (car x)))</"
"code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:302
msgid ""
"<code class=\"western\">(def _cadr (x)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(car (cdr x)))</"
"code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:305
msgid ""
"<code class=\"western\">(def _cadar (x)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(car (cdr (car "
"x))))</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:308
msgid ""
"<code class=\"western\">(def _caddr (x)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(car (cdr (cdr "
"x))))</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:311
msgid ""
"<code class=\"western\">(def _caddar (x)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(car (cdr (cdr (car "
"x)))))</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:314
msgid ""
"<code class=\"western\">(_cadr '(a b c d))</code>\n"
"<code class=\"western\">; returns b</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:317
msgid ""
"<code class=\"western\">(_caddr '(a b c d))</code>\n"
"<code class=\"western\">; returns c</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:320
msgid ""
"<code class=\"western\">(_cadar '((a b c d) (e f g)))</code>\n"
"<code class=\"western\">; returns b</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:324
msgid ""
"<code class=\"western\">(_caddar '((a b c d) (e f g)))</code>\n"
"<code class=\"western\">; returns c</code></pre><h3 class=\"western\">\n"
"<a name=\"_append\"></a><code class=\"western\">_append</code></h3>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:326
msgid "<p>Allows you to join lists.</p>"
msgstr "<p>Позволяет вам соединять списки.</p>"

#: in_ed/UnderstandingPowerLISP.html:330
msgid ""
"<pre class=\"western\"><code class=\"western\">(def _append (x y)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(if (_null x) y "
"(cons (car x) (_append (cdr x) y))))</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:334
msgid ""
"<code class=\"western\">(_append '(a b) '(c d))</code>\n"
"<code class=\"western\">; returns (a b c d)</code></pre><h3 class=\"western"
"\">\n"
"<a name=\"_list\"></a><code class=\"western\">_list</code></h3>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:338
msgid ""
"<p>Creates a list from two expressions. The distinction between this\n"
"and <code class=\"western\">cons</code> is that <code class=\"western"
"\">_list</code>\n"
"will append <code class=\"western\">nil</code> for you.</p>"
msgstr ""
"<p>Создает список из двух выражений. Разница между ним и <code class="
"\"western\">cons</code> \n"
"в том, что <code class=\"western\">_list</code> добавит за вас <code class="
"\"western\">nil</code>.\n"
"</p>"

#: in_ed/UnderstandingPowerLISP.html:344
msgid ""
"<p>This maintains the integrity of lists that you pass as arguments\n"
"and removes the need for an additional <code class=\"western\">cons</code>\n"
"when joining two atoms.</p>"
msgstr ""
"<p>Она поддерживает целостность списков, которые вы передаете в качестве "
"аргументов, \n"
"и устраняет необходимость в дополнительных <code class=\"western\">cons</"
"code> при \n"
"объединении двух атомов. </p>"

#: in_ed/UnderstandingPowerLISP.html:348
msgid ""
"<pre class=\"western\"><code class=\"western\">(def _list (x y)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(cons x (cons y "
"nil)))</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:351
msgid ""
"<code class=\"western\">(_list 'a 'b)</code>\n"
"<code class=\"western\">; returns (a b)</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:355
msgid ""
"<code class=\"western\">(_list '(a b) '(c d))</code>\n"
"<code class=\"western\">; returns ((a b) (c d))</code></pre><h3 class="
"\"western\">\n"
"<a name=\"_pair\"></a><code class=\"western\">_pair</code></h3>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:358
msgid ""
"<p>Joins two lists creating pairs based on the position of each\n"
"element.</p>"
msgstr ""
"<p>Объединяет два списка, создавая пары на основе положения каждого "
"элемента. </p>"

#: in_ed/UnderstandingPowerLISP.html:365
msgid ""
"<pre class=\"western\"><code class=\"western\">(def _pair (x y)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(if (_and (_null x) "
"(_null y)) nil</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(_and (_not "
"(atom x)) (_not (atom y)))</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(cons (_list "
"(car x) (car y))</code>\n"
"<code class=\"western\">            </code><code class=\"western\">(_pair "
"(cdr x) (cdr y)))))</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:369
msgid ""
"<code class=\"western\">(_pair '(x y z) '(a b c))</code>\n"
"<code class=\"western\">; returns ((x a) (y b) (z c))</code></pre><h3 class="
"\"western\">\n"
"<a name=\"_assoc\"></a><code class=\"western\">_assoc</code></h3>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:372
msgid ""
"<p>Gets values from key-value pairs, where the first argument is the\n"
"key and the second argument is a list of pairs.</p>"
msgstr ""
"<p>Получает значения из пар \"ключ-значение\", где первый аргумент - это "
"ключ, \n"
"а второй аргумент - это список пар. </p>"

#: in_ed/UnderstandingPowerLISP.html:377
msgid ""
"<pre class=\"western\"><code class=\"western\">(def _assoc (x y)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(if (is (caar y) x) "
"(_cadar y)</code>\n"
"<code class=\"western\">    </code><code class=\"western\">(_assoc x (cdr "
"y))))</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:380
msgid ""
"<code class=\"western\">(_assoc 'y '((x a) (y b)))</code>\n"
"<code class=\"western\">; returns b</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:384
msgid ""
"<code class=\"western\">(_assoc 'x '((w (a b)) (x (c d)) (y (e f))))</code>\n"
"<code class=\"western\">; returns (c d)</code></pre><h2 class=\"western\">\n"
"<a name=\"the-universal-function\"></a>The universal function</h2>"
msgstr ""
"<code class=\"western\">(_assoc 'x '((w (a b)) (x (c d)) (y (e f))))</code>\n"
"<code class=\"western\">; returns (c d)</code></pre><h2 class=\"western\">\n"
"<a name=\"the-universal-function\"></a>Универсальная функция</h2>"

#: in_ed/UnderstandingPowerLISP.html:388
msgid ""
"<p>The true power of LISP is its ability to evaluate itself from a\n"
"few building blocks. As John McCarthy did, we will be defining <code class="
"\"western\">_eval</code>\n"
"which can evaluate LISP in LISP.</p>"
msgstr ""
"<p>Истинная сила LISP заключается в его способности оценивать/вычислять \n"
"себя из нескольких строительных блоков. Как и Джон Маккарти, мы будем \n"
"определять <code class=\"western\">_eval</code>, который может вычислять/"
"оценивать \n"
"LISP в LISP.</p>"

#: in_ed/UnderstandingPowerLISP.html:394
msgid ""
"<p>This is the most surprising and powerful aspect of the language.\n"
"With 5 primitives and 12 functions, you have the building blocks to\n"
"build an interpreter.</p>"
msgstr ""
"<p>Это самый удивительный и мощный аспект языка. С 5 примитивами и \n"
"12 функциями у вас есть строительные блоки для создания интерпретатора. </p>"

#: in_ed/UnderstandingPowerLISP.html:419
msgid ""
"<pre class=\"western\"><code class=\"western\">(def _eval (e a)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(if</code>\n"
"<code class=\"western\">    </code><code class=\"western\">(atom e) (_assoc "
"e a)</code>\n"
"<code class=\"western\">    </code><code class=\"western\">(atom (car e)) "
"(if</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(is (car e) "
"'quote) (_cadr e)</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(is (car e) "
"'atom)  (atom (_eval (_cadr  e) a))</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(is (car e) "
"'eq)    (is   (_eval (_cadr  e) a)</code>\n"
"<code class=\"western\">                                </code><code class="
"\"western\">(_eval (_caddr e) a))</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(is (car e) "
"'car)   (car  (_eval (_cadr  e) a))</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(is (car e) "
"'cdr)   (cdr  (_eval (_cadr  e) a))</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(is (car e) "
"'cons)  (cons (_eval (_cadr  e) a)</code>\n"
"<code class=\"western\">                                </code><code class="
"\"western\">(_eval (_caddr e) a))</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(is (car e) "
"'cond)  (_evcon (cdr e) a)</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(_eval (cons "
"(_assoc (car e) a)</code>\n"
"<code class=\"western\">                   </code><code class=\"western"
"\">(cdr e))</code>\n"
"<code class=\"western\">             </code><code class=\"western\">a))</"
"code>\n"
"<code class=\"western\">    </code><code class=\"western\">(is (caar e) "
"'label)</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(_eval (cons "
"(_caddar e) (cdr e))</code>\n"
"<code class=\"western\">             </code><code class=\"western\">(cons "
"(_list (_cadar e) (car e)) a))</code>\n"
"<code class=\"western\">    </code><code class=\"western\">(is (caar e) "
"'lambda)</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(_eval (_caddar "
"e)</code>\n"
"<code class=\"western\">             </code><code class=\"western\">(_append "
"(_pair (_cadar e) (_evlis (cdr e) a))</code>\n"
"<code class=\"western\">                      </code><code class=\"western"
"\">a))))</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:424
msgid ""
"<code class=\"western\">(def _evcon (c a)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(if (_eval (_caar "
"c) a)</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(_eval (_cadar "
"c) a)</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(_evcon (cdr c) "
"a)))</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:434
msgid ""
"<code class=\"western\">(def _evlis (m a)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(if (_null m) nil</"
"code>\n"
"<code class=\"western\">      </code><code class=\"western\">(cons (_eval  "
"(car m) a)</code>\n"
"<code class=\"western\">            </code><code class=\"western\">(_evlis "
"(cdr m) a))))</code></pre>\n"
"<p>\n"
"When using <code class=\"western\">_eval</code> the syntax of the\n"
"contained expressions will be specific to the interpreter. We arenât\n"
"writing in Arc anymore, but a completely new language. The primitive\n"
"form of LISP.</p>"
msgstr ""
"<code class=\"western\">(def _evlis (m a)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(if (_null m) nil</"
"code>\n"
"<code class=\"western\">      </code><code class=\"western\">(cons (_eval  "
"(car m) a)</code>\n"
"<code class=\"western\">            </code><code class=\"western\">(_evlis "
"(cdr m) a))))</code></pre>\n"
"<p>\n"
"При использовании <code class=\"western\">_eval</code> синтаксис "
"содержащихся в нем \n"
"выражений будет зависеть от интерпретатора. Мы больше не пишем на Arc, а "
"на \n"
"совершенно новом языке. Примитивная форма LISP.\n"
"</p>"

#: in_ed/UnderstandingPowerLISP.html:439
msgid ""
"<p>Even if you have been following along, there is a lot to break\n"
"down here, so letâs step through it.</p>"
msgstr ""
"<p>Даже если вы следовали за нами, здесь есть что сломать, так что давайте \n"
"рассмотрим этот код.</p>"

#: in_ed/UnderstandingPowerLISP.html:443
msgid ""
"<h3 class=\"western\"><a name=\"interpreting-elementary-functions\"></"
"a>Interpreting\n"
"elementary functions</h3>"
msgstr ""
"<h3 class=\"western\"><a name=\"interpreting-elementary-functions\"></"
"a>Интерпретация элементарных функций\n"
"</h3>"

#: in_ed/UnderstandingPowerLISP.html:447
msgid ""
"<p><code class=\"western\">_eval</code> takes <code class=\"western\">e</"
"code>\n"
"as the expression to be evaluated and <code class=\"western\">a</code>\n"
"as a list of pairs that will be referenced by <code class=\"western\">e</"
"code>.</p>"
msgstr ""
"<p><code class=\"western\">_eval</code> принимает <code class=\"western\">e</"
"code> как выражение, \n"
"которое нужно вычислить и <code class=\"western\">a</code> как список пар, "
"на которые будет \n"
"ссылаться  <code class=\"western\">e</code>.</p>"

#: in_ed/UnderstandingPowerLISP.html:453
msgid ""
"<p>If <code class=\"western\">e</code> is atomic <code class=\"western"
"\">_assoc</code>\n"
"is called to return the value that matches the key <code class=\"western"
"\">e</code>\n"
"in <code class=\"western\">a</code>.</p>"
msgstr ""
"<p>Если <code class=\"western\">e</code> является атомарным, вызывается \n"
"<code class=\"western\">_assoc</code> для возврата значения, "
"соответствующего ключу \n"
"<code class=\"western\">e</code> в <code class=\"western\">a</code>. \n"
"</p>"

#: in_ed/UnderstandingPowerLISP.html:457
msgid ""
"<pre class=\"western\"><code class=\"western\">(_eval 'x '((x a) (y b)))</"
"code>\n"
"<code class=\"western\">; returns a</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:464
msgid ""
"<code class=\"western\">(_eval 'y '((x a) (y b)))</code>\n"
"<code class=\"western\">; returns b</code></pre>\n"
"<p>\n"
"If <code class=\"western\">e</code> is not atomic, then <code class=\"western"
"\">_eval</code>\n"
"checks if the first element of <code class=\"western\">e</code> is one\n"
"of the elementary functions.</p>"
msgstr ""
"<code class=\"western\">(_eval 'y '((x a) (y b)))</code>\n"
"<code class=\"western\">; returns b</code></pre>\n"
"<p>\n"
"Если <code class=\"western\">e</code> не является атомарным, то \n"
"<code class=\"western\">_eval</code> проверяет, является ли первый элемент \n"
"<code class=\"western\">e</code> одной из элементарных функций.\n"
"</p>"

#: in_ed/UnderstandingPowerLISP.html:469
msgid ""
"<p>In the case of <code class=\"western\">quote</code> the symbol\n"
"following <code class=\"western\">quote</code> is returned literally.</p>"
msgstr ""
"<p>В случае <code class=\"western\">quote</code>(цитаты) символ, следующий "
"за \n"
"<code class=\"western\">quote</code>, возвращается буквально. </p>"

#: in_ed/UnderstandingPowerLISP.html:474
msgid ""
"<pre class=\"western\"><code class=\"western\">(_eval '(quote x) nil)</"
"code>\n"
"<code class=\"western\">; nil is needed because _eval requires two "
"arguments</code>\n"
"<code class=\"western\">; returns x</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:482
msgid ""
"<code class=\"western\">(_eval '(quote (x a)) nil)</code>\n"
"<code class=\"western\">; returns (x a)</code></pre>\n"
"<p>\n"
"With other elementary functions, <code class=\"western\">e</code> takes\n"
"the form <code class=\"western\">(function key)</code>, where <code class="
"\"western\">key</code>\n"
"is used to get a value from <code class=\"western\">a</code> that will\n"
"be evaluated by <code class=\"western\">function</code>.</p>"
msgstr ""
"<code class=\"western\">(_eval '(quote (x a)) nil)</code>\n"
"<code class=\"western\">; returns (x a)</code></pre>\n"
"<p>\n"
"С другими элементарными функциями <code class=\"western\">e</code> принимает "
"форму \n"
"<code class=\"western\">(function key)</code>, где <code class=\"western"
"\">key</code> используется \n"
"для получения значения из <code class=\"western\">a</code>, которое будет "
"вычислятся(обрабатываться) \n"
"<code class=\"western\">function</code>.</p>"

#: in_ed/UnderstandingPowerLISP.html:490
msgid ""
"<p>The following use of <code class=\"western\">_eval</code> is\n"
"equivalent to the much simpler <code class=\"western\">(atom 'y)</code>\n"
"but it is core to understanding the <code class=\"western\">_eval</code>\n"
"function. Notice how <code class=\"western\">x</code> is being used to\n"
"reference the value in the second parameter, <code class=\"western\">a</"
"code>.</p>"
msgstr ""
"<p>Следующее использование <code class=\"western\">_eval</code> "
"эквивалентно \n"
"гораздо более простому <code class=\"western\">(atom 'y)</code>, но "
"является \n"
"ключевым для понимания функции <code class=\"western\">_eval</code>. "
"Обратите внимание, \n"
"как <code class=\"western\">x</code> используется для ссылки на значение "
"второго \n"
"параметра, <code class=\"western\">a</code>.</p>"

#: in_ed/UnderstandingPowerLISP.html:494
msgid ""
"<pre class=\"western\"><code class=\"western\">(_eval '(atom x) '((x y)))</"
"code>\n"
"<code class=\"western\">; returns t</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:501
msgid ""
"<code class=\"western\">(_eval '(atom x) '((x (a b))))</code>\n"
"<code class=\"western\">; returns nil</code></pre>\n"
"<p>\n"
"For every elementary function except <code class=\"western\">quote</code>\n"
"there are recursive <code class=\"western\">_eval</code> calls being\n"
"made until it reaches <code class=\"western\">_assoc</code> or <code class="
"\"western\">quote</code>.</p>"
msgstr ""
"<code class=\"western\">(_eval '(atom x) '((x (a b))))</code>\n"
"<code class=\"western\">; returns nil</code></pre>\n"
"<p>\n"
"Для каждой элементарной функции, кроме <code class=\"western\">quote</code>, "
"выполняются \n"
"рекурсивные вызовы <code class=\"western\">_eval</code> до тех пор, пока она "
"не достигнет \n"
"<code class=\"western\">_assoc</code> или <code class=\"western\">quote</"
"code>.</p>"

#: in_ed/UnderstandingPowerLISP.html:506
msgid ""
"<p>These are the steps <code class=\"western\">_eval</code> takes to\n"
"evaluate <code class=\"western\">atom</code>.</p>"
msgstr ""
"<p>Это шаги, которые выполняет <code class=\"western\">_eval</code> для \n"
"вычисления/оценки  <code class=\"western\">atom</code>.</p>"

#: in_ed/UnderstandingPowerLISP.html:518
msgid ""
"<pre class=\"western\"><code class=\"western\">(_eval '(atom x) '((x y)))</"
"code>\n"
"<code class=\"western\">; (atom (_eval (_cadr e) a))</code>\n"
"<code class=\"western\">; (atom (_eval  x ((x y))))</code>\n"
"<code class=\"western\">; (atom (_assoc x ((x y))))</code>\n"
"<code class=\"western\">; (atom y)</code>\n"
"<code class=\"western\">; returns t</code></pre>\n"
"<p>\n"
"<code class=\"western\">car</code> and <code class=\"western\">cdr</code>\n"
"have a very similar structure to <code class=\"western\">atom</code>\n"
"because only one expression has to be evaluated.</p>"
msgstr ""
"<pre class=\"western\"><code class=\"western\">(_eval '(atom x) '((x y)))</"
"code>\n"
"<code class=\"western\">; (atom (_eval (_cadr e) a))</code>\n"
"<code class=\"western\">; (atom (_eval  x ((x y))))</code>\n"
"<code class=\"western\">; (atom (_assoc x ((x y))))</code>\n"
"<code class=\"western\">; (atom y)</code>\n"
"<code class=\"western\">; returns t</code></pre>\n"
"<p>\n"
"<code class=\"western\">car</code> и <code class=\"western\">cdr</code>\n"
"имеют очень похожую структуру на <code class=\"western\">atom</code>, \n"
"потому что нужно вычислять только одно выражение. </p>"

#: in_ed/UnderstandingPowerLISP.html:522
msgid ""
"<pre class=\"western\"><code class=\"western\">(_eval '(car x) '((x (a b "
"c))))</code>\n"
"<code class=\"western\">; returns a</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:529
msgid ""
"<code class=\"western\">(_eval '(cdr x) '((x (a b c))))</code>\n"
"<code class=\"western\">; returns (b c)</code></pre>\n"
"<p>\n"
"<code class=\"western\">cons</code> and <code class=\"western\">eq</code>\n"
"have two expressions that need to be evaluated. As such, <code class="
"\"western\">a</code>\n"
"needs to contain two pairs.</p>"
msgstr ""
"<code class=\"western\">(_eval '(cdr x) '((x (a b c))))</code>\n"
"<code class=\"western\">; returns (b c)</code></pre>\n"
"<p>\n"
"<code class=\"western\">cons</code> и <code class=\"western\">eq</code> "
"имеют \n"
"два выражения, которые необходимо вычислить. Таким образом, в <code class="
"\"western\">a</code> \n"
"должно быть две пары. </p>"

#: in_ed/UnderstandingPowerLISP.html:533
msgid ""
"<pre class=\"western\"><code class=\"western\">(_eval '(eq x y) '((x a) (y "
"a)))</code>\n"
"<code class=\"western\">; returns t</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:541
msgid ""
"<code class=\"western\">(_eval '(cons x y) '((x a) (y b)))</code>\n"
"<code class=\"western\">; returns (a . b)</code></pre>\n"
"<p>\n"
"<code class=\"western\">cond</code> makes use of a new function, <code class="
"\"western\">_evcon</code>\n"
"which takes a list of pairs with the format <code class=\"western"
"\">(condition\n"
"expression)</code>. When a true condition is found, that expression\n"
"is evaluated.</p>"
msgstr ""
"<code class=\"western\">(_eval '(cons x y) '((x a) (y b)))</code>\n"
"<code class=\"western\">; returns (a . b)</code></pre>\n"
"<p>\n"
"<code class=\"western\">cond</code> использует новую функцию \n"
"<code class=\"western\">_evcon</code>, которая принимает список пар в "
"формате \n"
"<code class=\"western\">(condition expression)</code>/(условие выражение). \n"
"Когда истинное условие найдено, это выражение вычисляется. </p>"

#: in_ed/UnderstandingPowerLISP.html:547
msgid ""
"<pre class=\"western\"><code class=\"western\">(def _evcon (c a)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(if (_eval (_caar "
"c) a)</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(_eval (_cadar "
"c) a)</code>\n"
"<code class=\"western\">      </code><code class=\"western\">(_evcon (cdr c) "
"a)))</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:555
msgid ""
"<code class=\"western\">(_evcon '(((atom c1) a1) ((atom c2) a2) ((atom c3) "
"a3))</code>\n"
"<code class=\"western\">        </code><code class=\"western\">'((c1 (a b)) "
"(a1 not_atom)</code>\n"
"<code class=\"western\">          </code><code class=\"western\">(c2 (c d)) "
"(a2 still_not_atom)</code>\n"
"<code class=\"western\">          </code><code class=\"western\">(c3 e)     "
"(a3 is_atom)))</code>\n"
"<code class=\"western\">; returns is_atom</code></pre>\n"
"<p>\n"
"Here is the same expression using <code class=\"western\">_eval</code>.</p>"
msgstr ""
"<code class=\"western\">(_evcon '(((atom c1) a1) ((atom c2) a2) ((atom c3) "
"a3))</code>\n"
"<code class=\"western\">        </code><code class=\"western\">'((c1 (a b)) "
"(a1 not_atom)</code>\n"
"<code class=\"western\">          </code><code class=\"western\">(c2 (c d)) "
"(a2 still_not_atom)</code>\n"
"<code class=\"western\">          </code><code class=\"western\">(c3 e)     "
"(a3 is_atom)))</code>\n"
"<code class=\"western\">; returns is_atom</code></pre>\n"
"<p>\n"
"Вот то же выражение с использованием <code class=\"western\">_eval</code>.</"
"p>"

#: in_ed/UnderstandingPowerLISP.html:565
msgid ""
"<pre class=\"western\"><code class=\"western\">(_eval '(cond ((atom c1) a1) "
"((atom c2) a2) ((atom c3) a3))</code>\n"
"<code class=\"western\">       </code><code class=\"western\">'((c1 (a b)) "
"(a1 not_atom)</code>\n"
"<code class=\"western\">         </code><code class=\"western\">(c2 (c d)) "
"(a2 still_not_atom)</code>\n"
"<code class=\"western\">         </code><code class=\"western\">(c3 e)     "
"(a3 is_atom)))</code>\n"
"<code class=\"western\">; returns is_atom</code></pre><h3 class=\"western"
"\">\n"
"<a name=\"interpreting-label-and-lambda-functions\"></a>Interpreting\n"
"<code class=\"western\">label</code> and <code class=\"western\">lambda</"
"code>\n"
"functions</h3>"
msgstr ""
"<pre class=\"western\"><code class=\"western\">(_eval '(cond ((atom c1) a1) "
"((atom c2) a2) ((atom c3) a3))</code>\n"
"<code class=\"western\">       </code><code class=\"western\">'((c1 (a b)) "
"(a1 not_atom)</code>\n"
"<code class=\"western\">         </code><code class=\"western\">(c2 (c d)) "
"(a2 still_not_atom)</code>\n"
"<code class=\"western\">         </code><code class=\"western\">(c3 e)     "
"(a3 is_atom)))</code>\n"
"<code class=\"western\">; returns is_atom</code></pre><h3 class=\"western"
"\">\n"
"<a name=\"interpreting-label-and-lambda-functions\"></a>Интерпретация \n"
"<code class=\"western\">label</code> и <code class=\"western\">lambda</"
"code>\n"
"функций</h3>"

#: in_ed/UnderstandingPowerLISP.html:569
msgid ""
"<p>If <code class=\"western\">e</code> is atomic but isnât an\n"
"elementary function, it must be a <code class=\"western\">label</code>\n"
"or <code class=\"western\">lambda</code> function defined by the user.</p>"
msgstr ""
"<p>Если <code class=\"western\">e</code> является атомарной, но \n"
"не элементарной функцией, это должна быть <code class=\"western\">label</"
"code> или \n"
"<code class=\"western\">lambda</code>-функция, определенная пользователем.</"
"p>"

#: in_ed/UnderstandingPowerLISP.html:576
msgid ""
"<p><code class=\"western\">lambda</code> expressions take the format\n"
"<code class=\"western\">(lambda (param) (expression) arg)</code> where\n"
"<code class=\"western\">arg</code> will be passed to <code class=\"western"
"\">expression</code>\n"
"through <code class=\"western\">param</code>.</p>"
msgstr ""
"<p><code class=\"western\">lambda</code>-выражения принимают формат \n"
"<code class=\"western\">(lambda (param) (expression) arg)</code>, где \n"
"<code class=\"western\">arg</code> передается в <code class=\"western"
"\">expression</code> \n"
"через <code class=\"western\">param</code>.</p>"

#: in_ed/UnderstandingPowerLISP.html:589
msgid ""
"<pre class=\"western\"><code class=\"western\">(_eval '((lambda (param)</"
"code>\n"
"<code class=\"western\">           </code><code class=\"western\">(cond "
"((atom param) (quote is_atom))</code>\n"
"<code class=\"western\">                 </code><code class=\"western"
"\">((quote t)    (quote not_atom))))</code>\n"
"<code class=\"western\">          </code><code class=\"western\">arg)</"
"code>\n"
"<code class=\"western\">       </code><code class=\"western\">'((arg (a "
"b))))</code>\n"
"<code class=\"western\">; returns not_atom</code></pre>\n"
"<p>\n"
"Note that <code class=\"western\">(quote t)</code> is used here as an\n"
"explicit <code class=\"western\">else</code> condition. Arc handles\n"
"these cases gracefully, but because we are bound to the rules of the\n"
"interpreter we must use this syntax.</p>"
msgstr ""
"<pre class=\"western\"><code class=\"western\">(_eval '((lambda (param)</"
"code>\n"
"<code class=\"western\">           </code><code class=\"western\">(cond "
"((atom param) (quote is_atom))</code>\n"
"<code class=\"western\">                 </code><code class=\"western"
"\">((quote t)    (quote not_atom))))</code>\n"
"<code class=\"western\">          </code><code class=\"western\">arg)</"
"code>\n"
"<code class=\"western\">       </code><code class=\"western\">'((arg (a "
"b))))</code>\n"
"<code class=\"western\">; returns not_atom</code></pre>\n"
"<p>\n"
"Обратите внимание, что <code class=\"western\">(quote t)</code> здесь "
"используется \n"
"как явное условие <code class=\"western\">else</code>. Arc обрабатывает эти "
"случаи изящно, \n"
"но поскольку мы привязаны к правилам интерпретатора, мы должны использовать "
"этот \n"
"синтаксис.</p>"

#: in_ed/UnderstandingPowerLISP.html:594
msgid ""
"<p>During evaluation, the above <code class=\"western\">lambda</code>\n"
"expression becomes</p>"
msgstr ""
"<p>Во время вычисления/оценки указанное выше <code class=\"western\">lambda</"
"code>-\n"
"выражение становится </p>"

#: in_ed/UnderstandingPowerLISP.html:606
msgid ""
"<pre class=\"western\"><code class=\"western\">(_eval '(cond ((atom param) "
"(quote is_atom))</code>\n"
"<code class=\"western\">              </code><code class=\"western\">((quote "
"t)    (quote not_atom)))</code>\n"
"<code class=\"western\">       </code><code class=\"western\">'((param (a "
"b)) (arg (a b))))</code></pre>\n"
"<p>\n"
"Notice how the arguments are extended to contain a pair for <code class="
"\"western\">param</code>.\n"
"This makes use of the supplementary <code class=\"western\">_evlis</code>\n"
"function which recursively constructs a list of pairs from <code class="
"\"western\">arg</code>\n"
"for each <code class=\"western\">param</code> in <code class=\"western"
"\">lambda</code>.\n"
"This allows <code class=\"western\">lambda</code> to handle any list of\n"
"parameters.</p>"
msgstr ""
"<pre class=\"western\"><code class=\"western\">(_eval '(cond ((atom param) "
"(quote is_atom))</code>\n"
"<code class=\"western\">              </code><code class=\"western\">((quote "
"t)    (quote not_atom)))</code>\n"
"<code class=\"western\">       </code><code class=\"western\">'((param (a "
"b)) (arg (a b))))</code></pre>\n"
"<p>\n"
"Обратите внимание, как аргументы расширяются, чтобы содержать пару для \n"
"<code class=\"western\">param</code>(параметра). Это использует "
"дополнительную функцию \n"
"<code class=\"western\">_evlis</code>, которая рекурсивно создает список пар "
"из \n"
"<code class=\"western\">arg</code> для каждого параметра(<code class="
"\"western\">param</code>) \n"
"в <code class=\"western\">lambda</code>. Это позволяет <code class=\"western"
"\">lambda</code>\n"
"обрабатывать любой список параметров.</p>"

#: in_ed/UnderstandingPowerLISP.html:612
msgid ""
"<p><code class=\"western\">((lambda (</code><em>p</em><em><sub>1</sub></"
"em><code class=\"western\">...</code><em>p</em><em><sub>n</sub></em><code "
"class=\"western\">)\n"
"</code><em>e</em><code class=\"western\">) </code><em>a</em><em><sub>1</"
"sub></em><code class=\"western\">...</code><em>a</em><em><sub>n</sub></"
"em><code class=\"western\">)</code>\n"
"is the formal definition.</p>"
msgstr ""
"<p><code class=\"western\">((lambda (</code><em>p</em><em><sub>1</sub></"
"em><code class=\"western\">...</code><em>p</em><em><sub>n</sub></em><code "
"class=\"western\">)\n"
"</code><em>e</em><code class=\"western\">) </code><em>a</em><em><sub>1</"
"sub></em><code class=\"western\">...</code><em>a</em><em><sub>n</sub></"
"em><code class=\"western\">)</code>\n"
"это формальное определение. </p>"

#: in_ed/UnderstandingPowerLISP.html:618
msgid ""
"<p><code class=\"western\">label</code> allows functions to be called\n"
"by name, which is arguably the most important feature of any\n"
"programming language.</p>"
msgstr ""
"<p><code class=\"western\">label</code> позволяет вызывать функции по "
"имени, \n"
"что, возможно, является наиболее важной особенностью любого языка \n"
"программирования.\n"
"</p>"

#: in_ed/UnderstandingPowerLISP.html:624
msgid ""
"<p>Here, McCarthy defines <code class=\"western\">ff</code> as a\n"
"function to return the first atom in a list. It makes use of labeled\n"
"recursion.</p>"
msgstr ""
"<p>Здесь Маккарти определяет <code class=\"western\">ff</code> как "
"функцию, \n"
"возвращающую первый атом в списке. Он использует labeled(помеченную) "
"рекурсию. </p>"

#: in_ed/UnderstandingPowerLISP.html:638
msgid ""
"<pre class=\"western\"><code class=\"western\">(_eval '((label ff (lambda "
"(x)</code>\n"
"<code class=\"western\">                     </code><code class=\"western"
"\">(cond ((atom x) x)</code>\n"
"<code class=\"western\">                           </code><code class="
"\"western\">((quote t) (ff (car x))))))</code>\n"
"<code class=\"western\">         </code><code class=\"western\">y)</code>\n"
"<code class=\"western\">       </code><code class=\"western\">'((y ((a b) "
"c))))</code>\n"
"<code class=\"western\">; returns a</code></pre>\n"
"<p>\n"
"When <code class=\"western\">_eval</code> finds <code class=\"western"
"\">label</code>,\n"
"it will store that function in <code class=\"western\">a</code> to be\n"
"used later. It will also begin evaluating the <code class=\"western"
"\">lambda</code>\n"
"function defined by <code class=\"western\">label</code>. During\n"
"evaluation, the above expression becomes</p>"
msgstr ""
"<pre class=\"western\"><code class=\"western\">(_eval '((label ff (lambda "
"(x)</code>\n"
"<code class=\"western\">                     </code><code class=\"western"
"\">(cond ((atom x) x)</code>\n"
"<code class=\"western\">                           </code><code class="
"\"western\">((quote t) (ff (car x))))))</code>\n"
"<code class=\"western\">         </code><code class=\"western\">y)</code>\n"
"<code class=\"western\">       </code><code class=\"western\">'((y ((a b) "
"c))))</code>\n"
"<code class=\"western\">; returns a</code></pre>\n"
"<p>\n"
"Когда <code class=\"western\">_eval</code> найдет <code class=\"western"
"\">label</code>, \n"
"она сохранит эту функцию в <code class=\"western\">a</code>, чтобы "
"использовать ее позже. \n"
"Она также начнет вычисление <code class=\"western\">lambda</code>-функции, "
"определенной \n"
"<code class=\"western\">label</code>. Во время вычисления/оценки приведенное "
"выше \n"
"выражение становится </p>"

#: in_ed/UnderstandingPowerLISP.html:652
msgid ""
"<pre class=\"western\"><code class=\"western\">(_eval '((lambda (x)</code>\n"
"<code class=\"western\">           </code><code class=\"western\">(cond "
"((atom x) x)</code>\n"
"<code class=\"western\">                 </code><code class=\"western"
"\">((quote t) (ff (car x)))))</code>\n"
"<code class=\"western\">         </code><code class=\"western\">y)</code>\n"
"<code class=\"western\">       </code><code class=\"western\">'((ff (label "
"ff (lambda (x)</code>\n"
"<code class=\"western\">               </code><code class=\"western\">(cond "
"((atom x) x)</code>\n"
"<code class=\"western\">                     </code><code class=\"western"
"\">((quote t) (ff (car x)))))))</code>\n"
"<code class=\"western\">         </code><code class=\"western\">(y ((a b) "
"c))))</code></pre>\n"
"<p>\n"
"The full evaluation is, as McCarthy puts it, âan activity better\n"
"suited to electronic computers than to people.â I agree and wonât\n"
"be listing out every step of evaluation.</p>"
msgstr ""
"<pre class=\"western\"><code class=\"western\">(_eval '((lambda (x)</code>\n"
"<code class=\"western\">           </code><code class=\"western\">(cond "
"((atom x) x)</code>\n"
"<code class=\"western\">                 </code><code class=\"western"
"\">((quote t) (ff (car x)))))</code>\n"
"<code class=\"western\">         </code><code class=\"western\">y)</code>\n"
"<code class=\"western\">       </code><code class=\"western\">'((ff (label "
"ff (lambda (x)</code>\n"
"<code class=\"western\">               </code><code class=\"western\">(cond "
"((atom x) x)</code>\n"
"<code class=\"western\">                     </code><code class=\"western"
"\">((quote t) (ff (car x)))))))</code>\n"
"<code class=\"western\">         </code><code class=\"western\">(y ((a b) "
"c))))</code></pre>\n"
"<p>\n"
"Полное вычисление, как выразился Маккарти, «больше подходит для электронных "
"компьютеров, \n"
"чем для людей». Я согласен и не буду перечислять каждый шаг вычисления/"
"оценки.</p>"

#: in_ed/UnderstandingPowerLISP.html:655
msgid ""
"<h3 class=\"western\"><a name=\"simplifying-_eval\"></a>Simplifying <code "
"class=\"western\">_eval</code></h3>"
msgstr ""
"<h3 class=\"western\"><a name=\"simplifying-_eval\"></a>Упрощение <code "
"class=\"western\">_eval</code></h3>"

#: in_ed/UnderstandingPowerLISP.html:660
msgid ""
"<p>Using <code class=\"western\">_eval</code> in its raw form is rather\n"
"verbose, so McCarthy defined <code class=\"western\">_apply</code> as a\n"
"wrapper to <code class=\"western\">_eval</code> that helps keep\n"
"expressions shorter and easier to understand.</p>"
msgstr ""
"<p>Использование <code class=\"western\">_eval</code> в сырой форме "
"довольно \n"
"многословно, поэтому Маккарти определил <code class=\"western\">_apply</"
"code> \n"
"как оболочку для <code class=\"western\">_eval</code>, которая помогает "
"делать \n"
"выражения короче и легче для понимания.\n"
"</p>"

#: in_ed/UnderstandingPowerLISP.html:666
msgid ""
"<p>This will take the parameters for <code class=\"western\">_eval</code>\n"
"and wrap them like <code class=\"western\">(quote (param))</code>. It\n"
"also applies arguments directly to the function.</p>"
msgstr ""
"<p>Она возьмет параметры для <code class=\"western\">_eval</code> и обернет "
"их как \n"
"<code class=\"western\">(quote (param))</code>. Она также применяет "
"аргументы \n"
"непосредственно к функции. </p>"

#: in_ed/UnderstandingPowerLISP.html:671
msgid ""
"<pre class=\"western\"><code class=\"western\">(def _appq (m)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(if (_null m) nil "
"(cons (_list 'quote (car m))</code>\n"
"<code class=\"western\">                          </code><code class="
"\"western\">(_appq (cdr m)))))</code>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:677
msgid ""
"<code class=\"western\">(def _apply (f args)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(_eval (cons f "
"(_appq args)) nil))</code></pre>\n"
"<p>\n"
"Using this function, the <code class=\"western\">ff</code> function can\n"
"be written as</p>"
msgstr ""
"<code class=\"western\">(def _apply (f args)</code>\n"
"<code class=\"western\">  </code><code class=\"western\">(_eval (cons f "
"(_appq args)) nil))</code></pre>\n"
"<p>\n"
"Используя эту функцию, функцию <code class=\"western\">ff</code> можно \n"
"записать как </p>"

#: in_ed/UnderstandingPowerLISP.html:685
msgid ""
"<pre class=\"western\"><code class=\"western\">(_apply '(label ff (lambda "
"(x)</code>\n"
"<code class=\"western\">                     </code><code class=\"western"
"\">(cond ((atom x) x)</code>\n"
"<code class=\"western\">                           </code><code class="
"\"western\">((quote t) (ff (car x))))))</code>\n"
"<code class=\"western\">        </code><code class=\"western\">'(a b))</"
"code></pre>\n"
"<p>\n"
"which calls <code class=\"western\">_eval</code> as</p>"
msgstr ""
"<pre class=\"western\"><code class=\"western\">(_apply '(label ff (lambda "
"(x)</code>\n"
"<code class=\"western\">                     </code><code class=\"western"
"\">(cond ((atom x) x)</code>\n"
"<code class=\"western\">                           </code><code class="
"\"western\">((quote t) (ff (car x))))))</code>\n"
"<code class=\"western\">        </code><code class=\"western\">'(a b))</"
"code></pre>\n"
"<p>\n"
"которая вызывает <code class=\"western\">_eval</code> как </p>"

#: in_ed/UnderstandingPowerLISP.html:697
msgid ""
"<pre class=\"western\"><code class=\"western\">(_eval '((label ff (lambda "
"(x)</code>\n"
"<code class=\"western\">                     </code><code class=\"western"
"\">(cond ((atom x) x)</code>\n"
"<code class=\"western\">                           </code><code class="
"\"western\">((quote t) (ff (car x))))))</code>\n"
"<code class=\"western\">          </code><code class=\"western\">(quote a) "
"(quote b))</code>\n"
"<code class=\"western\">       </code><code class=\"western\">'nil)</code></"
"pre>\n"
"<p>\n"
"<code class=\"western\">_apply</code> can be used for anything you\n"
"would write using <code class=\"western\">_eval</code>. But it is\n"
"useful to first understand <code class=\"western\">_eval</code> before\n"
"adding this layer of abstraction.</p>"
msgstr ""
"<pre class=\"western\"><code class=\"western\">(_eval '((label ff (lambda "
"(x)</code>\n"
"<code class=\"western\">                     </code><code class=\"western"
"\">(cond ((atom x) x)</code>\n"
"<code class=\"western\">                           </code><code class="
"\"western\">((quote t) (ff (car x))))))</code>\n"
"<code class=\"western\">          </code><code class=\"western\">(quote a) "
"(quote b))</code>\n"
"<code class=\"western\">       </code><code class=\"western\">'nil)</code></"
"pre>\n"
"<p>\n"
"<code class=\"western\">_apply</code>  можно использовать для всего, что "
"вы \n"
"пишете используя <code class=\"western\">_eval</code>. Но полезно сначала "
"понять \n"
"<code class=\"western\">_eval</code>, прежде чем добавлять этот уровень "
"абстракции.</p>"

#: in_ed/UnderstandingPowerLISP.html:700
msgid "<h2 class=\"western\"><a name=\"takeaways\"></a>Takeaways</h2>"
msgstr "<h2 class=\"western\"><a name=\"takeaways\"></a>Выводы</h2>"

#: in_ed/UnderstandingPowerLISP.html:704
msgid ""
"<p>The ability to define new languages, and monitor their internal\n"
"state makes LISP an excellent language for exploration and\n"
"experimentation.</p>"
msgstr ""
"<p>Возможность определять новые языки и отслеживать их внутреннее "
"состояние \n"
"делает LISP отличным языком для исследования и экспериментов.</p>"

#: in_ed/UnderstandingPowerLISP.html:710
msgid ""
"<p>Gone is the magic of compilation and executables. You can see\n"
"every step of evaluation for yourself. That makes the exercise of\n"
"stumbling through the archaic syntax fulfilling.</p>"
msgstr ""
"<p>Исчезла магия компиляции и исполняемых файлов. Вы можете сами увидеть \n"
"каждый этап вычисления/оценки. Это делает упражнение по "
"stumbling(спотыканию) \n"
"в архаичном синтаксисе полезным.</p>"

#: in_ed/UnderstandingPowerLISP.html:716
msgid ""
"<p>I donât see myself using LISP in production. However, I will\n"
"continue to use it as a tool for broadening my understanding of\n"
"low-level programming.</p>"
msgstr ""
"<p>Я не думаю, что буду использовать LISP в производственной среде. \n"
"Тем не менее, я буду продолжать использовать его как инструмент для \n"
"расширения своего понимания низкоуровневого программирования. </p>"

#: in_ed/UnderstandingPowerLISP.html:722
msgid ""
"<p>The next step for me is to understand how to implement a compiler\n"
"that would convert this to machine code. I plan to read <a href=\"https://"
"mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-1.html\" "
"target=\"_blank\">Structure\n"
"and Interpretation of Computer Programs</a> to do so.</p>"
msgstr ""
"<p>Следующий шаг для меня - понять, как реализовать компилятор, который \n"
"преобразует это в машинный код. Для этого я планирую прочитать \n"
"<a href=\"https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/"
"book-Z-H-1.html\" target=\"_blank\">Структура и интерпретация компьютерных "
"программ</a>.</p>"

#: in_ed/UnderstandingPowerLISP.html:729
msgid ""
"<p>Additionally, I would like to modernize this interpreter. As Paul\n"
"Graham wrote, âThe language he [John McCarthy] wrote in 1960 was\n"
"missing a lot. It has no side-effects, no sequential execution, no\n"
"practical numbers, and dynamic scope.â But this can be addressed.</p>"
msgstr ""
"<p>Дополнительно я хотел бы модернизировать этот интерпретатор. Как писал "
"Пол Грэм: \n"
"«В языке, который он [Джон Маккарти] написал в 1960 году, многое не хватало. "
"У него \n"
"нет побочных эффектов, последовательного выполнения, практических чисел и \n"
"динамической области действия ». Но с этим можно бороться.</p>"

#: in_ed/UnderstandingPowerLISP.html:735
msgid ""
"<p>Paul Graham hints at Steele and Sussmanâs article, <a href=\"https://wiki."
"c2.com/?TheArtOfTheInterpreter\" target=\"_blank\">The\n"
"Art of the Interpreter</a> without getting into specifics. Perhaps\n"
"Iâll go through these in another article.</p>"
msgstr ""
"<p>Пол Грэм намекает на статью Стила и Сассмана «Art of the Interpreter», \n"
"не вдаваясь в подробности. Возможно, я рассмотрю их в другой статье.</p>"

#: in_ed/UnderstandingPowerLISP.html:743
msgid ""
"<p>Digging through the history of programming, youâll find LISPâs\n"
"influence everywhere. The exercise of adjusting to its syntax is a\n"
"worthy pursuit in itself, but developing that true sense of\n"
"understanding opens a window into the inner workings of all\n"
"languages. That is the purpose of understanding LISP.</p>"
msgstr ""
"<p>Покопавшись в истории программирования, вы повсюду найдете влияние "
"LISP. \n"
"Попытка приспособиться к его синтаксису - достойное занятие само по себе, \n"
"но развитие этого истинного чувства понимания открывает окно во внутреннюю \n"
"работу всех языков. Это цель понимания LISP. </p>"

#: in_ed/UnderstandingPowerLISP.html:746
msgid "<hr/>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:749
msgid ""
"<ol>\n"
"\t<li/>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:754
msgid ""
"<p><a name=\"ref:1\"></a>Sinclair Target. &quot;How Lisp Became\n"
"\tGod's Own Programming Language&quot;, Two Bit History, October 14,\n"
"\t2018, accessed April 3, 2020,\n"
"\t<a href=\"https://twobithistory.org/2018/10/14/lisp.html\" target=\"_blank"
"\">https://twobithistory.org/2018/10/14/lisp.html</a></p>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:757
msgid "</ol>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:761
msgid ""
"<p><font size=\"2\" style=\"font-size: 10pt\"><a href=\"https://joshbradley."
"me/tags/lisp/\">LISP</a>\n"
"</font>\n"
"</p>"
msgstr ""

#: in_ed/UnderstandingPowerLISP.html:764
msgid ""
"</body>\n"
"</html>"
msgstr ""

<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf8"><title>Простой CLX</title></head>
<body>
<h1>Простые примеры управления X11 из Common Lisp с использованием CLX </h1>

<p>Friday 10th December 2021</p>

<p>Back online. No real changes since 2005</p>

<p>Файлы исходного кода собраны в <a href="http://alan.sdf-eu.org/clx/simple/examples/source.tar">tar-файл</a> для удобной загрузки. Он содержит три дополнительных исходных файла: 
mixed-input.lisp, animation.lisp log.op.lisp, пояснения для которых я еще не написал.</p>

<p>Могут быть некоторые несоответствия в именах файлов и именах функций. 
У меня до сих пор нет подтверждения, после прочитения этого поста. </p>

<h2>Минималистичный код для всплывающего окна</h2>

<p>Файл с исходным кодом:<a href="http://alan.sdf-eu.org/clx/simple/examples/min-pop-up-window.txt">min-pop-up-window</a></p>

<p>Сначала я пытаюсь открыть окно. Я стремлюсь к максимально простой 
программе и указываю, где она вводит в заблуждение относительно того, 
как написать правильную программу.</p>

<p>Два основных допущения протокола X: 
</p>

<ul>

    <li> Клавиатура, мышь и ЭЛТ находятся на одной машине, называемой 
	сервером. Программа, обрабатывающая данные, находится(или может находится) 
	на другом компьютере, называемом клиентом.</li>

    <li> Сервер - это многопользовательская машина, и каждый 
	пользователь сидит перед причудливой установкой, называемой дисплеем, 
	с несколькими ЭЛТ.
</li>

</ul>

<p>Итак, чудом многозадачности ваша машина притворяется двумя машинами, 
клиентской и серверной, которые общаются друг с другом через внутренний 
интерфейс loopback(обратной петли). Возможно, сейчас самое время проверить, 
действительно ли он запущен. </p>

<pre>&gt;&gt;&gt;&gt;&gt;&gt; ifconfig lo0
lo0: flags=8049<up,loopback,running,multicast> mtu 16384
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x5 
        inet6 ::1 prefixlen 128 
        inet 127.0.0.1 netmask 0xff000000 
</up,loopback,running,multicast></pre>

<p>Что ж, это нормально, и в этом есть смысл, хотя я подозреваю, 
что на моей машине клиенты действительно общаются с локальным X-сервером, 
используя сокет /tmp/.X11-unix/X0 из соображений эффективности.</p>

<p>Как минимальная программа выполняет обмен данными(установку соединения) 
между клиентом и сервером? Это не так. Она просто предполагает, что окно появилось, 
спит несколько секунд, а затем снова закрывает его, независимо от того, 
появилось окно на самом деле или нет.</p>

<h2>Построчное объяснение</h2>
<pre>    (defun pop-up-window (life-time &amp;optional (host ""))
</pre>

<p>Первый аргумент - <i>life-time</i>(время жизни) - это время, в течение 
которого программа ожидает между запросом X-сервера отобразить окно и повторным 
его закрытием. Если ничего не происходит, можно попробовать еще раз.
</p>

<p>Второй аргумент позволяет вам открыть окно на другом сервере. 
Перед тем, как это сработает, нужно разобраться с вопросами авторизации. 
Вероятно, лучше пока не пробовать её, но он подчеркивает, что если вы 
используете X, ваш код с самого начала включен в сеть. Это означает, 
что вам всегда нужно начинать с подключения к выбранному дисплею. 
</p>

<pre>    (let* ((display (xlib:open-display host))
</pre>
В принципе, дисплей представляет собой причудливую установку с 
несколькими ЭЛТ (или ЖК-дисплеями). Мы прямо указываем в коде, 
что хотим использовать первую CRT(дисплей) 
<pre> 	 (screen (first (xlib:display-roots display)))
</pre>
Что здесь происходит с квалификаторами пакетов? Почему 
<tt>xlib:display-roots</tt> но не <tt>xlib:first</tt>?
<p></p>

<p>Я не импортировал символ display-root ни через import, ни через use-package. 
Поэтому я использую квалификатор пакета, чтобы прояснить, какие вызовы функций 
характерны для X11. Однако <tt>xlib:display-roots</tt> возвращает обычный список. 
Специальной функции доступа <tt>xlib:first</tt> не требуется. Я просто использую 
<tt>first</tt> из пакета common-lisp. Я мог бы использовать <tt>car</tt>.</p>

<pre>   (root-window (xlib:screen-root screen))
</pre>

<p>Окна находятся в иерархическом дереве, где у каждого окна есть 
родительский элемент. Каждое окно, кроме специального корневого окна 
каждого экрана. Мы просим X-сервер сообщить нам корневое окно, чтобы 
мы могли передать его обратно в качестве родителя нашего собственного 
окна. </p>

<pre>	 (my-window (xlib:create-window
		     :parent root-window
		     :x 0
		     :y 0
		     :width 200
		     :height 100)))
</pre>

<p>Это строка, которую вы так долго ждали, которая создает окно. 
:x 0 и :y 0 указывают верхний левый угол. Не волнуйтесь, если это 
не то, чего вы хотите. Поскольку это окно верхнего уровня, оконный 
менеджер вмешается и поместит его туда, где он считает нужным. 
Диспетчер окон также может отменить выбранную вами ширину и высоту, 
хотя это встречается реже.</p>

<p></p>

(Вмешательство оконного менеджера, известное как перенаправление, 
нежелательно, когда вы открываете окно меню, и может быть отключено, 
то есть переопределено с помощью ":override-redirect :on". Не пробуйте 
это сейчас. Поскольку диспетчеру окон было приказано держаться подальше 
от него, он не будет ставить рамку вокруг вашего окна, поэтому может 
быть и смотреть не на что , даже если код работает.)
<p></p>

<p>Теперь мы создали окно, которое мы можем себе представить. 
Мы можем извлечь идентификатор окна с помощью xlib:drawable-id, 
отправить его по электронной почте на компьютер на другом конце света, 
который может подключиться к X-серверу через Интернет и отобразить окно, 
в результате чего оно появится на экране. Возможно, и нет. 
</p>

<pre>    (xlib:map-window my-window)
</pre>

<p>В этот момент запрос map-window находится в очереди клиента, 
ожидая отправки по сети на сервер. X11 всегда буферизует и ставит в очередь, 
кэширует и prevaricating(преобразует), чтобы минимизировать сетевой трафик. </p>

<pre>    (xlib:display-finish-output display)
</pre>

<p>Эта команда очищает выходной буфер, отправляя события и обновляя 
очередь событий любыми ответами перед продолжением. Это вводит в заблуждение 
относительно того, как написать правильную программу, и во втором примере 
<em>вместо</em> неё будет использоваться очистка буфера, встроенная в макрос 
<tt>event-case</tt>.</p>

<p>В большинстве случаев встроенная очистка буфера работает хорошо, 
минимизируя сетевой трафик, не доставляя неудобств программисту. 
Иногда она не работает так, как вы хотите. Обычно этого бывает 
достаточно нечасто, чтобы вы полностью забыли об очередях и продолжали 
тратить полчаса на поиск ошибки во всех неправильных местах. 
Так что кажется хорошей идеей сразу ввести <tt>display-force-output</tt> и
<tt>display-finish-output</tt> из-за разочарования, которое вызывают 
неочищенные(т.е не отправленные) буферы, если вы о них не знаете, 
даже если вы редко используете эти команды. </p>

<p></p>

<pre>    (format t "should appear now~%")
</pre>

<p>Это идет на стандартный вывод Лиспа. Он появляется чуть ниже того места, 
где вы ввели (pop-up-window 5), надеясь, что окно появится на пять секунд. </p>

<pre>    (sleep life-time)
</pre>
Неуравновешенный минималистский код вместо того, чтобы сделать 
правильные вещи, т.е. проверять очередь событий, чтобы увидеть, 
было ли открыто окно. 
<pre>    (xlib:destroy-window my-window)
</pre>
Помните, что вам разрешено передавать идентификаторы окружающего окна 
другим клиентам. 
<pre>    (xlib:close-display display)
</pre>
Клиенту X11 не нужно выполнять очистку или даже выходить. 
На X-сервер возложена обязанность замечать, когда соединение закрывается, 
а затем очищать его. Таким образом, вы можете убить постоянную клиентскую 
программу с помощью клиента xkill, который поставляется с X, или с помощью 
команды операционной системы. Операционная система закрывает просроченные 
соединения. X-сервер замечает их и убирает.
<p></p>

<p>Если ваша программа передала свое окно другой программе, она 
должна сообщить X-серверу, прежде чем оно будет убито, установив 
режим закрытия(close-down-mode). Когда вы полностью закончили работу 
с окном, есть команда kill-tempo-clients. </p>

<p.if you="" don't="" include="" destroy-window="" or="" close-display="" in="" the="" code="" write="" when="" are="" trying="" things="" out="" at="" repl="" end="" up="" with="" dead="" windows="" cluttering="" display="" until="" destroy="" them="" window="" manager="" commands="" exit="" your="" lisp="" image.="" this="" is="" harmless,="" but="" makes="" feel="" icky="" and="" broken.<="" p="">

<h2>Более реалистичный код для всплывающего окна</h2>

<p>Исходный файл: <a href="http://alan.sdf-eu.org/clx/simple/examples/soap-bubble.txt">Soap Bubble</a></p>

<pre>(defun blow-bubble (&amp;optional (host ""))
</pre>

<p>Ужасная задержка исчезла. Эта функция реагирует на события 
от X-сервера.</p>

<p>В предыдущем минималистичном коде появляется прозрачное окно. 
Оно слишком далеко заходит с метафорой окна. Нам нужен черный фон. 
Какое значение пикселя дает черный цвет? Помните, что клиенту нет 
смысла узнавать код черного пикселя локально. Машина, на которой он 
работает, может даже не иметь X-сервера. Вы должны пройти по сети, 
чтобы спросить об этом X-сервер, к которому вы подключены. 
</p>

<pre>   (black (xlib:screen-black-pixel screen))
</pre>
Обратите внимание, что это черный пиксель для определенного экрана. 
Я надеюсь собрать двухголовый сервер с картой nVidia в слоте AGP и 
картой Matrox в слоте PCI. Что произойдет, если две разные видеокарты 
используют разные коды для черного? Я должен быть OK(в порядке?/на связи?) 
с X-сервером, возвращающим код карты, которая управляет экраном, 
о котором я спрашивал. 
<p></p>

<p>Получив код черного пикселя, используем его в xlib:  
<tt>xlib:create-window</tt>
</p>

<pre>:background black
</pre>
Другое большое отличие от минималистичного кода - это обработка событий. 
Это окно похоже на soap bubble(мыльный пузырь). Он остается вверху, 
пока мы не нажмем на него курсор мыши. Также мы вводим, но не используем 
событие exposure(воздействия).
<p></p>

<p>Событие exposure(воздействия) имеет решающее значение. 
X-сервер не делает заметок о том, что было нарисовано в вашем окне. 
Если ваше окно закрывается, содержимое теряется. Когда оно обнаружено, 
X-сервер отправляет событие expose(раскрытия). Оно не означает, 
что окно открыто, теперь вы можете что-нибудь нарисовать. Оно также
означает X-сервер, говорящий: «Я потерял содержимое, напомните мне, 
что должно было быть в окне». 
</p>

<pre>:event-mask (xlib:make-event-mask :exposure
			          :enter-window)
</pre>
Это устанавливает окно для приема событий exposure(экспонирования). 
Вы почти всегда хотите получать события exposure(экспонирования/отображения). 
Оно также устанавливает окно для приема событий с enter-notify(уведомлением о вводе). 
Это позволяет нам "лопнуть" окно, как мыльный пузырь, пуф, даже 
без щелчка мышью. Это событие удобно использовать в простом примере, 
но оно не так важно, как можно догадаться по названию. Ввод с клавиатуры 
и нажатие кнопок автоматически переходят в выбранное окно. Если окно запросило 
события нажатия клавиш и кнопок, оно получит их, и ему не нужно отслеживать 
вход и выход курсора мыши. Enter-notify полезен, если вы хотите, чтобы окно 
меняло цвет, чтобы предупреждать пользователя, в каком окне он 
собирается щелкнуть. 
<pre>    (xlib:event-case (display :force-output-p t
			      :discard-p t)
      (:exposure ()(format t "Exposed~%"))
      (:enter-notify () t))
</pre>
Это ядро программы clx. Различные события распределяются по коду, 
который их обрабатывает. Первое, что следует заметить, это 
отсутствие  <tt>xlib:display-force-output</tt>. Мы установили ключевое слово: 
<tt>:force-output-p</tt> для eventcase. Оно указывает event-case 
очищать выходной буфер перед проверкой событий. Поскольку event-case 
занимает центральное место в программировании clx, сбросы буфера, 
вызванные: <tt>:force-output-p</tt>, часто являются всеми необходимыми 
очистками буфера. Итак, у нас есть все необходимое, чтобы забыть о 
сбросе/очистке выходного буфера и попасть в ловушку из-за того, 
что мы забываем, что это необходимо делать.
<p></p>

<p>Макрос xlib:event-case имеет две умные функциональности 
</p>

<ul>

    <li><tt>xlib:event-case</tt> определяет, пометил ли код обработчика событие 
	как завершенное или его следует оставить в очереди событий.</li>

    <li><tt>xlib:event-case</tt> делает больше, чем просто отправляет события, 
	он также может действовать как цикл, повторно отправляя(dispatching) 
	события.</li>
</ul>
Как ни странно, они оба используют один и тот же механизм. Конечное значение, 
выдаваемое кодом, обрабатывающим событие, обычно интерпретируется как истина 
или ложь, и этому логическому значению придается двойное значение.
<p></p>

<p>Если true, событие отмечается галочкой (в документации 
`processed'(обработано)) и удаляется из очереди событий. 
Если false, событие не отмечается галочкой (в документации 
`unprocessed'(необработано)) и висит где-то поблизости, 
чтобы потом вернуться и всё равно достать вас.</p>

<p>Если true(истина), неявный цикл event-case выполнил свою работу 
и завершился. Если false, неявный цикл case-case повторяется для 
еще одной попытки.</p>

<p>Странная маленькая линия
</p>

<pre>:discard-p t 
</pre>
жизненно важна. В ней говорится, что после отправки события и 
запуска некоторого кода для его обработки оно удаляется из 
очереди событий, даже если оно не было отмечено галочкой. 
(В документации это называется «отбрасыванием необработанных событий»
("discarding unprocessed events"), что создает обманчивое 
впечатление.) 
<pre>(:exposure ()(format t "Exposed~%"))
</pre>
В реальном приложении это запускает код для перерисовки экрана. 
Мы же просто отмечаем прибытие события в терминал Лиспа. Помните 
функцию первого аргумента format 
<pre>format stream --- output to stream, return nil
format t --- output to standard output, return nil
format nil --- output to string, return string
</pre>
Таким образом, формат возвращает nil, и event-case повторяется для 
другой попытки. 
<pre>(:enter-notify () t))
</pre>
это возвращает истину, поэтому цикл event-case завершается, и программа 
перейдет к уничтожению окна и завершении работы. 
<p></p>

<h2>Создание отметок</h2>

<p>Исходный файл: <a href="http://alan.sdf-eu.org/clx/simple/examples/graphic-x.txt">graphic-x</a></p>

<p>Вероятно, довольно неприятно, что только в третьем примере 
можно что-либо нарисовать на экране. Я задержался, потому что 
вы не можете просто нарисовать линию, вы должны сначала создать 
графический контекст. Стоит уделить немного времени рассмотрению 
двух проблем, для решения которых предназначены графические 
контексты.</p>

<p>Первая проблема заключается в том, что можно быстро обнаружить, 
что существует множество вариантов рисования линии. Насколько она толстая, 
какого цвета. Если она толстая, есть ли у неё заглушка? Если да, то круглая 
или квадратная. Она разбита(dashed)? Если да, то какова длина тире и промежутка, 
или существует более сложная схема. Более тонко, это только что образовавшийся 
зазор или он окрашен в цвет фона? Конечно, не хочется вводить все эти разные 
параметры каждый раз, когда нужно нарисовать линию. Есть выбор решений. Либо 
оно использует преимущества параметров ключевого слова Lisp, например, ключевое 
слово: thickness для установки толщины линий, либо имеет графический контекст, 
в котором хранятся ваши любимые настройки. </p>

<p>Вторая проблема заключается в том, что нужно помнить, что X11 
задуман как сетевая оконная система. Очевидно, что необходимо 
отправлять координаты конечных точек по сети, но нужно избегать 
повторной отправки данных о цвете и толщине по сети. Графический 
контекст должен находиться на сервере.</p>

<p>Предположение, лежащее в основе X11, заключается в том, 
что вам часто нужно вносить изменения в графический контекст, 
иногда рисовать красным, иногда синим, некоторые линии толстые, 
другие тонкие, но вы будете использовать ограниченный набор параметров. 
Например, линий могут быть сотни, но все они попадают в одну из 
четырех категорий: толстый красный, тонкий красный, толстый синий, 
тонкий синий.</p>

<p>В X11 это работает так: клиент устанавливает небольшое количество 
графических контекстов на сервере. Команды рисования указывают числовой 
идентификатор графического контекста. Поэтому очень дешево нарезать и 
менять графические контексты.</p>

<p>Клиенты также могут изменять содержимое графического контекста. 
CLX сохраняет изменения и сохраняет локальную копию, отправляя их 
по сети только по мере необходимости. </p>

<pre>(defun graphic-x (width height &amp;optional (host ""))
</pre>

<p>Мы собираемся нарисовать большой крестик поперек окна двумя линиями. 
Линии будут нарисованы в соответствии с аргументами функции, поэтому, 
если оконный менеджер не предоставит вам запрашиваемый размер, линии не 
будут точно входить в углы, как предполагалось. 
</p>

<pre> 	 (grackon (xlib:create-gcontext
		   :drawable root-window
		   :foreground white
		   :background black))
</pre>
Нам нужно сохранить графический контекст в переменной, потому 
что в принципе у нас может быть несколько разных контекстов. 
Мы храним только локальную копию CLX. Важно то, что она содержит 
числовой идентификатор, который CLX вставляет в вызовы по сети. 
Я изо всех сил пытался придумать имя переменной. 
graphics-context слишком длинный. gc наоборот короткое. g-context 
и graphics-c слишком однобокие. gra-con слишком уродлив. 
grackon не намного лучше, но добавление k почти делает из 
него слово. 
<pre>    (describe grackon)
</pre>
Используем встроенную команду описания Common Lisp для отображения 
некоторой информации в окне Lisp. Это не обязательно, но помогает 
понять, что происходит.
<p></p>

<p>Теперь мы реагируем на события exposure, рисуя: 
</p>

<pre>      (:exposure ()
		 (xlib:draw-line my-window
			    grackon
			    0 height
			    width 0)
		 (xlib:draw-line my-window
			    grackon
			    0 0
			    width height))
</pre>
Вызовы такие же, как и следовало ожидать: в какое окно 
входит линия, в графическом контексте указываются все детали, 
а четыре числа задают координаты конечных точек.
<p></p>

<p>Я немного изменил маску событий и список событий в event-case. 
Теперь окно остается открытым, пока вы не нажмете в нем кнопку. 
Так что удобно изменять размер окна, уменьшать его и уменьшать, 
и видеть, что вы перерисовываете тот же старый X. </p>

<h2>Построение графика функции</h2>

<p>Исходный файл: <a href="http://alan.sdf-eu.org/clx/simple/examples/graph-f.txt">graph-f</a></p>

<p>Мы только что использовали процедуру draw-line(рисования линии) 
Xlib, чтобы нарисовать линию. Естественно окунуться в построение 
графика функции, написав цикл для рисования множества линий, от (0, f(0)) 
до (1, f(1)) и от (1, f(1)) до (2, f(2)) и так далее. Подождите. 
В Xlib есть команда draw-lines, которая принимает последовательность чисел, 
чередуя координаты x и y. Она связывает линии за вас, используя стиль 
соединения в графическом контексте, и может даже заполнить вашу фигуру за вас, 
если вы хотите, чтобы линии представляли многоугольник.</p>

<p>Чтобы получить большую функциональность, мы упрощаем наш код CLX! 
Мы реагируем на события exposure следующим образом: 
</p>

<pre>      (:exposure ()
		 (xlib:draw-lines my-window
				  grackon
				  points)
		 nil)
</pre>
Вся остальная функциональность обеспечивается обычным кодом Common Lisp, 
который не вызывает CLX.
<p></p>

<p>На самом деле другой код выполнен в стиле CLX. Естественный стиль 
Common Lisp - использовать последовательность точек. CLX использует 
последовательность в два раза длиннее, чередуя x и y. Это приводит к 
неуклюжему коду. Я провожу вас через него.</p>

<p>Сначала попробуйте функцию single-graph с чем-нибудь вроде  
</p>

<pre>(single-graph #(0 0 100 100 200 300 300 0) 400 400)
</pre>
Хорошо, это работает, но есть разные проблемы. X работает вниз 
от верхнего края экрана, поэтому график идет вверх неправильно. 
График имеет размер в пикселях. График не масштабирован под 
размер окна.
<p></p>

<p>Начнем с процедуры создания массива для построения графика функции 
<i>y</i>=<i>f</i>(<i>x</i>). Мы пользуемся преимуществом того факта, 
что CL позволяет использовать любые символьные знаки в имени символа 
для вызова нашей функции <i>x,f(x)</i> что напоминает нам, что она 
генерирует список, который чередует <i>x1,f(x1),x2,f(x2),...</i> 
Вертикальные линии - важные символы цитирования. Они позволяют использовать 
запятые и круглые скобки в именах символов точно так же, как "позволяет 
вам использовать их в строках".</p>

<p><tt>|x,f(x)|</tt> передается функция f и вызывает ее несколько раз, 
чтобы построить массив, табулирующий функцию в диапазоне от x-min до x-max. 
Единственными уступками этому графическому коду являются включение параметра 
разрешения, указывающего, сколько точек нужно построить, и использование 
собственного макета данных CLX.</p>

<p>Если мы собираемся масштабировать эти данные по размеру окна, 
нам нужно знать минимальное и максимальное значения. Оно вычисляется 
с помощью bound-xy-vec. </p>

<p><tt>fit-xy-to-window</tt> использует <tt>bound-xy-vec</tt> для 
нахождения минимумов и максимумов, а затем создает новый массив целых 
чисел, масштабированных и округленных для отображения. Обратите внимание 
на естественное использование второго аргумента для округления, чтобы 
разделить диапазон от минимального до максимального.</p>

<p>Наконец, normalized-graph дублирует свои аргументы ширины и высоты, 
чтобы масштабировать данные построения и установить размер окна. 
Здесь мы теряем шанс изменить размер графика при изменении размера окна, 
поэтому это код, который нам нужно исправить в более позднем, не совсем 
простом примере.</p>

<p>Итак, мы можем построить несколько циклов синусоидальной волны 
</p>

<pre>(normalised-graph (|x,f(x)| 100 (- pi) (* 3 pi) #'sin)
		    400 200)
</pre>
или параболы 
<pre>(normalised-graph (|x,f(x)| 100 -3 3
		  #'(lambda(x)(* x x)))
		  400 400)
</pre>
Такое программное обеспечение обычно работает так, что массив содержит 
только данные y. Данные x неявно присутствуют в начальном значении и 
приращении. Поскольку мы использовали представление CLX, в котором 
координаты x указаны явно, легко построить параметрическую кривую, 
предоставив функции для x и y. <tt>|x(t),y(t)|</tt> строит массив. 
Не попадитесь в ловушку, используя t для переменной. t - это константа, 
которую CL резервирует для представления истины.
<p></p>

<p>Итак, рисуем круг с помощью
</p>

<pre>(normalised-graph (|x(t),y(t)| 100 0 (* 2 pi) #'cos #'sin)
		  400 400)
</pre>
и фигуру Лиссажу с помощью
<pre>(normalised-graph (|x(t),y(t)| 100 0 (* 2 pi)
		  #'(lambda(x)(sin (* 2 x))) #'sin)
		  400 400)
</pre>
CL поддерживает комплексные числа, а комплексные числа естественным 
образом интерпретируются как точки на плоскости. <tt>|z(t)|</tt> строит 
путь на комплексной плоскости. Мы можем нарисовать круг с помощью 
<pre>(normalised-graph (|z(t)| 100 0 (* 2 pi)
		   #'(lambda(theta)(exp (* #c(0 1) theta))))
		   400 400)
</pre>
и циклоид с помощью
<pre>(normalised-graph (|z(t)| 100 0 (* 3 pi)
		   #'(lambda(theta)
		       (+ theta 
			  (exp (* #c(0 1)
				  (- (* 3/2 pi) 
				     theta))))))
		  800 200)
</pre>
Я включил процедуру изготовления красивых выкроек из 
игрушки-спирографа из моего детства. 
<pre>(normalised-graph (|z(t)| 1000 0 (* 2 pi)
		   (cycloid 3 10 13 5))
		   400 400)
</pre>
Упс. Предполагается, что это будут «простые примеры в CLX», 
а не «сложные переменные, от которых у вас закружится голова». 
Вернемся к коду. Все вызовы CLX разделены на один график. 
Однако CLX-ность просачивается в остальную часть кода из-за 
использования структуры данных CLX с чередованием x и y. 
Это может привести к тому, что более чистый код Common Lisp 
будет использовать более естественную структуру данных, 
возможно, с определением точечной структуры и использованием 
массива точек. Комплексные числа уже обеспечивают это. Возможно, 
лучше всего подойдет массив комплексных чисел. С другой стороны, 
эта веб-страница посвящена CLX. Представляется целесообразным 
использовать схему данных CLX в примере кода. 
<p></p>

<h2>Понимание exposure(экспозиции)</h2>

<p>Исходный файл: <a href="http://alan.sdf-eu.org/clx/simple/examples/understanding-exposure.txt">understanding-exposure</a></p>

<p>Цель событий exposure(экспонирования) - позволить клиенту перерисовать 
только что открывшиеся части окна. Простой примерный код не должен 
ограничиваться этим намерением. Функция 
</p>

<pre>(defun show-exposure-events (width height &amp;optional (host ""))
</pre>
не перерисовывает существующее изображение, как это должна делать хорошая 
программа CLX. Вместо этого эта злодейская функция помещает диагональные 
кресты в прямоугольники, предоставленные событиями exposure(экспозиции), 
чтобы мы могли видеть сами события экспозиции. 
<pre>      (:exposure (count x y width height)
		 (format t "~A~%" count)
		 (xlib:draw-line my-window
			    grackon
			    x y
			    width height
			    t)
		 (xlib:draw-line my-window
			    grackon
			    x (+ y height)
			    (+ x width) y))
</pre>
На поверхности события exposure(экспозиции) выглядят очевидными. 
Ваше окно закрыто. Вы выделяете иконку закрывающего окна, открывая 
свое окно под ним, и ваше окно получает событие expose с подробным 
описанием прямоугольника, который был открыт(требует экспонирования/отображения).
<p></p>

<p>Всегда ли открытая область прямоугольная? Нет.</p>

<p>Сократите один из ваших терминалов X так, чтобы он помещался 
внутри этого окна программы, и оставьте его сверху. Разверните 
другое окно так, чтобы оно закрывало оба, и поместите его сверху. 
Теперь выделите иконкой большое окно, открывающее это окно программы, 
и меньшее окно, расположенное поверх него. Открытая область образует 
кольцо. Оно не прямоугольное. Это даже не просто связано. Хуже того, 
можно использовать два маленьких окна для создания события, которое 
открывает область с двумя отверстиями в ней. Попробуй и увидишь. 
Станет очевидно, для чего предназначена  переменная count. </p>

<p>Классическое использование count(счетчика) - определить, 
что одно действие выявило непрямоугольную область, и просто сдаться. 
События экспонирования гарантированно будут непрерывными в очереди 
событий с обратным отсчетом до нуля, поэтому программа отбрасывает 
события экспонирования с положительным значением счетчика, а по 
окончании обратного отсчета перерисовывает все окно.</p>

<p>Это адекватный подход? Вы заметите проблему, когда переместите 
другие окна над окном функции show-extension-events. Создается 
множество узких прямоугольников. Если реальная программа приступит 
к тщательно продуманному пересчету всего окна для каждого из 
множества узких прямоугольных событий экспонирования, она может 
безнадежно застрять. К сожалению, X-сервер не может производить 
обратный отсчет. Он не знает, когда пользователь перестанет 
размахивать верхним окном, так с чего же начнется отсчет? </p>

<p>Два возможных ответа: один заключается в том, что клиенты, 
представляющие результаты медленных вычислений, должны кэшировать 
результаты на своей стороне сети и повторно передавать их из своего 
явно управляемого кеша. В качестве альтернативы создайте растровое 
изображение на стороне сервера. Запишите данные в растровое 
изображение и попросите клиентскую программу выдать инструкции X-серверу, 
чтобы скопировать растровое изображение в окно клиентских программ. 
Но где хранятся растровые изображения? В видеокарте? В основной памяти
серверных машин . Я не знаю.</p>

<p>Сейчас нам не нужно решать эти проблемы. Достаточно просто 
иметь представление о том, что вызывает события exposure, и с 
чем приходится справляться вашей клиентской программе, вплоть 
до чисел и форм. </p>

<h2>Hello World</h2>

<p>Исходный файл: <a href="http://alan.sdf-eu.org/clx/simple/examples/hello-world.txt">hello-world</a></p>

<p>В простых примерах используются значения по умолчанию. 
Команды clx для размещения текста на экране рисуют его под 
контролем графического контекста. Графический контекст содержит 
поле для информации о шрифте, и предполагается, что по умолчанию 
используется что-то полезное. Таким образом, мы можем заменить 
наши перекрещенные линии текстом. </p>

<h2>Ragged Right(Рваный справа)</h2>

<p>Исходный файл: <a href="http://alan.sdf-eu.org/clx/simple/examples/ragged-right.txt">ragged-right</a></p>

<p>Некоторые примеры настолько просты, что бесполезны. В частности, 
нужно вызвать <tt>xlib:text-width</tt>, чтобы отслеживать интервалы, 
а для этого необходимо знать, какой шрифт вы используете. Просто 
позволить ему остаться по умолчанию на самом деле не срабатывает. </p>

<p>Очевидно, что нужно иметь дополнительную переменную <tt>font</tt>(шрифт), 
инициализированную вызовом <tt>xlib:open-font</tt>
</p>

<pre>(font (xlib:open-font
	display
	"-*-lucida-medium-r-*-*-12-*-*-*-*-*-*")
</pre>
Этот шрифт можно передать вызову <tt>xlib:create-gcontext</tt>. 
Альтернатива есть. Если аргумент font для <tt>xlib:create-gcontext</tt> 
является строковым, <tt>xlib:create-gcontext</tt> откроет шрифт 
для вас, используя строку в качестве имени. Исходя из многолетнего опыта 
программирования на статически типизированных языках, я сразу заметил 
недостаток альтернативы. Я бы не смог написать:
<pre>(xlib:text-width font word)
</pre>
но должен получить доступ к компоненту шрифта графического контекста 
таким образом: :
<pre>(xlib:text-width (xlib:gcontext-font grackon) word)
</pre>
Мой многолетний опыт работы со статически типизированными языками ввел 
меня в заблуждение. Да, <tt>xlib:text-width</tt> ожидает шрифт, 
но если ему задан графический контекст, он не вызывает ошибку типа, 
он просто извлекает шрифт из графического контекста и продолжает работу. 
Итак, <tt>ragged-right.lisp</tt> не имеет отдельной переменной для 
шрифта, а просто имеет 
<pre>(xlib:text-width grackon word)
</pre>
Это работает не совсем гладко. Еще нужно написать 
<pre>(xlib:font-ascent (xlib:gcontext-font grackon))
</pre>
Настоящий код (обычно) импортирует пакет xlib и не использует 
квалификатор пакета xlib. (Я уже не так уверен в этом. Почему бы 
не написать оболочку <tt>alan:font-ascent</tt>, которая извлекает 
шрифт из графического контекста? Почему бы не написать оболочку 
<tt>alan:draw-line</tt> на <tt>xlib:draw-line</tt>, которая 
запоминает строку, готовую к событиям последовательности expose?)
<p></p>

<p>Здесь есть более общий момент о разнице между программированием 
на статически типизированных языках и программированием на динамически 
типизированных языках, таких как CL. Я привык писать статически 
типизированный код, такой как
</p>

<pre>(eat-fruit apple)
(eat-fruit (peel bananna))
</pre>
и получаю ошибку типа, если я забываю извлечь компонентную 
часть из агрегата перед передачей ее подпрограмме, которая 
ожидает компонентную часть. В CL я могу очистить свой код, 
вставив извлечение компонентов из агрегатов в код, 
обрабатывающий компоненты. Универсальные функции в CLOS 
предоставляют удобный способ кодировать это. Но я думаю, 
что выиграю, только если смогу быть более основательным, 
чем Xlib. Умение писать (eat-fruit bananna) является преимуществом 
только в том случае, если можно также писать (eat-fruit orange). 
Я не хочу вспоминать, что могу писать (eat-fruit bananna), 
но все равно писать (eat-fruit (peel orange)) 
<p></p>

<p>Хватит болтовни кодера, вернемся к запуску настоящего кода.
</p>

<p>Смысл установки текста состоит в том, чтобы позволить 
пользователю программы изменять размер текстового окна и 
перекомпоновывать текст в соответствии с требованиями, 
но позиции слов в окне вычисляются в X-клиенте (подумайте: 
большая машина в подвале) в то время как размер окна 
контролируется X-сервером, машиной, к которой вы прикасаетесь 
и видите. X-сервер должен уведомлять X-клиент об изменениях 
в конфигурации окна.</p>

<p>Мы добавляем: <tt>:structure-notify</tt> к маске событий нашего окна, 
чтобы оно слушало(listening). Мы также положили
</p>

<pre>(:configure-notify (width height)
	 (setf actual-width width actual-height height)
	 nil)
</pre>
в цикле событий, чтобы клиентская программа оставалась 
актуальной с размером окна, когда пользователь изменяет 
его через оконный менеджер, запущенный на X-сервере. 
<p></p>

<p>В руководстве Xlib четко указано, что если оконный менеджер 
изменяет размер окна перед его отображением, событие Configure-Notify 
появляется в очереди перед первым событием Expose. Мой код зависит 
от события Configure-Notify для инициализации фактической ширины и 
высоты, даже если оконный менеджер дает мне размер, который я прошу. 
Я не нашел документации о том, разрешено ли мне это делать. 
Пожалуйста, напишите мне, если найдете.</p>

<p>Функция ожидает текст в виде списка слов, поэтому
</p>

<pre>(ragged-right '("The" "cat" "sat" "on" "the" "mat."))
</pre>
показывает особенно банальную фразу. Измените размер окна и
посмотрите, как идет текст. 
<p></p>

<p>Представление текста в виде списка слов упрощает запись 
неразрывного пробела.
</p>

<pre>(ragged-right '("The cat" "sat" "on" "the mat."))
</pre>
предотвращает разрывы после слова «the». Однако это 
представление болезненно вводить. Итак, ragged-right.lisp 
включает подпрограмму для разбиения строки по внутренним 
знакам - пробелам. Вырежте и вставьте
<pre>(ragged-right (white-space-split
"Ragged right setting is easier than justified setting.
This is both a strength and a weakness.  Although the
regular word spacing of ragged right setting is easier on
the reader's eye, in craft work there is honour and glory in
doing things the hard way. The reader of justified text
knows of the labour and expense, and is flattered to get
something for nothing, even if it is worth what he paid."))
</pre>
чтобы увидеть более крупный пример. 
<p></p>

<p>Обратите внимание, что каждое событие expose генерирует 
огромное количество сетевого трафика. xlib:draw-glyph для 
каждого слова в тексте, даже если оно не помещается в окне 
и просто отбрасывается X-сервером. На моем Pentium 166 МГц 
можно заметить небольшие задержки. Сомневаюсь, что вы заметите 
проблему на своей блестящей современной машине. Однако есть одна 
интересная идея - развернуть веб-службы с использованием X11 
вместо HTTP. Для этого потребуется гораздо лучший код. </p>

<h2>Цветные прямоугольники(Coloured rectangles)</h2>

<p>Исходный файл: <a href="http://alan.sdf-eu.org/clx/simple/examples/mondrian.txt">Mondrian</a></p>

<p>Отойдя от текста на несколько минут, давайте посмотрим на цвет. 
Очевидная демонстрационная программа для цвета - это отображение 
нескольких цветных прямоугольников, поэтому исходный файл начинается 
довольно очевидным образом со структуры цветного прямоугольника. 
Очевидно, что процедура random-choice(случайного выбора) заключается 
в выборе цвета из списка цветов. </p>

<p>Встроенная функция make-list в Common Lisp не совсем соответствует 
нашим потребностям, потому что она вычисляет исходную форму элемента 
только один раз, поэтому мы определяем нашу собственную версию cons-up 
для многократного вызова конструктора. </p>

<p>Что ж, у нас есть список цветов '(red green blue ... ), 
и нам нужен графический контекст для каждого цвета, чтобы 
мы могли переключаться от контекста к контексту, когда мы 
спускаемся вниз по списку прямоугольников, рисуя каждый в 
своем собственном цвете. Есть много способов сопоставить 
символы с графическими контекстами. Я решил поместить 
графический контекст в список свойств символа как его 
свойство grackon.</p>

<p>Сначала мы вносим дополнения в списки свойств, 
я должен был использовать mapc или, еще лучше, dolist. 
</p>

<pre>    (mapcar
     #'(lambda(colour-symbol)
	 (setf (get colour-symbol 'grackon)
	       (xlib:create-gcontext
		   :drawable root-window
		   :foreground (xlib:alloc-color
				(xlib:window-colormap root-window)
				(symbol-name colour-symbol))
		   :background black)))
     *colour-list*)
</pre>
Важным новым вызовом является xlib:alloc-color. Он принимает 
спецификацию цвета: столько красного, столько зеленого, столько синего 
и сообщает вам значение пикселя, которое нужно отправить на видеокарту 
для получения этого цвета. Внутренняя работа X11 содержит некоторые 
текстовые файлы, в которых говорится, что «желтый» - это красный и 
зеленый, а «авокадо» - в основном зеленый, и так далее, поэтому вы 
можете передать строку alloc-color, и она будет искать красный, 
зеленый и синие компоненты для вас. В самом деле, вы можете передать 
ему символ, и он будет использовать имя символа для поиска строки. 
Кроме того, некоторые видеокарты позволяют изменять карту цветов, 
поэтому X считает карты цветов принадлежащими окнам. xalloc-color 
нужно указать, какое окно использовать. Мы используем root-window(корневое-окно).
<p></p>

<p>Вызов <tt>xlib:draw-rectangle</tt> в основном соответствует вашим 
ожиданиям. Необязательный параметр <tt>fill-p</tt> мог быть просто 
<tt>t</tt>, но меня раздражает наличие анонимных констант в конце 
списков параметров. <tt>'fill</tt> так же хорошо говорит "да" компьютеру, 
а также напоминает программисту о том, что он сказал "да". </p>

<h2>Более цветные прямоугольники</h2>

<p>Исходный файл: <a href="http://alan.sdf-eu.org/clx/simple/examples/subwindow.txt">subwindow</a></p>

<p>Окна живут в иерархических деревьях. Пока что наше единственное 
окно бездетно. Давайте изменим это, создав несколько подокон, 
отличающихся цветом фона.</p>

<p>Первое, что бросается в глаза, - это отсутствие  событий expose. 
Вы всегда опускаете события expose только в простом примере кода. 
Я здесь говорю. X-сервер заботится о фонах окон за вас. Командная строка, 
например 
</p>

<pre>(graphic-x 300 300 50 50)
</pre>
заставляет окна накладываться друг на друга, поэтому вы можете 
увидеть эффект их перемещения, нажав клавишу.
<p></p>

<p>Также обратите внимание, что X-сервер отслеживает, в каком из 
ваших окон находится курсор. Хотя X находится на довольно низком 
уровне, есть некоторые важные домашние задачи, которые он скрывает 
от вас. </p>

<h2>Параграфы(Paragraphs), или продолжение Ragged Right</h2>
<dl>
<dt>Исходный файл
</dt><dd> <a href="http://alan.sdf-eu.org/clx/simple/examples/paragraphs.txt">paragraphs</a>
</dd><dt>Пример текста
</dt><dd> <a href="http://alan.sdf-eu.org/clx/simple/examples/escape.txt">escape</a>
</dd></dl>

<p>Я внес постепенные улучшения в ragged-right.lisp, изменив порядок 
кода и улучшив его для отображения более одного параграфа. 
Одно вычисление
</p>

<pre>(paragraphs "escape")
</pre>
чтобы прочитать текст в образце файла. Если я сделаю еще два шага 
для развития этого кода, это будет интересный момент. Этот шаг не 
вводит никаких новых функций CLX.
<p></p>

<h2>Аналоговый ввод</h2>

<p>Исходный файл: <a href="http://alan.sdf-eu.org/clx/simple/examples/analogue-input.txt">analogue-input</a></p>

<p>Одним из пунктов изучения CLX является определение положения указателей, 
чтобы вы могли оснастить свои программы аналоговыми элементами управления. 
Затем положения указателя на экране могут представлять числа, выше по экрану 
для большего числа, дальше вправо для большего числа.
</p>

<p>Эта небольшая процедура позволяет пользователю вводить два числа, 
щелкая по окну. Например 
</p>

<pre>(pick2numbers 400 100)
</pre>
всплывает окно шириной 400 пикселей и высотой 100 пикселей. 
Можете ли вы ввести (200 . 50), щелкнув точно посередине?
<p></p>

<p>Для <a href="http://alan.sdf-eu.org/clx/simple/examples/understanding-exposure.txt">понимания
 экспозиции(exposure)</a> мы извлекли некоторые параметры из события 
exposure(экспозиции) с помощью 
</p>

<pre>(:exposure (count x y width height)
</pre>
Теперь мы получаем положение указателя, извлекая его из 
события button-press(нажатия кнопки). 
<pre>(:button-press(x y)
</pre>
X11 нумерует свои пиксели, как если бы он использовал регистры 
в интегральной схеме видеоконтроллера, которая сканирует электронный 
луч слева направо и сверху вниз. Это прошло незамеченным в ragged-right.lisp. 
Увеличение количества строк приводило к тому, что строки с более 
высокими номерами отображались внизу страницы в совершенно естественном 
порядке чтения сверху вниз.
<p></p>

<p>Однако здесь мы сталкиваемся с конфликтом  интуиций. Если на дисплее 
отображается какой-то математический график, y должен увеличиваться на 
экране. Нумерация сверху вниз, которую использует X11 и которая так 
естественна для текста, является неправильной для аналогового ввода, 
поэтому мы исправляем ее, просто избегая ошибок по одной.
</p>

<pre>(cons x (- y-range (+ y 1))
</pre>
<p></p>

<p>Мы также поместили заголовок в строку заголовка окна. 
Это важный косметический штрих. Стоит задуматься, что это должно 
быть невозможно. Конечно, мы можем рисовать текст внутри нашего окна, 
но X11 окна наши команды рисования помещаются внутри окна, а оконный 
менеджер помещает свою рамку вокруг нашего окна, строго за его пределами. 
Как нам удалось писать за пределами собственного окна?</p>

<p>Мы этого не делали. Мы поговорили с оконным менеджером, и он 
разместил наш заголовок для использования. Отсюда новая команда 
</p>

<pre>xlib:change-property
</pre>
Она придает окнам произвольные свойства. Очевидно, мы прикрепляем 
свойство к нашему собственному окну. Диспетчер окон ищет свойство
:wm_name  в каждом из окон, которыми он управляет, чтобы увидеть, 
что у них есть имя. Мы предоставили имя "Pick two numbers"(Выбор 
двух чисел», типа :string, формат 8-битных байтов, и мы указали, 
что строка должна быть представлена своим символьным кодом. Это 
должно происходить по умолчанию, но на моем компьютере это не работает. 
<p></p>

</p.if></body></html>